{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ContextDependencyHelpers = exports;\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quotemeta = str => {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\nconst splitContextFromPrefix = prefix => {\n  const idx = prefix.lastIndexOf(\"/\");\n  let context = \".\";\n  if (idx >= 0) {\n    context = prefix.substr(0, idx);\n    prefix = `.${prefix.substr(idx)}`;\n  }\n  return {\n    context,\n    prefix\n  };\n};\nconst splitQueryFromPostfix = postfix => {\n  const idx = postfix.indexOf(\"?\");\n  let query = \"\";\n  if (idx >= 0) {\n    query = postfix.substr(idx);\n    postfix = postfix.substr(0, idx);\n  }\n  return {\n    postfix,\n    query\n  };\n};\nContextDependencyHelpers.create = (Dep, range, param, expr, options, contextOptions,\n// when parser is not passed in, expressions won't be walked\nparser = null) => {\n  if (param.isTemplateString()) {\n    let prefixRaw = param.quasis[0].string;\n    let postfixRaw = param.quasis.length > 1 ? param.quasis[param.quasis.length - 1].string : \"\";\n    const valueRange = param.range;\n    const {\n      context,\n      prefix\n    } = splitContextFromPrefix(prefixRaw);\n    const {\n      postfix,\n      query\n    } = splitQueryFromPostfix(postfixRaw);\n\n    // When there are more than two quasis, the generated RegExp can be more precise\n    // We join the quasis with the expression regexp\n    const innerQuasis = param.quasis.slice(1, param.quasis.length - 1);\n    const innerRegExp = options.wrappedContextRegExp.source + innerQuasis.map(q => quotemeta(q.string) + options.wrappedContextRegExp.source).join(\"\");\n\n    // Example: `./context/pre${e}inner${e}inner2${e}post?query`\n    // context: \"./context\"\n    // prefix: \"./pre\"\n    // innerQuasis: [BEE(\"inner\"), BEE(\"inner2\")]\n    // (BEE = BasicEvaluatedExpression)\n    // postfix: \"post\"\n    // query: \"?query\"\n    // regExp: /^\\.\\/pre.*inner.*inner2.*post$/\n    const regExp = new RegExp(`^${quotemeta(prefix)}${innerRegExp}${quotemeta(postfix)}$`);\n    const dep = new Dep(Object.assign({\n      request: context + query,\n      recursive: options.wrappedContextRecursive,\n      regExp,\n      mode: \"sync\"\n    }, contextOptions), range, valueRange);\n    dep.loc = expr.loc;\n    const replaces = [];\n    param.parts.forEach((part, i) => {\n      if (i % 2 === 0) {\n        // Quasis or merged quasi\n        let range = part.range;\n        let value = part.string;\n        if (param.templateStringKind === \"cooked\") {\n          value = JSON.stringify(value);\n          value = value.slice(1, value.length - 1);\n        }\n        if (i === 0) {\n          // prefix\n          value = prefix;\n          range = [param.range[0], part.range[1]];\n          value = (param.templateStringKind === \"cooked\" ? \"`\" : \"String.raw`\") + value;\n        } else if (i === param.parts.length - 1) {\n          // postfix\n          value = postfix;\n          range = [part.range[0], param.range[1]];\n          value = value + \"`\";\n        } else if (part.expression && part.expression.type === \"TemplateElement\" && part.expression.value.raw === value) {\n          // Shortcut when it's a single quasi and doesn't need to be replaced\n          return;\n        }\n        replaces.push({\n          range,\n          value\n        });\n      } else {\n        // Expression\n        if (parser) {\n          parser.walkExpression(part.expression);\n        }\n      }\n    });\n    dep.replaces = replaces;\n    dep.critical = options.wrappedContextCritical && \"a part of the request of a dependency is an expression\";\n    return dep;\n  } else if (param.isWrapped() && (param.prefix && param.prefix.isString() || param.postfix && param.postfix.isString())) {\n    let prefixRaw = param.prefix && param.prefix.isString() ? param.prefix.string : \"\";\n    let postfixRaw = param.postfix && param.postfix.isString() ? param.postfix.string : \"\";\n    const prefixRange = param.prefix && param.prefix.isString() ? param.prefix.range : null;\n    const postfixRange = param.postfix && param.postfix.isString() ? param.postfix.range : null;\n    const valueRange = param.range;\n    const {\n      context,\n      prefix\n    } = splitContextFromPrefix(prefixRaw);\n    const {\n      postfix,\n      query\n    } = splitQueryFromPostfix(postfixRaw);\n    const regExp = new RegExp(`^${quotemeta(prefix)}${options.wrappedContextRegExp.source}${quotemeta(postfix)}$`);\n    const dep = new Dep(Object.assign({\n      request: context + query,\n      recursive: options.wrappedContextRecursive,\n      regExp,\n      mode: \"sync\"\n    }, contextOptions), range, valueRange);\n    dep.loc = expr.loc;\n    const replaces = [];\n    if (prefixRange) {\n      replaces.push({\n        range: prefixRange,\n        value: JSON.stringify(prefix)\n      });\n    }\n    if (postfixRange) {\n      replaces.push({\n        range: postfixRange,\n        value: JSON.stringify(postfix)\n      });\n    }\n    dep.replaces = replaces;\n    dep.critical = options.wrappedContextCritical && \"a part of the request of a dependency is an expression\";\n    if (parser && param.wrappedInnerExpressions) {\n      for (const part of param.wrappedInnerExpressions) {\n        if (part.expression) parser.walkExpression(part.expression);\n      }\n    }\n    return dep;\n  } else {\n    const dep = new Dep(Object.assign({\n      request: options.exprContextRequest,\n      recursive: options.exprContextRecursive,\n      regExp: options.exprContextRegExp,\n      mode: \"sync\"\n    }, contextOptions), range, param.range);\n    dep.loc = expr.loc;\n    dep.critical = options.exprContextCritical && \"the request of a dependency is an expression\";\n    if (parser) {\n      parser.walkExpression(param.expression);\n    }\n    return dep;\n  }\n};","map":{"version":3,"names":["ContextDependencyHelpers","exports","quotemeta","str","replace","splitContextFromPrefix","prefix","idx","lastIndexOf","context","substr","splitQueryFromPostfix","postfix","indexOf","query","create","Dep","range","param","expr","options","contextOptions","parser","isTemplateString","prefixRaw","quasis","string","postfixRaw","length","valueRange","innerQuasis","slice","innerRegExp","wrappedContextRegExp","source","map","q","join","regExp","RegExp","dep","Object","assign","request","recursive","wrappedContextRecursive","mode","loc","replaces","parts","forEach","part","i","value","templateStringKind","JSON","stringify","expression","type","raw","push","walkExpression","critical","wrappedContextCritical","isWrapped","isString","prefixRange","postfixRange","wrappedInnerExpressions","exprContextRequest","exprContextRecursive","exprContextRegExp","exprContextCritical"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/dependencies/ContextDependencyHelpers.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ContextDependencyHelpers = exports;\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quotemeta = str => {\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nconst splitContextFromPrefix = prefix => {\n\tconst idx = prefix.lastIndexOf(\"/\");\n\tlet context = \".\";\n\tif (idx >= 0) {\n\t\tcontext = prefix.substr(0, idx);\n\t\tprefix = `.${prefix.substr(idx)}`;\n\t}\n\treturn {\n\t\tcontext,\n\t\tprefix\n\t};\n};\n\nconst splitQueryFromPostfix = postfix => {\n\tconst idx = postfix.indexOf(\"?\");\n\tlet query = \"\";\n\tif (idx >= 0) {\n\t\tquery = postfix.substr(idx);\n\t\tpostfix = postfix.substr(0, idx);\n\t}\n\treturn {\n\t\tpostfix,\n\t\tquery\n\t};\n};\n\nContextDependencyHelpers.create = (\n\tDep,\n\trange,\n\tparam,\n\texpr,\n\toptions,\n\tcontextOptions,\n\t// when parser is not passed in, expressions won't be walked\n\tparser = null\n) => {\n\tif (param.isTemplateString()) {\n\t\tlet prefixRaw = param.quasis[0].string;\n\t\tlet postfixRaw =\n\t\t\tparam.quasis.length > 1\n\t\t\t\t? param.quasis[param.quasis.length - 1].string\n\t\t\t\t: \"\";\n\n\t\tconst valueRange = param.range;\n\t\tconst { context, prefix } = splitContextFromPrefix(prefixRaw);\n\t\tconst { postfix, query } = splitQueryFromPostfix(postfixRaw);\n\n\t\t// When there are more than two quasis, the generated RegExp can be more precise\n\t\t// We join the quasis with the expression regexp\n\t\tconst innerQuasis = param.quasis.slice(1, param.quasis.length - 1);\n\t\tconst innerRegExp =\n\t\t\toptions.wrappedContextRegExp.source +\n\t\t\tinnerQuasis\n\t\t\t\t.map(q => quotemeta(q.string) + options.wrappedContextRegExp.source)\n\t\t\t\t.join(\"\");\n\n\t\t// Example: `./context/pre${e}inner${e}inner2${e}post?query`\n\t\t// context: \"./context\"\n\t\t// prefix: \"./pre\"\n\t\t// innerQuasis: [BEE(\"inner\"), BEE(\"inner2\")]\n\t\t// (BEE = BasicEvaluatedExpression)\n\t\t// postfix: \"post\"\n\t\t// query: \"?query\"\n\t\t// regExp: /^\\.\\/pre.*inner.*inner2.*post$/\n\t\tconst regExp = new RegExp(\n\t\t\t`^${quotemeta(prefix)}${innerRegExp}${quotemeta(postfix)}$`\n\t\t);\n\t\tconst dep = new Dep(\n\t\t\tObject.assign(\n\t\t\t\t{\n\t\t\t\t\trequest: context + query,\n\t\t\t\t\trecursive: options.wrappedContextRecursive,\n\t\t\t\t\tregExp,\n\t\t\t\t\tmode: \"sync\"\n\t\t\t\t},\n\t\t\t\tcontextOptions\n\t\t\t),\n\t\t\trange,\n\t\t\tvalueRange\n\t\t);\n\t\tdep.loc = expr.loc;\n\t\tconst replaces = [];\n\n\t\tparam.parts.forEach((part, i) => {\n\t\t\tif (i % 2 === 0) {\n\t\t\t\t// Quasis or merged quasi\n\t\t\t\tlet range = part.range;\n\t\t\t\tlet value = part.string;\n\t\t\t\tif (param.templateStringKind === \"cooked\") {\n\t\t\t\t\tvalue = JSON.stringify(value);\n\t\t\t\t\tvalue = value.slice(1, value.length - 1);\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// prefix\n\t\t\t\t\tvalue = prefix;\n\t\t\t\t\trange = [param.range[0], part.range[1]];\n\t\t\t\t\tvalue =\n\t\t\t\t\t\t(param.templateStringKind === \"cooked\" ? \"`\" : \"String.raw`\") +\n\t\t\t\t\t\tvalue;\n\t\t\t\t} else if (i === param.parts.length - 1) {\n\t\t\t\t\t// postfix\n\t\t\t\t\tvalue = postfix;\n\t\t\t\t\trange = [part.range[0], param.range[1]];\n\t\t\t\t\tvalue = value + \"`\";\n\t\t\t\t} else if (\n\t\t\t\t\tpart.expression &&\n\t\t\t\t\tpart.expression.type === \"TemplateElement\" &&\n\t\t\t\t\tpart.expression.value.raw === value\n\t\t\t\t) {\n\t\t\t\t\t// Shortcut when it's a single quasi and doesn't need to be replaced\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treplaces.push({\n\t\t\t\t\trange,\n\t\t\t\t\tvalue\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Expression\n\t\t\t\tif (parser) {\n\t\t\t\t\tparser.walkExpression(part.expression);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tdep.replaces = replaces;\n\t\tdep.critical =\n\t\t\toptions.wrappedContextCritical &&\n\t\t\t\"a part of the request of a dependency is an expression\";\n\t\treturn dep;\n\t} else if (\n\t\tparam.isWrapped() &&\n\t\t((param.prefix && param.prefix.isString()) ||\n\t\t\t(param.postfix && param.postfix.isString()))\n\t) {\n\t\tlet prefixRaw =\n\t\t\tparam.prefix && param.prefix.isString() ? param.prefix.string : \"\";\n\t\tlet postfixRaw =\n\t\t\tparam.postfix && param.postfix.isString() ? param.postfix.string : \"\";\n\t\tconst prefixRange =\n\t\t\tparam.prefix && param.prefix.isString() ? param.prefix.range : null;\n\t\tconst postfixRange =\n\t\t\tparam.postfix && param.postfix.isString() ? param.postfix.range : null;\n\t\tconst valueRange = param.range;\n\t\tconst { context, prefix } = splitContextFromPrefix(prefixRaw);\n\t\tconst { postfix, query } = splitQueryFromPostfix(postfixRaw);\n\t\tconst regExp = new RegExp(\n\t\t\t`^${quotemeta(prefix)}${options.wrappedContextRegExp.source}${quotemeta(\n\t\t\t\tpostfix\n\t\t\t)}$`\n\t\t);\n\t\tconst dep = new Dep(\n\t\t\tObject.assign(\n\t\t\t\t{\n\t\t\t\t\trequest: context + query,\n\t\t\t\t\trecursive: options.wrappedContextRecursive,\n\t\t\t\t\tregExp,\n\t\t\t\t\tmode: \"sync\"\n\t\t\t\t},\n\t\t\t\tcontextOptions\n\t\t\t),\n\t\t\trange,\n\t\t\tvalueRange\n\t\t);\n\t\tdep.loc = expr.loc;\n\t\tconst replaces = [];\n\t\tif (prefixRange) {\n\t\t\treplaces.push({\n\t\t\t\trange: prefixRange,\n\t\t\t\tvalue: JSON.stringify(prefix)\n\t\t\t});\n\t\t}\n\t\tif (postfixRange) {\n\t\t\treplaces.push({\n\t\t\t\trange: postfixRange,\n\t\t\t\tvalue: JSON.stringify(postfix)\n\t\t\t});\n\t\t}\n\t\tdep.replaces = replaces;\n\t\tdep.critical =\n\t\t\toptions.wrappedContextCritical &&\n\t\t\t\"a part of the request of a dependency is an expression\";\n\n\t\tif (parser && param.wrappedInnerExpressions) {\n\t\t\tfor (const part of param.wrappedInnerExpressions) {\n\t\t\t\tif (part.expression) parser.walkExpression(part.expression);\n\t\t\t}\n\t\t}\n\n\t\treturn dep;\n\t} else {\n\t\tconst dep = new Dep(\n\t\t\tObject.assign(\n\t\t\t\t{\n\t\t\t\t\trequest: options.exprContextRequest,\n\t\t\t\t\trecursive: options.exprContextRecursive,\n\t\t\t\t\tregExp: options.exprContextRegExp,\n\t\t\t\t\tmode: \"sync\"\n\t\t\t\t},\n\t\t\t\tcontextOptions\n\t\t\t),\n\t\t\trange,\n\t\t\tparam.range\n\t\t);\n\t\tdep.loc = expr.loc;\n\t\tdep.critical =\n\t\t\toptions.exprContextCritical &&\n\t\t\t\"the request of a dependency is an expression\";\n\n\t\tif (parser) {\n\t\t\tparser.walkExpression(param.expression);\n\t\t}\n\n\t\treturn dep;\n\t}\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}