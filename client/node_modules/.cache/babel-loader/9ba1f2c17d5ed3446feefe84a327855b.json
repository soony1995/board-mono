{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar SourceNode = require(\"source-map\").SourceNode;\nvar SourceMapConsumer = require(\"source-map\").SourceMapConsumer;\nvar applySourceMap = function (sourceNode, sourceMapConsumer, sourceFile, removeGeneratedCodeForSourceFile) {\n  // The following notations are used to name stuff:\n  // Left <------------> Middle <-------------------> Right\n  // Input arguments:\n  //        sourceNode                                       - Code mapping from Left to Middle\n  //                   sourceFile                            - Name of a Middle file\n  //                              sourceMapConsumer          - Code mapping from Middle to Right\n  // Variables:\n  //           l2m                      m2r\n  // Left <-----------------------------------------> Right\n  // Variables:\n  //                       l2r\n\n  var l2rResult = new SourceNode();\n  var l2rOutput = [];\n  var middleSourceContents = {};\n  var m2rMappingsByLine = {};\n  var rightSourceContentsSet = {};\n  var rightSourceContentsLines = {};\n\n  // Store all mappings by generated line\n  sourceMapConsumer.eachMapping(function (mapping) {\n    (m2rMappingsByLine[mapping.generatedLine] = m2rMappingsByLine[mapping.generatedLine] || []).push(mapping);\n  }, null, SourceMapConsumer.GENERATED_ORDER);\n\n  // Store all source contents\n  sourceNode.walkSourceContents(function (source, content) {\n    middleSourceContents[\"$\" + source] = content;\n  });\n  var middleSource = middleSourceContents[\"$\" + sourceFile];\n  var middleSourceLines = middleSource ? middleSource.split(\"\\n\") : undefined;\n\n  // Walk all left to middle mappings\n  sourceNode.walk(function (chunk, middleMapping) {\n    var source;\n\n    // Find a mapping from middle to right\n    if (middleMapping.source === sourceFile && middleMapping.line && m2rMappingsByLine[middleMapping.line]) {\n      var m2rBestFit;\n      var m2rMappings = m2rMappingsByLine[middleMapping.line];\n      // Note: if this becomes a performance problem, use binary search\n      for (var i = 0; i < m2rMappings.length; i++) {\n        if (m2rMappings[i].generatedColumn <= middleMapping.column) {\n          m2rBestFit = m2rMappings[i];\n        }\n      }\n      if (m2rBestFit) {\n        var allowMiddleName = false;\n        var middleLine;\n        var rightSourceContent;\n        var rightSourceContentLines;\n        var rightSource = m2rBestFit.source;\n        // Check if we have middle and right source for this mapping\n        // Then we could have an \"identify\" mapping\n        if (middleSourceLines && rightSource && (middleLine = middleSourceLines[m2rBestFit.generatedLine - 1]) && ((rightSourceContentLines = rightSourceContentsLines[rightSource]) || (rightSourceContent = sourceMapConsumer.sourceContentFor(rightSource, true)))) {\n          if (!rightSourceContentLines) {\n            rightSourceContentLines = rightSourceContentsLines[rightSource] = rightSourceContent.split(\"\\n\");\n          }\n          var rightLine = rightSourceContentLines[m2rBestFit.originalLine - 1];\n          if (rightLine) {\n            var offset = middleMapping.column - m2rBestFit.generatedColumn;\n            if (offset > 0) {\n              var middlePart = middleLine.slice(m2rBestFit.generatedColumn, middleMapping.column);\n              var rightPart = rightLine.slice(m2rBestFit.originalColumn, m2rBestFit.originalColumn + offset);\n              if (middlePart === rightPart) {\n                // When original and generated code is equal we assume we have an \"identity\" mapping\n                // In this case we can offset the original position\n                m2rBestFit = Object.assign({}, m2rBestFit, {\n                  originalColumn: m2rBestFit.originalColumn + offset,\n                  generatedColumn: middleMapping.column\n                });\n              }\n            }\n            if (!m2rBestFit.name && middleMapping.name) {\n              allowMiddleName = rightLine.slice(m2rBestFit.originalColumn, m2rBestFit.originalColumn + middleMapping.name.length) === middleMapping.name;\n            }\n          }\n        }\n\n        // Construct a left to right node from the found middle to right mapping\n        source = m2rBestFit.source;\n        l2rOutput.push(new SourceNode(m2rBestFit.originalLine, m2rBestFit.originalColumn, source, chunk, allowMiddleName ? middleMapping.name : m2rBestFit.name));\n\n        // Set the source contents once\n        if (!(\"$\" + source in rightSourceContentsSet)) {\n          rightSourceContentsSet[\"$\" + source] = true;\n          var sourceContent = sourceMapConsumer.sourceContentFor(source, true);\n          if (sourceContent) {\n            l2rResult.setSourceContent(source, sourceContent);\n          }\n        }\n        return;\n      }\n    }\n    if (removeGeneratedCodeForSourceFile && middleMapping.source === sourceFile || !middleMapping.source) {\n      // Construct a left to middle node with only generated code\n      // Because user do not want mappings to middle sources\n      // Or this chunk has no mapping\n      l2rOutput.push(chunk);\n      return;\n    }\n\n    // Construct a left to middle node\n    source = middleMapping.source;\n    l2rOutput.push(new SourceNode(middleMapping.line, middleMapping.column, source, chunk, middleMapping.name));\n    if (\"$\" + source in middleSourceContents) {\n      if (!(\"$\" + source in rightSourceContentsSet)) {\n        l2rResult.setSourceContent(source, middleSourceContents[\"$\" + source]);\n        delete middleSourceContents[\"$\" + source];\n      }\n    }\n  });\n\n  // Put output into the resulting SourceNode\n  l2rResult.add(l2rOutput);\n  return l2rResult;\n};\nmodule.exports = applySourceMap;","map":{"version":3,"names":["SourceNode","require","SourceMapConsumer","applySourceMap","sourceNode","sourceMapConsumer","sourceFile","removeGeneratedCodeForSourceFile","l2rResult","l2rOutput","middleSourceContents","m2rMappingsByLine","rightSourceContentsSet","rightSourceContentsLines","eachMapping","mapping","generatedLine","push","GENERATED_ORDER","walkSourceContents","source","content","middleSource","middleSourceLines","split","undefined","walk","chunk","middleMapping","line","m2rBestFit","m2rMappings","i","length","generatedColumn","column","allowMiddleName","middleLine","rightSourceContent","rightSourceContentLines","rightSource","sourceContentFor","rightLine","originalLine","offset","middlePart","slice","rightPart","originalColumn","Object","assign","name","sourceContent","setSourceContent","add","module","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack-sources/lib/applySourceMap.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar SourceNode = require(\"source-map\").SourceNode;\nvar SourceMapConsumer = require(\"source-map\").SourceMapConsumer;\n\nvar applySourceMap = function(\n\tsourceNode,\n\tsourceMapConsumer,\n\tsourceFile,\n\tremoveGeneratedCodeForSourceFile\n) {\n\t// The following notations are used to name stuff:\n\t// Left <------------> Middle <-------------------> Right\n\t// Input arguments:\n\t//        sourceNode                                       - Code mapping from Left to Middle\n\t//                   sourceFile                            - Name of a Middle file\n\t//                              sourceMapConsumer          - Code mapping from Middle to Right\n\t// Variables:\n\t//           l2m                      m2r\n\t// Left <-----------------------------------------> Right\n\t// Variables:\n\t//                       l2r\n\n\tvar l2rResult = new SourceNode();\n\tvar l2rOutput = [];\n\n\tvar middleSourceContents = {};\n\n\tvar m2rMappingsByLine = {};\n\n\tvar rightSourceContentsSet = {};\n\tvar rightSourceContentsLines = {};\n\n\t// Store all mappings by generated line\n\tsourceMapConsumer.eachMapping(\n\t\tfunction(mapping) {\n\t\t\t(m2rMappingsByLine[mapping.generatedLine] =\n\t\t\t\tm2rMappingsByLine[mapping.generatedLine] || []).push(mapping);\n\t\t},\n\t\tnull,\n\t\tSourceMapConsumer.GENERATED_ORDER\n\t);\n\n\t// Store all source contents\n\tsourceNode.walkSourceContents(function(source, content) {\n\t\tmiddleSourceContents[\"$\" + source] = content;\n\t});\n\n\tvar middleSource = middleSourceContents[\"$\" + sourceFile];\n\tvar middleSourceLines = middleSource ? middleSource.split(\"\\n\") : undefined;\n\n\t// Walk all left to middle mappings\n\tsourceNode.walk(function(chunk, middleMapping) {\n\t\tvar source;\n\n\t\t// Find a mapping from middle to right\n\t\tif(\n\t\t\tmiddleMapping.source === sourceFile &&\n\t\t\tmiddleMapping.line &&\n\t\t\tm2rMappingsByLine[middleMapping.line]\n\t\t) {\n\t\t\tvar m2rBestFit;\n\t\t\tvar m2rMappings = m2rMappingsByLine[middleMapping.line];\n\t\t\t// Note: if this becomes a performance problem, use binary search\n\t\t\tfor(var i = 0; i < m2rMappings.length; i++) {\n\t\t\t\tif(m2rMappings[i].generatedColumn <= middleMapping.column) {\n\t\t\t\t\tm2rBestFit = m2rMappings[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m2rBestFit) {\n\t\t\t\tvar allowMiddleName = false;\n\t\t\t\tvar middleLine;\n\t\t\t\tvar rightSourceContent;\n\t\t\t\tvar rightSourceContentLines;\n\t\t\t\tvar rightSource = m2rBestFit.source;\n\t\t\t\t// Check if we have middle and right source for this mapping\n\t\t\t\t// Then we could have an \"identify\" mapping\n\t\t\t\tif(\n\t\t\t\t\tmiddleSourceLines &&\n\t\t\t\t\trightSource &&\n\t\t\t\t\t(middleLine = middleSourceLines[m2rBestFit.generatedLine - 1]) &&\n\t\t\t\t\t((rightSourceContentLines = rightSourceContentsLines[rightSource]) ||\n\t\t\t\t\t\t(rightSourceContent = sourceMapConsumer.sourceContentFor(\n\t\t\t\t\t\t\trightSource,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t)))\n\t\t\t\t) {\n\t\t\t\t\tif(!rightSourceContentLines) {\n\t\t\t\t\t\trightSourceContentLines = rightSourceContentsLines[\n\t\t\t\t\t\t\trightSource\n\t\t\t\t\t\t] = rightSourceContent.split(\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tvar rightLine = rightSourceContentLines[m2rBestFit.originalLine - 1];\n\t\t\t\t\tif(rightLine) {\n\t\t\t\t\t\tvar offset = middleMapping.column - m2rBestFit.generatedColumn;\n\t\t\t\t\t\tif(offset > 0) {\n\t\t\t\t\t\t\tvar middlePart = middleLine.slice(\n\t\t\t\t\t\t\t\tm2rBestFit.generatedColumn,\n\t\t\t\t\t\t\t\tmiddleMapping.column\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tvar rightPart = rightLine.slice(\n\t\t\t\t\t\t\t\tm2rBestFit.originalColumn,\n\t\t\t\t\t\t\t\tm2rBestFit.originalColumn + offset\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif(middlePart === rightPart) {\n\t\t\t\t\t\t\t\t// When original and generated code is equal we assume we have an \"identity\" mapping\n\t\t\t\t\t\t\t\t// In this case we can offset the original position\n\t\t\t\t\t\t\t\tm2rBestFit = Object.assign({}, m2rBestFit, {\n\t\t\t\t\t\t\t\t\toriginalColumn: m2rBestFit.originalColumn + offset,\n\t\t\t\t\t\t\t\t\tgeneratedColumn: middleMapping.column\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!m2rBestFit.name && middleMapping.name) {\n\t\t\t\t\t\t\tallowMiddleName =\n\t\t\t\t\t\t\t\trightLine.slice(\n\t\t\t\t\t\t\t\t\tm2rBestFit.originalColumn,\n\t\t\t\t\t\t\t\t\tm2rBestFit.originalColumn + middleMapping.name.length\n\t\t\t\t\t\t\t\t) === middleMapping.name;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Construct a left to right node from the found middle to right mapping\n\t\t\t\tsource = m2rBestFit.source;\n\t\t\t\tl2rOutput.push(\n\t\t\t\t\tnew SourceNode(\n\t\t\t\t\t\tm2rBestFit.originalLine,\n\t\t\t\t\t\tm2rBestFit.originalColumn,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tallowMiddleName ? middleMapping.name : m2rBestFit.name\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t// Set the source contents once\n\t\t\t\tif(!(\"$\" + source in rightSourceContentsSet)) {\n\t\t\t\t\trightSourceContentsSet[\"$\" + source] = true;\n\t\t\t\t\tvar sourceContent = sourceMapConsumer.sourceContentFor(source, true);\n\t\t\t\t\tif(sourceContent) {\n\t\t\t\t\t\tl2rResult.setSourceContent(source, sourceContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif((removeGeneratedCodeForSourceFile && middleMapping.source === sourceFile) || !middleMapping.source) {\n\t\t\t// Construct a left to middle node with only generated code\n\t\t\t// Because user do not want mappings to middle sources\n\t\t\t// Or this chunk has no mapping\n\t\t\tl2rOutput.push(chunk);\n\t\t\treturn;\n\t\t}\n\n\t\t// Construct a left to middle node\n\t\tsource = middleMapping.source;\n\t\tl2rOutput.push(\n\t\t\tnew SourceNode(\n\t\t\t\tmiddleMapping.line,\n\t\t\t\tmiddleMapping.column,\n\t\t\t\tsource,\n\t\t\t\tchunk,\n\t\t\t\tmiddleMapping.name\n\t\t\t)\n\t\t);\n\t\tif(\"$\" + source in middleSourceContents) {\n\t\t\tif(!(\"$\" + source in rightSourceContentsSet)) {\n\t\t\t\tl2rResult.setSourceContent(source, middleSourceContents[\"$\" + source]);\n\t\t\t\tdelete middleSourceContents[\"$\" + source];\n\t\t\t}\n\t\t}\n\t});\n\n\t// Put output into the resulting SourceNode\n\tl2rResult.add(l2rOutput);\n\treturn l2rResult;\n};\n\nmodule.exports = applySourceMap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}