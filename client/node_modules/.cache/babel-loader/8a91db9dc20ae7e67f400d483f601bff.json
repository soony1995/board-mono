{"ast":null,"code":"'use strict';\n\nconst DEFAULT_OPTIONS = {\n  workerOptions: {},\n  maxCallsPerWorker: Infinity,\n  maxConcurrentWorkers: (require('os').cpus() || {\n    length: 1\n  }).length,\n  maxConcurrentCallsPerWorker: 10,\n  maxConcurrentCalls: Infinity,\n  maxCallTime: Infinity // exceed this and the whole worker is terminated\n  ,\n  maxRetries: Infinity,\n  forcedKillTime: 100,\n  autoStart: false,\n  onChild: function () {}\n};\nconst fork = require('./fork'),\n  TimeoutError = require('errno').create('TimeoutError'),\n  ProcessTerminatedError = require('errno').create('ProcessTerminatedError'),\n  MaxConcurrentCallsError = require('errno').create('MaxConcurrentCallsError');\nfunction Farm(options, path) {\n  this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n  this.path = path;\n  this.activeCalls = 0;\n}\n\n// make a handle to pass back in the form of an external API\nFarm.prototype.mkhandle = function (method) {\n  return function () {\n    let args = Array.prototype.slice.call(arguments);\n    if (this.activeCalls + this.callQueue.length >= this.options.maxConcurrentCalls) {\n      let err = new MaxConcurrentCallsError('Too many concurrent calls (active: ' + this.activeCalls + ', queued: ' + this.callQueue.length + ')');\n      if (typeof args[args.length - 1] == 'function') return process.nextTick(args[args.length - 1].bind(null, err));\n      throw err;\n    }\n    this.addCall({\n      method: method,\n      callback: args.pop(),\n      args: args,\n      retries: 0\n    });\n  }.bind(this);\n};\n\n// a constructor of sorts\nFarm.prototype.setup = function (methods) {\n  let iface;\n  if (!methods) {\n    // single-function export\n    iface = this.mkhandle();\n  } else {\n    // multiple functions on the export\n    iface = {};\n    methods.forEach(function (m) {\n      iface[m] = this.mkhandle(m);\n    }.bind(this));\n  }\n  this.searchStart = -1;\n  this.childId = -1;\n  this.children = {};\n  this.activeChildren = 0;\n  this.callQueue = [];\n  if (this.options.autoStart) {\n    while (this.activeChildren < this.options.maxConcurrentWorkers) this.startChild();\n  }\n  return iface;\n};\n\n// when a child exits, check if there are any outstanding jobs and requeue them\nFarm.prototype.onExit = function (childId) {\n  // delay this to give any sends a chance to finish\n  setTimeout(function () {\n    let doQueue = false;\n    if (this.children[childId] && this.children[childId].activeCalls) {\n      this.children[childId].calls.forEach(function (call, i) {\n        if (!call) return;else if (call.retries >= this.options.maxRetries) {\n          this.receive({\n            idx: i,\n            child: childId,\n            args: [new ProcessTerminatedError('cancel after ' + call.retries + ' retries!')]\n          });\n        } else {\n          call.retries++;\n          this.callQueue.unshift(call);\n          doQueue = true;\n        }\n      }.bind(this));\n    }\n    this.stopChild(childId);\n    doQueue && this.processQueue();\n  }.bind(this), 10);\n};\n\n// start a new worker\nFarm.prototype.startChild = function () {\n  this.childId++;\n  let forked = fork(this.path, this.options.workerOptions),\n    id = this.childId,\n    c = {\n      send: forked.send,\n      child: forked.child,\n      calls: [],\n      activeCalls: 0,\n      exitCode: null\n    };\n  this.options.onChild(forked.child);\n  forked.child.on('message', function (data) {\n    if (data.owner !== 'farm') {\n      return;\n    }\n    this.receive(data);\n  }.bind(this));\n  forked.child.once('exit', function (code) {\n    c.exitCode = code;\n    this.onExit(id);\n  }.bind(this));\n  this.activeChildren++;\n  this.children[id] = c;\n};\n\n// stop a worker, identified by id\nFarm.prototype.stopChild = function (childId) {\n  let child = this.children[childId];\n  if (child) {\n    child.send({\n      owner: 'farm',\n      event: 'die'\n    });\n    setTimeout(function () {\n      if (child.exitCode === null) child.child.kill('SIGKILL');\n    }, this.options.forcedKillTime).unref();\n    delete this.children[childId];\n    this.activeChildren--;\n  }\n};\n\n// called from a child process, the data contains information needed to\n// look up the child and the original call so we can invoke the callback\nFarm.prototype.receive = function (data) {\n  let idx = data.idx,\n    childId = data.child,\n    args = data.args,\n    child = this.children[childId],\n    call;\n  if (!child) {\n    return console.error('Worker Farm: Received message for unknown child. ' + 'This is likely as a result of premature child death, ' + 'the operation will have been re-queued.');\n  }\n  call = child.calls[idx];\n  if (!call) {\n    return console.error('Worker Farm: Received message for unknown index for existing child. ' + 'This should not happen!');\n  }\n  if (this.options.maxCallTime !== Infinity) clearTimeout(call.timer);\n  if (args[0] && args[0].$error == '$error') {\n    let e = args[0];\n    switch (e.type) {\n      case 'TypeError':\n        args[0] = new TypeError(e.message);\n        break;\n      case 'RangeError':\n        args[0] = new RangeError(e.message);\n        break;\n      case 'EvalError':\n        args[0] = new EvalError(e.message);\n        break;\n      case 'ReferenceError':\n        args[0] = new ReferenceError(e.message);\n        break;\n      case 'SyntaxError':\n        args[0] = new SyntaxError(e.message);\n        break;\n      case 'URIError':\n        args[0] = new URIError(e.message);\n        break;\n      default:\n        args[0] = new Error(e.message);\n    }\n    args[0].type = e.type;\n    args[0].stack = e.stack;\n\n    // Copy any custom properties to pass it on.\n    Object.keys(e).forEach(function (key) {\n      args[0][key] = e[key];\n    });\n  }\n  process.nextTick(function () {\n    call.callback.apply(null, args);\n  });\n  delete child.calls[idx];\n  child.activeCalls--;\n  this.activeCalls--;\n  if (child.calls.length >= this.options.maxCallsPerWorker && !Object.keys(child.calls).length) {\n    // this child has finished its run, kill it\n    this.stopChild(childId);\n  }\n\n  // allow any outstanding calls to be processed\n  this.processQueue();\n};\nFarm.prototype.childTimeout = function (childId) {\n  let child = this.children[childId],\n    i;\n  if (!child) return;\n  for (i in child.calls) {\n    this.receive({\n      idx: i,\n      child: childId,\n      args: [new TimeoutError('worker call timed out!')]\n    });\n  }\n  this.stopChild(childId);\n};\n\n// send a call to a worker, identified by id\nFarm.prototype.send = function (childId, call) {\n  let child = this.children[childId],\n    idx = child.calls.length;\n  child.calls.push(call);\n  child.activeCalls++;\n  this.activeCalls++;\n  child.send({\n    owner: 'farm',\n    idx: idx,\n    child: childId,\n    method: call.method,\n    args: call.args\n  });\n  if (this.options.maxCallTime !== Infinity) {\n    call.timer = setTimeout(this.childTimeout.bind(this, childId), this.options.maxCallTime);\n  }\n};\n\n// a list of active worker ids, in order, but the starting offset is\n// shifted each time this method is called, so we work our way through\n// all workers when handing out jobs\nFarm.prototype.childKeys = function () {\n  let cka = Object.keys(this.children),\n    cks;\n  if (this.searchStart >= cka.length - 1) this.searchStart = 0;else this.searchStart++;\n  cks = cka.splice(0, this.searchStart);\n  return cka.concat(cks);\n};\n\n// Calls are added to a queue, this processes the queue and is called\n// whenever there might be a chance to send more calls to the workers.\n// The various options all impact on when we're able to send calls,\n// they may need to be kept in a queue until a worker is ready.\nFarm.prototype.processQueue = function () {\n  let cka,\n    i = 0,\n    childId;\n  if (!this.callQueue.length) return this.ending && this.end();\n  if (this.activeChildren < this.options.maxConcurrentWorkers) this.startChild();\n  for (cka = this.childKeys(); i < cka.length; i++) {\n    childId = +cka[i];\n    if (this.children[childId].activeCalls < this.options.maxConcurrentCallsPerWorker && this.children[childId].calls.length < this.options.maxCallsPerWorker) {\n      this.send(childId, this.callQueue.shift());\n      if (!this.callQueue.length) return this.ending && this.end();\n    } /*else {\n      console.log(\n        , this.children[childId].activeCalls < this.options.maxConcurrentCallsPerWorker\n        , this.children[childId].calls.length < this.options.maxCallsPerWorker\n        , this.children[childId].calls.length , this.options.maxCallsPerWorker)\n      }*/\n  }\n  if (this.ending) this.end();\n};\n\n// add a new call to the call queue, then trigger a process of the queue\nFarm.prototype.addCall = function (call) {\n  if (this.ending) return this.end(); // don't add anything new to the queue\n  this.callQueue.push(call);\n  this.processQueue();\n};\n\n// kills child workers when they're all done\nFarm.prototype.end = function (callback) {\n  let complete = true;\n  if (this.ending === false) return;\n  if (callback) this.ending = callback;else if (this.ending == null) this.ending = true;\n  Object.keys(this.children).forEach(function (child) {\n    if (!this.children[child]) return;\n    if (!this.children[child].activeCalls) this.stopChild(child);else complete = false;\n  }.bind(this));\n  if (complete && typeof this.ending == 'function') {\n    process.nextTick(function () {\n      this.ending();\n      this.ending = false;\n    }.bind(this));\n  }\n};\nmodule.exports = Farm;\nmodule.exports.TimeoutError = TimeoutError;","map":{"version":3,"names":["DEFAULT_OPTIONS","workerOptions","maxCallsPerWorker","Infinity","maxConcurrentWorkers","require","cpus","length","maxConcurrentCallsPerWorker","maxConcurrentCalls","maxCallTime","maxRetries","forcedKillTime","autoStart","onChild","fork","TimeoutError","create","ProcessTerminatedError","MaxConcurrentCallsError","Farm","options","path","Object","assign","activeCalls","prototype","mkhandle","method","args","Array","slice","call","arguments","callQueue","err","process","nextTick","bind","addCall","callback","pop","retries","setup","methods","iface","forEach","m","searchStart","childId","children","activeChildren","startChild","onExit","setTimeout","doQueue","calls","i","receive","idx","child","unshift","stopChild","processQueue","forked","id","c","send","exitCode","on","data","owner","once","code","event","kill","unref","console","error","clearTimeout","timer","$error","e","type","TypeError","message","RangeError","EvalError","ReferenceError","SyntaxError","URIError","Error","stack","keys","key","apply","childTimeout","push","childKeys","cka","cks","splice","concat","ending","end","shift","complete","module","exports"],"sources":["/home/soon/bulletin-board/node_modules/worker-farm/lib/farm.js"],"sourcesContent":["'use strict'\n\nconst DEFAULT_OPTIONS = {\n          workerOptions               : {}\n        , maxCallsPerWorker           : Infinity\n        , maxConcurrentWorkers        : (require('os').cpus() || { length: 1 }).length\n        , maxConcurrentCallsPerWorker : 10\n        , maxConcurrentCalls          : Infinity\n        , maxCallTime                 : Infinity // exceed this and the whole worker is terminated\n        , maxRetries                  : Infinity\n        , forcedKillTime              : 100\n        , autoStart                   : false\n        , onChild                     : function() {}\n      }\n\nconst fork                    = require('./fork')\n    , TimeoutError            = require('errno').create('TimeoutError')\n    , ProcessTerminatedError  = require('errno').create('ProcessTerminatedError')\n    , MaxConcurrentCallsError = require('errno').create('MaxConcurrentCallsError')\n\n\nfunction Farm (options, path) {\n  this.options     = Object.assign({}, DEFAULT_OPTIONS, options)\n  this.path        = path\n  this.activeCalls = 0\n}\n\n\n// make a handle to pass back in the form of an external API\nFarm.prototype.mkhandle = function (method) {\n  return function () {\n    let args = Array.prototype.slice.call(arguments)\n    if (this.activeCalls + this.callQueue.length >= this.options.maxConcurrentCalls) {\n      let err = new MaxConcurrentCallsError('Too many concurrent calls (active: ' + this.activeCalls + ', queued: ' + this.callQueue.length + ')')\n      if (typeof args[args.length - 1] == 'function')\n        return process.nextTick(args[args.length - 1].bind(null, err))\n      throw err\n    }\n    this.addCall({\n        method   : method\n      , callback : args.pop()\n      , args     : args\n      , retries  : 0\n    })\n  }.bind(this)\n}\n\n\n// a constructor of sorts\nFarm.prototype.setup = function (methods) {\n  let iface\n  if (!methods) { // single-function export\n    iface = this.mkhandle()\n  } else { // multiple functions on the export\n    iface = {}\n    methods.forEach(function (m) {\n      iface[m] = this.mkhandle(m)\n    }.bind(this))\n  }\n\n  this.searchStart    = -1\n  this.childId        = -1\n  this.children       = {}\n  this.activeChildren = 0\n  this.callQueue      = []\n\n  if (this.options.autoStart) {\n    while (this.activeChildren < this.options.maxConcurrentWorkers)\n      this.startChild()\n  }\n\n  return iface\n}\n\n\n// when a child exits, check if there are any outstanding jobs and requeue them\nFarm.prototype.onExit = function (childId) {\n  // delay this to give any sends a chance to finish\n  setTimeout(function () {\n    let doQueue = false\n    if (this.children[childId] && this.children[childId].activeCalls) {\n      this.children[childId].calls.forEach(function (call, i) {\n        if (!call) return\n        else if (call.retries >= this.options.maxRetries) {\n          this.receive({\n              idx   : i\n            , child : childId\n            , args  : [ new ProcessTerminatedError('cancel after ' + call.retries + ' retries!') ]\n          })\n        } else {\n          call.retries++\n          this.callQueue.unshift(call)\n          doQueue = true\n        }\n      }.bind(this))\n    }\n    this.stopChild(childId)\n    doQueue && this.processQueue()\n  }.bind(this), 10)\n}\n\n\n// start a new worker\nFarm.prototype.startChild = function () {\n  this.childId++\n\n  let forked = fork(this.path, this.options.workerOptions)\n    , id     = this.childId\n    , c      = {\n          send        : forked.send\n        , child       : forked.child\n        , calls       : []\n        , activeCalls : 0\n        , exitCode    : null\n      }\n\n  this.options.onChild(forked.child);\n\n  forked.child.on('message', function(data) {\n    if (data.owner !== 'farm') {\n      return;\n    }\n    this.receive(data);\n  }.bind(this))\n  forked.child.once('exit', function (code) {\n    c.exitCode = code\n    this.onExit(id)\n  }.bind(this))\n\n  this.activeChildren++\n  this.children[id] = c\n}\n\n\n// stop a worker, identified by id\nFarm.prototype.stopChild = function (childId) {\n  let child = this.children[childId]\n  if (child) {\n    child.send({owner: 'farm', event: 'die'})\n    setTimeout(function () {\n      if (child.exitCode === null)\n        child.child.kill('SIGKILL')\n    }, this.options.forcedKillTime).unref()\n    ;delete this.children[childId]\n    this.activeChildren--\n  }\n}\n\n\n// called from a child process, the data contains information needed to\n// look up the child and the original call so we can invoke the callback\nFarm.prototype.receive = function (data) {\n  let idx     = data.idx\n    , childId = data.child\n    , args    = data.args\n    , child   = this.children[childId]\n    , call\n\n  if (!child) {\n    return console.error(\n        'Worker Farm: Received message for unknown child. '\n      + 'This is likely as a result of premature child death, '\n      + 'the operation will have been re-queued.'\n    )\n  }\n\n  call = child.calls[idx]\n  if (!call) {\n    return console.error(\n        'Worker Farm: Received message for unknown index for existing child. '\n      + 'This should not happen!'\n    )\n  }\n\n  if (this.options.maxCallTime !== Infinity)\n    clearTimeout(call.timer)\n\n  if (args[0] && args[0].$error == '$error') {\n    let e = args[0]\n    switch (e.type) {\n      case 'TypeError': args[0] = new TypeError(e.message); break\n      case 'RangeError': args[0] = new RangeError(e.message); break\n      case 'EvalError': args[0] = new EvalError(e.message); break\n      case 'ReferenceError': args[0] = new ReferenceError(e.message); break\n      case 'SyntaxError': args[0] = new SyntaxError(e.message); break\n      case 'URIError': args[0] = new URIError(e.message); break\n      default: args[0] = new Error(e.message)\n    }\n    args[0].type = e.type\n    args[0].stack = e.stack\n\n    // Copy any custom properties to pass it on.\n    Object.keys(e).forEach(function(key) {\n      args[0][key] = e[key];\n    });\n  }\n\n  process.nextTick(function () {\n    call.callback.apply(null, args)\n  })\n\n  ;delete child.calls[idx]\n  child.activeCalls--\n  this.activeCalls--\n\n  if (child.calls.length >= this.options.maxCallsPerWorker\n      && !Object.keys(child.calls).length) {\n    // this child has finished its run, kill it\n    this.stopChild(childId)\n  }\n\n  // allow any outstanding calls to be processed\n  this.processQueue()\n}\n\n\nFarm.prototype.childTimeout = function (childId) {\n  let child = this.children[childId]\n    , i\n\n  if (!child)\n    return\n\n  for (i in child.calls) {\n    this.receive({\n        idx   : i\n      , child : childId\n      , args  : [ new TimeoutError('worker call timed out!') ]\n    })\n  }\n  this.stopChild(childId)\n}\n\n\n// send a call to a worker, identified by id\nFarm.prototype.send = function (childId, call) {\n  let child = this.children[childId]\n    , idx   = child.calls.length\n\n  child.calls.push(call)\n  child.activeCalls++\n  this.activeCalls++\n\n  child.send({\n      owner  : 'farm'\n    , idx    : idx\n    , child  : childId\n    , method : call.method\n    , args   : call.args\n  })\n\n  if (this.options.maxCallTime !== Infinity) {\n    call.timer =\n      setTimeout(this.childTimeout.bind(this, childId), this.options.maxCallTime)\n  }\n}\n\n\n// a list of active worker ids, in order, but the starting offset is\n// shifted each time this method is called, so we work our way through\n// all workers when handing out jobs\nFarm.prototype.childKeys = function () {\n  let cka = Object.keys(this.children)\n    , cks\n\n  if (this.searchStart >= cka.length - 1)\n    this.searchStart = 0\n  else\n    this.searchStart++\n\n  cks = cka.splice(0, this.searchStart)\n\n  return cka.concat(cks)\n}\n\n\n// Calls are added to a queue, this processes the queue and is called\n// whenever there might be a chance to send more calls to the workers.\n// The various options all impact on when we're able to send calls,\n// they may need to be kept in a queue until a worker is ready.\nFarm.prototype.processQueue = function () {\n  let cka, i = 0, childId\n\n  if (!this.callQueue.length)\n    return this.ending && this.end()\n\n  if (this.activeChildren < this.options.maxConcurrentWorkers)\n    this.startChild()\n\n  for (cka = this.childKeys(); i < cka.length; i++) {\n    childId = +cka[i]\n    if (this.children[childId].activeCalls < this.options.maxConcurrentCallsPerWorker\n        && this.children[childId].calls.length < this.options.maxCallsPerWorker) {\n\n      this.send(childId, this.callQueue.shift())\n      if (!this.callQueue.length)\n        return this.ending && this.end()\n    } /*else {\n      console.log(\n        , this.children[childId].activeCalls < this.options.maxConcurrentCallsPerWorker\n        , this.children[childId].calls.length < this.options.maxCallsPerWorker\n        , this.children[childId].calls.length , this.options.maxCallsPerWorker)\n    }*/\n  }\n\n  if (this.ending)\n    this.end()\n}\n\n\n// add a new call to the call queue, then trigger a process of the queue\nFarm.prototype.addCall = function (call) {\n  if (this.ending)\n    return this.end() // don't add anything new to the queue\n  this.callQueue.push(call)\n  this.processQueue()\n}\n\n\n// kills child workers when they're all done\nFarm.prototype.end = function (callback) {\n  let complete = true\n  if (this.ending === false)\n    return\n  if (callback)\n    this.ending = callback\n  else if (this.ending == null)\n    this.ending = true\n  Object.keys(this.children).forEach(function (child) {\n    if (!this.children[child])\n      return\n    if (!this.children[child].activeCalls)\n      this.stopChild(child)\n    else\n      complete = false\n  }.bind(this))\n\n  if (complete && typeof this.ending == 'function') {\n    process.nextTick(function () {\n      this.ending()\n      this.ending = false\n    }.bind(this))\n  }\n}\n\n\nmodule.exports              = Farm\nmodule.exports.TimeoutError = TimeoutError\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}