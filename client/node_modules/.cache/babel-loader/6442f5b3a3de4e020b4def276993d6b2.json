{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst identifierUtils = require(\"../util/identifier\");\nconst {\n  intersect\n} = require(\"../util/SetHelpers\");\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n\nconst moveModuleBetween = (oldChunk, newChunk) => {\n  return module => {\n    oldChunk.moveModule(module, newChunk);\n  };\n};\nconst isNotAEntryModule = entryModule => {\n  return module => {\n    return entryModule !== module;\n  };\n};\nclass AggressiveSplittingPlugin {\n  /**\n   * @param {AggressiveSplittingPluginOptions=} options options object\n   */\n  constructor(options) {\n    if (!options) options = {};\n    validateOptions(schema, options, \"Aggressive Splitting Plugin\");\n    this.options = options;\n    if (typeof this.options.minSize !== \"number\") {\n      this.options.minSize = 30 * 1024;\n    }\n    if (typeof this.options.maxSize !== \"number\") {\n      this.options.maxSize = 50 * 1024;\n    }\n    if (typeof this.options.chunkOverhead !== \"number\") {\n      this.options.chunkOverhead = 0;\n    }\n    if (typeof this.options.entryChunkMultiplicator !== \"number\") {\n      this.options.entryChunkMultiplicator = 1;\n    }\n  }\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(\"AggressiveSplittingPlugin\", compilation => {\n      let needAdditionalSeal = false;\n      let newSplits;\n      let fromAggressiveSplittingSet;\n      let chunkSplitDataMap;\n      compilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n        newSplits = [];\n        fromAggressiveSplittingSet = new Set();\n        chunkSplitDataMap = new Map();\n      });\n      compilation.hooks.optimizeChunksAdvanced.tap(\"AggressiveSplittingPlugin\", chunks => {\n        // Precompute stuff\n        const nameToModuleMap = new Map();\n        const moduleToNameMap = new Map();\n        for (const m of compilation.modules) {\n          const name = identifierUtils.makePathsRelative(compiler.context, m.identifier(), compilation.cache);\n          nameToModuleMap.set(name, m);\n          moduleToNameMap.set(m, name);\n        }\n\n        // Check used chunk ids\n        const usedIds = new Set();\n        for (const chunk of chunks) {\n          usedIds.add(chunk.id);\n        }\n        const recordedSplits = compilation.records && compilation.records.aggressiveSplits || [];\n        const usedSplits = newSplits ? recordedSplits.concat(newSplits) : recordedSplits;\n        const minSize = this.options.minSize;\n        const maxSize = this.options.maxSize;\n        const applySplit = splitData => {\n          // Cannot split if id is already taken\n          if (splitData.id !== undefined && usedIds.has(splitData.id)) {\n            return false;\n          }\n\n          // Get module objects from names\n          const selectedModules = splitData.modules.map(name => nameToModuleMap.get(name));\n\n          // Does the modules exist at all?\n          if (!selectedModules.every(Boolean)) return false;\n\n          // Check if size matches (faster than waiting for hash)\n          const size = selectedModules.reduce((sum, m) => sum + m.size(), 0);\n          if (size !== splitData.size) return false;\n\n          // get chunks with all modules\n          const selectedChunks = intersect(selectedModules.map(m => new Set(m.chunksIterable)));\n\n          // No relevant chunks found\n          if (selectedChunks.size === 0) return false;\n\n          // The found chunk is already the split or similar\n          if (selectedChunks.size === 1 && Array.from(selectedChunks)[0].getNumberOfModules() === selectedModules.length) {\n            const chunk = Array.from(selectedChunks)[0];\n            if (fromAggressiveSplittingSet.has(chunk)) return false;\n            fromAggressiveSplittingSet.add(chunk);\n            chunkSplitDataMap.set(chunk, splitData);\n            return true;\n          }\n\n          // split the chunk into two parts\n          const newChunk = compilation.addChunk();\n          newChunk.chunkReason = \"aggressive splitted\";\n          for (const chunk of selectedChunks) {\n            selectedModules.forEach(moveModuleBetween(chunk, newChunk));\n            chunk.split(newChunk);\n            chunk.name = null;\n          }\n          fromAggressiveSplittingSet.add(newChunk);\n          chunkSplitDataMap.set(newChunk, splitData);\n          if (splitData.id !== null && splitData.id !== undefined) {\n            newChunk.id = splitData.id;\n          }\n          return true;\n        };\n\n        // try to restore to recorded splitting\n        let changed = false;\n        for (let j = 0; j < usedSplits.length; j++) {\n          const splitData = usedSplits[j];\n          if (applySplit(splitData)) changed = true;\n        }\n\n        // for any chunk which isn't splitted yet, split it and create a new entry\n        // start with the biggest chunk\n        const sortedChunks = chunks.slice().sort((a, b) => {\n          const diff1 = b.modulesSize() - a.modulesSize();\n          if (diff1) return diff1;\n          const diff2 = a.getNumberOfModules() - b.getNumberOfModules();\n          if (diff2) return diff2;\n          const modulesA = Array.from(a.modulesIterable);\n          const modulesB = Array.from(b.modulesIterable);\n          modulesA.sort();\n          modulesB.sort();\n          const aI = modulesA[Symbol.iterator]();\n          const bI = modulesB[Symbol.iterator]();\n          // eslint-disable-next-line no-constant-condition\n          while (true) {\n            const aItem = aI.next();\n            const bItem = bI.next();\n            if (aItem.done) return 0;\n            const aModuleIdentifier = aItem.value.identifier();\n            const bModuleIdentifier = bItem.value.identifier();\n            if (aModuleIdentifier > bModuleIdentifier) return -1;\n            if (aModuleIdentifier < bModuleIdentifier) return 1;\n          }\n        });\n        for (const chunk of sortedChunks) {\n          if (fromAggressiveSplittingSet.has(chunk)) continue;\n          const size = chunk.modulesSize();\n          if (size > maxSize && chunk.getNumberOfModules() > 1) {\n            const modules = chunk.getModules().filter(isNotAEntryModule(chunk.entryModule)).sort((a, b) => {\n              a = a.identifier();\n              b = b.identifier();\n              if (a > b) return 1;\n              if (a < b) return -1;\n              return 0;\n            });\n            const selectedModules = [];\n            let selectedModulesSize = 0;\n            for (let k = 0; k < modules.length; k++) {\n              const module = modules[k];\n              const newSize = selectedModulesSize + module.size();\n              if (newSize > maxSize && selectedModulesSize >= minSize) {\n                break;\n              }\n              selectedModulesSize = newSize;\n              selectedModules.push(module);\n            }\n            if (selectedModules.length === 0) continue;\n            const splitData = {\n              modules: selectedModules.map(m => moduleToNameMap.get(m)).sort(),\n              size: selectedModulesSize\n            };\n            if (applySplit(splitData)) {\n              newSplits = (newSplits || []).concat(splitData);\n              changed = true;\n            }\n          }\n        }\n        if (changed) return true;\n      });\n      compilation.hooks.recordHash.tap(\"AggressiveSplittingPlugin\", records => {\n        // 4. save made splittings to records\n        const allSplits = new Set();\n        const invalidSplits = new Set();\n\n        // Check if some splittings are invalid\n        // We remove invalid splittings and try again\n        for (const chunk of compilation.chunks) {\n          const splitData = chunkSplitDataMap.get(chunk);\n          if (splitData !== undefined) {\n            if (splitData.hash && chunk.hash !== splitData.hash) {\n              // Split was successful, but hash doesn't equal\n              // We can throw away the split since it's useless now\n              invalidSplits.add(splitData);\n            }\n          }\n        }\n        if (invalidSplits.size > 0) {\n          records.aggressiveSplits = records.aggressiveSplits.filter(splitData => !invalidSplits.has(splitData));\n          needAdditionalSeal = true;\n        } else {\n          // set hash and id values on all (new) splittings\n          for (const chunk of compilation.chunks) {\n            const splitData = chunkSplitDataMap.get(chunk);\n            if (splitData !== undefined) {\n              splitData.hash = chunk.hash;\n              splitData.id = chunk.id;\n              allSplits.add(splitData);\n              // set flag for stats\n              chunk.recorded = true;\n            }\n          }\n\n          // Also add all unused historial splits (after the used ones)\n          // They can still be used in some future compilation\n          const recordedSplits = compilation.records && compilation.records.aggressiveSplits;\n          if (recordedSplits) {\n            for (const splitData of recordedSplits) {\n              if (!invalidSplits.has(splitData)) allSplits.add(splitData);\n            }\n          }\n\n          // record all splits\n          records.aggressiveSplits = Array.from(allSplits);\n          needAdditionalSeal = false;\n        }\n      });\n      compilation.hooks.needAdditionalSeal.tap(\"AggressiveSplittingPlugin\", () => {\n        if (needAdditionalSeal) {\n          needAdditionalSeal = false;\n          return true;\n        }\n      });\n    });\n  }\n}\nmodule.exports = AggressiveSplittingPlugin;","map":{"version":3,"names":["identifierUtils","require","intersect","validateOptions","schema","moveModuleBetween","oldChunk","newChunk","module","moveModule","isNotAEntryModule","entryModule","AggressiveSplittingPlugin","constructor","options","minSize","maxSize","chunkOverhead","entryChunkMultiplicator","apply","compiler","hooks","thisCompilation","tap","compilation","needAdditionalSeal","newSplits","fromAggressiveSplittingSet","chunkSplitDataMap","optimize","Set","Map","optimizeChunksAdvanced","chunks","nameToModuleMap","moduleToNameMap","m","modules","name","makePathsRelative","context","identifier","cache","set","usedIds","chunk","add","id","recordedSplits","records","aggressiveSplits","usedSplits","concat","applySplit","splitData","undefined","has","selectedModules","map","get","every","Boolean","size","reduce","sum","selectedChunks","chunksIterable","Array","from","getNumberOfModules","length","addChunk","chunkReason","forEach","split","changed","j","sortedChunks","slice","sort","a","b","diff1","modulesSize","diff2","modulesA","modulesIterable","modulesB","aI","Symbol","iterator","bI","aItem","next","bItem","done","aModuleIdentifier","value","bModuleIdentifier","getModules","filter","selectedModulesSize","k","newSize","push","recordHash","allSplits","invalidSplits","hash","recorded","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/optimize/AggressiveSplittingPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst identifierUtils = require(\"../util/identifier\");\nconst { intersect } = require(\"../util/SetHelpers\");\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n\nconst moveModuleBetween = (oldChunk, newChunk) => {\n\treturn module => {\n\t\toldChunk.moveModule(module, newChunk);\n\t};\n};\n\nconst isNotAEntryModule = entryModule => {\n\treturn module => {\n\t\treturn entryModule !== module;\n\t};\n};\n\nclass AggressiveSplittingPlugin {\n\t/**\n\t * @param {AggressiveSplittingPluginOptions=} options options object\n\t */\n\tconstructor(options) {\n\t\tif (!options) options = {};\n\n\t\tvalidateOptions(schema, options, \"Aggressive Splitting Plugin\");\n\n\t\tthis.options = options;\n\t\tif (typeof this.options.minSize !== \"number\") {\n\t\t\tthis.options.minSize = 30 * 1024;\n\t\t}\n\t\tif (typeof this.options.maxSize !== \"number\") {\n\t\t\tthis.options.maxSize = 50 * 1024;\n\t\t}\n\t\tif (typeof this.options.chunkOverhead !== \"number\") {\n\t\t\tthis.options.chunkOverhead = 0;\n\t\t}\n\t\tif (typeof this.options.entryChunkMultiplicator !== \"number\") {\n\t\t\tthis.options.entryChunkMultiplicator = 1;\n\t\t}\n\t}\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\n\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tlet needAdditionalSeal = false;\n\t\t\t\tlet newSplits;\n\t\t\t\tlet fromAggressiveSplittingSet;\n\t\t\t\tlet chunkSplitDataMap;\n\t\t\t\tcompilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n\t\t\t\t\tnewSplits = [];\n\t\t\t\t\tfromAggressiveSplittingSet = new Set();\n\t\t\t\t\tchunkSplitDataMap = new Map();\n\t\t\t\t});\n\t\t\t\tcompilation.hooks.optimizeChunksAdvanced.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\tchunks => {\n\t\t\t\t\t\t// Precompute stuff\n\t\t\t\t\t\tconst nameToModuleMap = new Map();\n\t\t\t\t\t\tconst moduleToNameMap = new Map();\n\t\t\t\t\t\tfor (const m of compilation.modules) {\n\t\t\t\t\t\t\tconst name = identifierUtils.makePathsRelative(\n\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\tm.identifier(),\n\t\t\t\t\t\t\t\tcompilation.cache\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tnameToModuleMap.set(name, m);\n\t\t\t\t\t\t\tmoduleToNameMap.set(m, name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check used chunk ids\n\t\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tusedIds.add(chunk.id);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t(compilation.records && compilation.records.aggressiveSplits) ||\n\t\t\t\t\t\t\t[];\n\t\t\t\t\t\tconst usedSplits = newSplits\n\t\t\t\t\t\t\t? recordedSplits.concat(newSplits)\n\t\t\t\t\t\t\t: recordedSplits;\n\n\t\t\t\t\t\tconst minSize = this.options.minSize;\n\t\t\t\t\t\tconst maxSize = this.options.maxSize;\n\n\t\t\t\t\t\tconst applySplit = splitData => {\n\t\t\t\t\t\t\t// Cannot split if id is already taken\n\t\t\t\t\t\t\tif (splitData.id !== undefined && usedIds.has(splitData.id)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get module objects from names\n\t\t\t\t\t\t\tconst selectedModules = splitData.modules.map(name =>\n\t\t\t\t\t\t\t\tnameToModuleMap.get(name)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Does the modules exist at all?\n\t\t\t\t\t\t\tif (!selectedModules.every(Boolean)) return false;\n\n\t\t\t\t\t\t\t// Check if size matches (faster than waiting for hash)\n\t\t\t\t\t\t\tconst size = selectedModules.reduce(\n\t\t\t\t\t\t\t\t(sum, m) => sum + m.size(),\n\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (size !== splitData.size) return false;\n\n\t\t\t\t\t\t\t// get chunks with all modules\n\t\t\t\t\t\t\tconst selectedChunks = intersect(\n\t\t\t\t\t\t\t\tselectedModules.map(m => new Set(m.chunksIterable))\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// No relevant chunks found\n\t\t\t\t\t\t\tif (selectedChunks.size === 0) return false;\n\n\t\t\t\t\t\t\t// The found chunk is already the split or similar\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tselectedChunks.size === 1 &&\n\t\t\t\t\t\t\t\tArray.from(selectedChunks)[0].getNumberOfModules() ===\n\t\t\t\t\t\t\t\t\tselectedModules.length\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst chunk = Array.from(selectedChunks)[0];\n\t\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) return false;\n\t\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(chunk);\n\t\t\t\t\t\t\t\tchunkSplitDataMap.set(chunk, splitData);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// split the chunk into two parts\n\t\t\t\t\t\t\tconst newChunk = compilation.addChunk();\n\t\t\t\t\t\t\tnewChunk.chunkReason = \"aggressive splitted\";\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tselectedModules.forEach(moveModuleBetween(chunk, newChunk));\n\t\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t\t\tchunk.name = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(newChunk);\n\t\t\t\t\t\t\tchunkSplitDataMap.set(newChunk, splitData);\n\n\t\t\t\t\t\t\tif (splitData.id !== null && splitData.id !== undefined) {\n\t\t\t\t\t\t\t\tnewChunk.id = splitData.id;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// try to restore to recorded splitting\n\t\t\t\t\t\tlet changed = false;\n\t\t\t\t\t\tfor (let j = 0; j < usedSplits.length; j++) {\n\t\t\t\t\t\t\tconst splitData = usedSplits[j];\n\t\t\t\t\t\t\tif (applySplit(splitData)) changed = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// for any chunk which isn't splitted yet, split it and create a new entry\n\t\t\t\t\t\t// start with the biggest chunk\n\t\t\t\t\t\tconst sortedChunks = chunks.slice().sort((a, b) => {\n\t\t\t\t\t\t\tconst diff1 = b.modulesSize() - a.modulesSize();\n\t\t\t\t\t\t\tif (diff1) return diff1;\n\t\t\t\t\t\t\tconst diff2 = a.getNumberOfModules() - b.getNumberOfModules();\n\t\t\t\t\t\t\tif (diff2) return diff2;\n\t\t\t\t\t\t\tconst modulesA = Array.from(a.modulesIterable);\n\t\t\t\t\t\t\tconst modulesB = Array.from(b.modulesIterable);\n\t\t\t\t\t\t\tmodulesA.sort();\n\t\t\t\t\t\t\tmodulesB.sort();\n\t\t\t\t\t\t\tconst aI = modulesA[Symbol.iterator]();\n\t\t\t\t\t\t\tconst bI = modulesB[Symbol.iterator]();\n\t\t\t\t\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tconst aItem = aI.next();\n\t\t\t\t\t\t\t\tconst bItem = bI.next();\n\t\t\t\t\t\t\t\tif (aItem.done) return 0;\n\t\t\t\t\t\t\t\tconst aModuleIdentifier = aItem.value.identifier();\n\t\t\t\t\t\t\t\tconst bModuleIdentifier = bItem.value.identifier();\n\t\t\t\t\t\t\t\tif (aModuleIdentifier > bModuleIdentifier) return -1;\n\t\t\t\t\t\t\t\tif (aModuleIdentifier < bModuleIdentifier) return 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (const chunk of sortedChunks) {\n\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) continue;\n\t\t\t\t\t\t\tconst size = chunk.modulesSize();\n\t\t\t\t\t\t\tif (size > maxSize && chunk.getNumberOfModules() > 1) {\n\t\t\t\t\t\t\t\tconst modules = chunk\n\t\t\t\t\t\t\t\t\t.getModules()\n\t\t\t\t\t\t\t\t\t.filter(isNotAEntryModule(chunk.entryModule))\n\t\t\t\t\t\t\t\t\t.sort((a, b) => {\n\t\t\t\t\t\t\t\t\t\ta = a.identifier();\n\t\t\t\t\t\t\t\t\t\tb = b.identifier();\n\t\t\t\t\t\t\t\t\t\tif (a > b) return 1;\n\t\t\t\t\t\t\t\t\t\tif (a < b) return -1;\n\t\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst selectedModules = [];\n\t\t\t\t\t\t\t\tlet selectedModulesSize = 0;\n\t\t\t\t\t\t\t\tfor (let k = 0; k < modules.length; k++) {\n\t\t\t\t\t\t\t\t\tconst module = modules[k];\n\t\t\t\t\t\t\t\t\tconst newSize = selectedModulesSize + module.size();\n\t\t\t\t\t\t\t\t\tif (newSize > maxSize && selectedModulesSize >= minSize) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tselectedModulesSize = newSize;\n\t\t\t\t\t\t\t\t\tselectedModules.push(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (selectedModules.length === 0) continue;\n\t\t\t\t\t\t\t\tconst splitData = {\n\t\t\t\t\t\t\t\t\tmodules: selectedModules\n\t\t\t\t\t\t\t\t\t\t.map(m => moduleToNameMap.get(m))\n\t\t\t\t\t\t\t\t\t\t.sort(),\n\t\t\t\t\t\t\t\t\tsize: selectedModulesSize\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif (applySplit(splitData)) {\n\t\t\t\t\t\t\t\t\tnewSplits = (newSplits || []).concat(splitData);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (changed) return true;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.recordHash.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\trecords => {\n\t\t\t\t\t\t// 4. save made splittings to records\n\t\t\t\t\t\tconst allSplits = new Set();\n\t\t\t\t\t\tconst invalidSplits = new Set();\n\n\t\t\t\t\t\t// Check if some splittings are invalid\n\t\t\t\t\t\t// We remove invalid splittings and try again\n\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\tif (splitData.hash && chunk.hash !== splitData.hash) {\n\t\t\t\t\t\t\t\t\t// Split was successful, but hash doesn't equal\n\t\t\t\t\t\t\t\t\t// We can throw away the split since it's useless now\n\t\t\t\t\t\t\t\t\tinvalidSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (invalidSplits.size > 0) {\n\t\t\t\t\t\t\trecords.aggressiveSplits = records.aggressiveSplits.filter(\n\t\t\t\t\t\t\t\tsplitData => !invalidSplits.has(splitData)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tneedAdditionalSeal = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// set hash and id values on all (new) splittings\n\t\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\t\tsplitData.hash = chunk.hash;\n\t\t\t\t\t\t\t\t\tsplitData.id = chunk.id;\n\t\t\t\t\t\t\t\t\tallSplits.add(splitData);\n\t\t\t\t\t\t\t\t\t// set flag for stats\n\t\t\t\t\t\t\t\t\tchunk.recorded = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Also add all unused historial splits (after the used ones)\n\t\t\t\t\t\t\t// They can still be used in some future compilation\n\t\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t\tcompilation.records && compilation.records.aggressiveSplits;\n\t\t\t\t\t\t\tif (recordedSplits) {\n\t\t\t\t\t\t\t\tfor (const splitData of recordedSplits) {\n\t\t\t\t\t\t\t\t\tif (!invalidSplits.has(splitData)) allSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// record all splits\n\t\t\t\t\t\t\trecords.aggressiveSplits = Array.from(allSplits);\n\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.needAdditionalSeal.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\t() => {\n\t\t\t\t\t\tif (needAdditionalSeal) {\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = AggressiveSplittingPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}