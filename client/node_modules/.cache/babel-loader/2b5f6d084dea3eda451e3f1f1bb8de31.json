{"ast":null,"code":"'use strict';\n\nconst BB = require('bluebird');\nconst contentPath = require('./content/path');\nconst crypto = require('crypto');\nconst figgyPudding = require('figgy-pudding');\nconst fixOwner = require('./util/fix-owner');\nconst fs = require('graceful-fs');\nconst hashToSegments = require('./util/hash-to-segments');\nconst ms = require('mississippi');\nconst path = require('path');\nconst ssri = require('ssri');\nconst Y = require('./util/y.js');\nconst indexV = require('../package.json')['cache-version'].index;\nconst appendFileAsync = BB.promisify(fs.appendFile);\nconst readFileAsync = BB.promisify(fs.readFile);\nconst readdirAsync = BB.promisify(fs.readdir);\nconst concat = ms.concat;\nconst from = ms.from;\nmodule.exports.NotFoundError = class NotFoundError extends Error {\n  constructor(cache, key) {\n    super(Y`No cache entry for \\`${key}\\` found in \\`${cache}\\``);\n    this.code = 'ENOENT';\n    this.cache = cache;\n    this.key = key;\n  }\n};\nconst IndexOpts = figgyPudding({\n  metadata: {},\n  size: {}\n});\nmodule.exports.insert = insert;\nfunction insert(cache, key, integrity, opts) {\n  opts = IndexOpts(opts);\n  const bucket = bucketPath(cache, key);\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: opts.size,\n    metadata: opts.metadata\n  };\n  return fixOwner.mkdirfix(cache, path.dirname(bucket)).then(() => {\n    const stringified = JSON.stringify(entry);\n    // NOTE - Cleverness ahoy!\n    //\n    // This works because it's tremendously unlikely for an entry to corrupt\n    // another while still preserving the string length of the JSON in\n    // question. So, we just slap the length in there and verify it on read.\n    //\n    // Thanks to @isaacs for the whiteboarding session that ended up with this.\n    return appendFileAsync(bucket, `\\n${hashEntry(stringified)}\\t${stringified}`);\n  }).then(() => fixOwner.chownr(cache, bucket)).catch({\n    code: 'ENOENT'\n  }, () => {\n    // There's a class of race conditions that happen when things get deleted\n    // during fixOwner, or between the two mkdirfix/chownr calls.\n    //\n    // It's perfectly fine to just not bother in those cases and lie\n    // that the index entry was written. Because it's a cache.\n  }).then(() => {\n    return formatEntry(cache, entry);\n  });\n}\nmodule.exports.insert.sync = insertSync;\nfunction insertSync(cache, key, integrity, opts) {\n  opts = IndexOpts(opts);\n  const bucket = bucketPath(cache, key);\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: opts.size,\n    metadata: opts.metadata\n  };\n  fixOwner.mkdirfix.sync(cache, path.dirname(bucket));\n  const stringified = JSON.stringify(entry);\n  fs.appendFileSync(bucket, `\\n${hashEntry(stringified)}\\t${stringified}`);\n  try {\n    fixOwner.chownr.sync(cache, bucket);\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      throw err;\n    }\n  }\n  return formatEntry(cache, entry);\n}\nmodule.exports.find = find;\nfunction find(cache, key) {\n  const bucket = bucketPath(cache, key);\n  return bucketEntries(bucket).then(entries => {\n    return entries.reduce((latest, next) => {\n      if (next && next.key === key) {\n        return formatEntry(cache, next);\n      } else {\n        return latest;\n      }\n    }, null);\n  }).catch(err => {\n    if (err.code === 'ENOENT') {\n      return null;\n    } else {\n      throw err;\n    }\n  });\n}\nmodule.exports.find.sync = findSync;\nfunction findSync(cache, key) {\n  const bucket = bucketPath(cache, key);\n  try {\n    return bucketEntriesSync(bucket).reduce((latest, next) => {\n      if (next && next.key === key) {\n        return formatEntry(cache, next);\n      } else {\n        return latest;\n      }\n    }, null);\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return null;\n    } else {\n      throw err;\n    }\n  }\n}\nmodule.exports.delete = del;\nfunction del(cache, key, opts) {\n  return insert(cache, key, null, opts);\n}\nmodule.exports.delete.sync = delSync;\nfunction delSync(cache, key, opts) {\n  return insertSync(cache, key, null, opts);\n}\nmodule.exports.lsStream = lsStream;\nfunction lsStream(cache) {\n  const indexDir = bucketDir(cache);\n  const stream = from.obj();\n\n  // \"/cachename/*\"\n  readdirOrEmpty(indexDir).map(bucket => {\n    const bucketPath = path.join(indexDir, bucket);\n\n    // \"/cachename/<bucket 0xFF>/*\"\n    return readdirOrEmpty(bucketPath).map(subbucket => {\n      const subbucketPath = path.join(bucketPath, subbucket);\n\n      // \"/cachename/<bucket 0xFF>/<bucket 0xFF>/*\"\n      return readdirOrEmpty(subbucketPath).map(entry => {\n        const getKeyToEntry = bucketEntries(path.join(subbucketPath, entry)).reduce((acc, entry) => {\n          acc.set(entry.key, entry);\n          return acc;\n        }, new Map());\n        return getKeyToEntry.then(reduced => {\n          for (let entry of reduced.values()) {\n            const formatted = formatEntry(cache, entry);\n            formatted && stream.push(formatted);\n          }\n        }).catch({\n          code: 'ENOENT'\n        }, nop);\n      });\n    });\n  }).then(() => {\n    stream.push(null);\n  }, err => {\n    stream.emit('error', err);\n  });\n  return stream;\n}\nmodule.exports.ls = ls;\nfunction ls(cache) {\n  return BB.fromNode(cb => {\n    lsStream(cache).on('error', cb).pipe(concat(entries => {\n      cb(null, entries.reduce((acc, xs) => {\n        acc[xs.key] = xs;\n        return acc;\n      }, {}));\n    }));\n  });\n}\nfunction bucketEntries(bucket, filter) {\n  return readFileAsync(bucket, 'utf8').then(data => _bucketEntries(data, filter));\n}\nfunction bucketEntriesSync(bucket, filter) {\n  const data = fs.readFileSync(bucket, 'utf8');\n  return _bucketEntries(data, filter);\n}\nfunction _bucketEntries(data, filter) {\n  let entries = [];\n  data.split('\\n').forEach(entry => {\n    if (!entry) {\n      return;\n    }\n    const pieces = entry.split('\\t');\n    if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {\n      // Hash is no good! Corruption or malice? Doesn't matter!\n      // EJECT EJECT\n      return;\n    }\n    let obj;\n    try {\n      obj = JSON.parse(pieces[1]);\n    } catch (e) {\n      // Entry is corrupted!\n      return;\n    }\n    if (obj) {\n      entries.push(obj);\n    }\n  });\n  return entries;\n}\nmodule.exports._bucketDir = bucketDir;\nfunction bucketDir(cache) {\n  return path.join(cache, `index-v${indexV}`);\n}\nmodule.exports._bucketPath = bucketPath;\nfunction bucketPath(cache, key) {\n  const hashed = hashKey(key);\n  return path.join.apply(path, [bucketDir(cache)].concat(hashToSegments(hashed)));\n}\nmodule.exports._hashKey = hashKey;\nfunction hashKey(key) {\n  return hash(key, 'sha256');\n}\nmodule.exports._hashEntry = hashEntry;\nfunction hashEntry(str) {\n  return hash(str, 'sha1');\n}\nfunction hash(str, digest) {\n  return crypto.createHash(digest).update(str).digest('hex');\n}\nfunction formatEntry(cache, entry) {\n  // Treat null digests as deletions. They'll shadow any previous entries.\n  if (!entry.integrity) {\n    return null;\n  }\n  return {\n    key: entry.key,\n    integrity: entry.integrity,\n    path: contentPath(cache, entry.integrity),\n    size: entry.size,\n    time: entry.time,\n    metadata: entry.metadata\n  };\n}\nfunction readdirOrEmpty(dir) {\n  return readdirAsync(dir).catch({\n    code: 'ENOENT'\n  }, () => []).catch({\n    code: 'ENOTDIR'\n  }, () => []);\n}\nfunction nop() {}","map":{"version":3,"names":["BB","require","contentPath","crypto","figgyPudding","fixOwner","fs","hashToSegments","ms","path","ssri","Y","indexV","index","appendFileAsync","promisify","appendFile","readFileAsync","readFile","readdirAsync","readdir","concat","from","module","exports","NotFoundError","Error","constructor","cache","key","code","IndexOpts","metadata","size","insert","integrity","opts","bucket","bucketPath","entry","stringify","time","Date","now","mkdirfix","dirname","then","stringified","JSON","hashEntry","chownr","catch","formatEntry","sync","insertSync","appendFileSync","err","find","bucketEntries","entries","reduce","latest","next","findSync","bucketEntriesSync","delete","del","delSync","lsStream","indexDir","bucketDir","stream","obj","readdirOrEmpty","map","join","subbucket","subbucketPath","getKeyToEntry","acc","set","Map","reduced","values","formatted","push","nop","emit","ls","fromNode","cb","on","pipe","xs","filter","data","_bucketEntries","readFileSync","split","forEach","pieces","parse","e","_bucketDir","_bucketPath","hashed","hashKey","apply","_hashKey","hash","_hashEntry","str","digest","createHash","update","dir"],"sources":["/home/soon/bulletin-board/node_modules/webpack/node_modules/cacache/lib/entry-index.js"],"sourcesContent":["'use strict'\n\nconst BB = require('bluebird')\n\nconst contentPath = require('./content/path')\nconst crypto = require('crypto')\nconst figgyPudding = require('figgy-pudding')\nconst fixOwner = require('./util/fix-owner')\nconst fs = require('graceful-fs')\nconst hashToSegments = require('./util/hash-to-segments')\nconst ms = require('mississippi')\nconst path = require('path')\nconst ssri = require('ssri')\nconst Y = require('./util/y.js')\n\nconst indexV = require('../package.json')['cache-version'].index\n\nconst appendFileAsync = BB.promisify(fs.appendFile)\nconst readFileAsync = BB.promisify(fs.readFile)\nconst readdirAsync = BB.promisify(fs.readdir)\nconst concat = ms.concat\nconst from = ms.from\n\nmodule.exports.NotFoundError = class NotFoundError extends Error {\n  constructor (cache, key) {\n    super(Y`No cache entry for \\`${key}\\` found in \\`${cache}\\``)\n    this.code = 'ENOENT'\n    this.cache = cache\n    this.key = key\n  }\n}\n\nconst IndexOpts = figgyPudding({\n  metadata: {},\n  size: {}\n})\n\nmodule.exports.insert = insert\nfunction insert (cache, key, integrity, opts) {\n  opts = IndexOpts(opts)\n  const bucket = bucketPath(cache, key)\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: opts.size,\n    metadata: opts.metadata\n  }\n  return fixOwner.mkdirfix(\n    cache, path.dirname(bucket)\n  ).then(() => {\n    const stringified = JSON.stringify(entry)\n    // NOTE - Cleverness ahoy!\n    //\n    // This works because it's tremendously unlikely for an entry to corrupt\n    // another while still preserving the string length of the JSON in\n    // question. So, we just slap the length in there and verify it on read.\n    //\n    // Thanks to @isaacs for the whiteboarding session that ended up with this.\n    return appendFileAsync(\n      bucket, `\\n${hashEntry(stringified)}\\t${stringified}`\n    )\n  }).then(\n    () => fixOwner.chownr(cache, bucket)\n  ).catch({ code: 'ENOENT' }, () => {\n    // There's a class of race conditions that happen when things get deleted\n    // during fixOwner, or between the two mkdirfix/chownr calls.\n    //\n    // It's perfectly fine to just not bother in those cases and lie\n    // that the index entry was written. Because it's a cache.\n  }).then(() => {\n    return formatEntry(cache, entry)\n  })\n}\n\nmodule.exports.insert.sync = insertSync\nfunction insertSync (cache, key, integrity, opts) {\n  opts = IndexOpts(opts)\n  const bucket = bucketPath(cache, key)\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: opts.size,\n    metadata: opts.metadata\n  }\n  fixOwner.mkdirfix.sync(cache, path.dirname(bucket))\n  const stringified = JSON.stringify(entry)\n  fs.appendFileSync(\n    bucket, `\\n${hashEntry(stringified)}\\t${stringified}`\n  )\n  try {\n    fixOwner.chownr.sync(cache, bucket)\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      throw err\n    }\n  }\n  return formatEntry(cache, entry)\n}\n\nmodule.exports.find = find\nfunction find (cache, key) {\n  const bucket = bucketPath(cache, key)\n  return bucketEntries(bucket).then(entries => {\n    return entries.reduce((latest, next) => {\n      if (next && next.key === key) {\n        return formatEntry(cache, next)\n      } else {\n        return latest\n      }\n    }, null)\n  }).catch(err => {\n    if (err.code === 'ENOENT') {\n      return null\n    } else {\n      throw err\n    }\n  })\n}\n\nmodule.exports.find.sync = findSync\nfunction findSync (cache, key) {\n  const bucket = bucketPath(cache, key)\n  try {\n    return bucketEntriesSync(bucket).reduce((latest, next) => {\n      if (next && next.key === key) {\n        return formatEntry(cache, next)\n      } else {\n        return latest\n      }\n    }, null)\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return null\n    } else {\n      throw err\n    }\n  }\n}\n\nmodule.exports.delete = del\nfunction del (cache, key, opts) {\n  return insert(cache, key, null, opts)\n}\n\nmodule.exports.delete.sync = delSync\nfunction delSync (cache, key, opts) {\n  return insertSync(cache, key, null, opts)\n}\n\nmodule.exports.lsStream = lsStream\nfunction lsStream (cache) {\n  const indexDir = bucketDir(cache)\n  const stream = from.obj()\n\n  // \"/cachename/*\"\n  readdirOrEmpty(indexDir).map(bucket => {\n    const bucketPath = path.join(indexDir, bucket)\n\n    // \"/cachename/<bucket 0xFF>/*\"\n    return readdirOrEmpty(bucketPath).map(subbucket => {\n      const subbucketPath = path.join(bucketPath, subbucket)\n\n      // \"/cachename/<bucket 0xFF>/<bucket 0xFF>/*\"\n      return readdirOrEmpty(subbucketPath).map(entry => {\n        const getKeyToEntry = bucketEntries(\n          path.join(subbucketPath, entry)\n        ).reduce((acc, entry) => {\n          acc.set(entry.key, entry)\n          return acc\n        }, new Map())\n\n        return getKeyToEntry.then(reduced => {\n          for (let entry of reduced.values()) {\n            const formatted = formatEntry(cache, entry)\n            formatted && stream.push(formatted)\n          }\n        }).catch({ code: 'ENOENT' }, nop)\n      })\n    })\n  }).then(() => {\n    stream.push(null)\n  }, err => {\n    stream.emit('error', err)\n  })\n\n  return stream\n}\n\nmodule.exports.ls = ls\nfunction ls (cache) {\n  return BB.fromNode(cb => {\n    lsStream(cache).on('error', cb).pipe(concat(entries => {\n      cb(null, entries.reduce((acc, xs) => {\n        acc[xs.key] = xs\n        return acc\n      }, {}))\n    }))\n  })\n}\n\nfunction bucketEntries (bucket, filter) {\n  return readFileAsync(\n    bucket, 'utf8'\n  ).then(data => _bucketEntries(data, filter))\n}\n\nfunction bucketEntriesSync (bucket, filter) {\n  const data = fs.readFileSync(bucket, 'utf8')\n  return _bucketEntries(data, filter)\n}\n\nfunction _bucketEntries (data, filter) {\n  let entries = []\n  data.split('\\n').forEach(entry => {\n    if (!entry) { return }\n    const pieces = entry.split('\\t')\n    if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {\n      // Hash is no good! Corruption or malice? Doesn't matter!\n      // EJECT EJECT\n      return\n    }\n    let obj\n    try {\n      obj = JSON.parse(pieces[1])\n    } catch (e) {\n      // Entry is corrupted!\n      return\n    }\n    if (obj) {\n      entries.push(obj)\n    }\n  })\n  return entries\n}\n\nmodule.exports._bucketDir = bucketDir\nfunction bucketDir (cache) {\n  return path.join(cache, `index-v${indexV}`)\n}\n\nmodule.exports._bucketPath = bucketPath\nfunction bucketPath (cache, key) {\n  const hashed = hashKey(key)\n  return path.join.apply(path, [bucketDir(cache)].concat(\n    hashToSegments(hashed)\n  ))\n}\n\nmodule.exports._hashKey = hashKey\nfunction hashKey (key) {\n  return hash(key, 'sha256')\n}\n\nmodule.exports._hashEntry = hashEntry\nfunction hashEntry (str) {\n  return hash(str, 'sha1')\n}\n\nfunction hash (str, digest) {\n  return crypto\n    .createHash(digest)\n    .update(str)\n    .digest('hex')\n}\n\nfunction formatEntry (cache, entry) {\n  // Treat null digests as deletions. They'll shadow any previous entries.\n  if (!entry.integrity) { return null }\n  return {\n    key: entry.key,\n    integrity: entry.integrity,\n    path: contentPath(cache, entry.integrity),\n    size: entry.size,\n    time: entry.time,\n    metadata: entry.metadata\n  }\n}\n\nfunction readdirOrEmpty (dir) {\n  return readdirAsync(dir)\n    .catch({ code: 'ENOENT' }, () => [])\n    .catch({ code: 'ENOTDIR' }, () => [])\n}\n\nfunction nop () {\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,EAAE,GAAGC,OAAO,CAAC,UAAU,CAAC;AAE9B,MAAMC,WAAW,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAC7C,MAAME,MAAM,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMG,YAAY,GAAGH,OAAO,CAAC,eAAe,CAAC;AAC7C,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,kBAAkB,CAAC;AAC5C,MAAMK,EAAE,GAAGL,OAAO,CAAC,aAAa,CAAC;AACjC,MAAMM,cAAc,GAAGN,OAAO,CAAC,yBAAyB,CAAC;AACzD,MAAMO,EAAE,GAAGP,OAAO,CAAC,aAAa,CAAC;AACjC,MAAMQ,IAAI,GAAGR,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMS,IAAI,GAAGT,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMU,CAAC,GAAGV,OAAO,CAAC,aAAa,CAAC;AAEhC,MAAMW,MAAM,GAAGX,OAAO,CAAC,iBAAiB,CAAC,CAAC,eAAe,CAAC,CAACY,KAAK;AAEhE,MAAMC,eAAe,GAAGd,EAAE,CAACe,SAAS,CAACT,EAAE,CAACU,UAAU,CAAC;AACnD,MAAMC,aAAa,GAAGjB,EAAE,CAACe,SAAS,CAACT,EAAE,CAACY,QAAQ,CAAC;AAC/C,MAAMC,YAAY,GAAGnB,EAAE,CAACe,SAAS,CAACT,EAAE,CAACc,OAAO,CAAC;AAC7C,MAAMC,MAAM,GAAGb,EAAE,CAACa,MAAM;AACxB,MAAMC,IAAI,GAAGd,EAAE,CAACc,IAAI;AAEpBC,MAAM,CAACC,OAAO,CAACC,aAAa,GAAG,MAAMA,aAAa,SAASC,KAAK,CAAC;EAC/DC,WAAWA,CAAEC,KAAK,EAAEC,GAAG,EAAE;IACvB,KAAK,CAAClB,CAAC,wBAAwBkB,GAAG,iBAAiBD,KAAK,IAAI,CAAC;IAC7D,IAAI,CAACE,IAAI,GAAG,QAAQ;IACpB,IAAI,CAACF,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,GAAG,GAAGA,GAAG;EAChB;AACF,CAAC;AAED,MAAME,SAAS,GAAG3B,YAAY,CAAC;EAC7B4B,QAAQ,EAAE,CAAC,CAAC;EACZC,IAAI,EAAE,CAAC;AACT,CAAC,CAAC;AAEFV,MAAM,CAACC,OAAO,CAACU,MAAM,GAAGA,MAAM;AAC9B,SAASA,MAAMA,CAAEN,KAAK,EAAEC,GAAG,EAAEM,SAAS,EAAEC,IAAI,EAAE;EAC5CA,IAAI,GAAGL,SAAS,CAACK,IAAI,CAAC;EACtB,MAAMC,MAAM,GAAGC,UAAU,CAACV,KAAK,EAAEC,GAAG,CAAC;EACrC,MAAMU,KAAK,GAAG;IACZV,GAAG;IACHM,SAAS,EAAEA,SAAS,IAAIzB,IAAI,CAAC8B,SAAS,CAACL,SAAS,CAAC;IACjDM,IAAI,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC;IAChBV,IAAI,EAAEG,IAAI,CAACH,IAAI;IACfD,QAAQ,EAAEI,IAAI,CAACJ;EACjB,CAAC;EACD,OAAO3B,QAAQ,CAACuC,QAAQ,CACtBhB,KAAK,EAAEnB,IAAI,CAACoC,OAAO,CAACR,MAAM,CAC5B,CAAC,CAACS,IAAI,CAAC,MAAM;IACX,MAAMC,WAAW,GAAGC,IAAI,CAACR,SAAS,CAACD,KAAK,CAAC;IACzC;IACA;IACA;IACA;IACA;IACA;IACA;IACA,OAAOzB,eAAe,CACpBuB,MAAM,EAAE,KAAKY,SAAS,CAACF,WAAW,CAAC,KAAKA,WAAW,EACrD,CAAC;EACH,CAAC,CAAC,CAACD,IAAI,CACL,MAAMzC,QAAQ,CAAC6C,MAAM,CAACtB,KAAK,EAAES,MAAM,CACrC,CAAC,CAACc,KAAK,CAAC;IAAErB,IAAI,EAAE;EAAS,CAAC,EAAE,MAAM;IAChC;IACA;IACA;IACA;IACA;EAAA,CACD,CAAC,CAACgB,IAAI,CAAC,MAAM;IACZ,OAAOM,WAAW,CAACxB,KAAK,EAAEW,KAAK,CAAC;EAClC,CAAC,CAAC;AACJ;AAEAhB,MAAM,CAACC,OAAO,CAACU,MAAM,CAACmB,IAAI,GAAGC,UAAU;AACvC,SAASA,UAAUA,CAAE1B,KAAK,EAAEC,GAAG,EAAEM,SAAS,EAAEC,IAAI,EAAE;EAChDA,IAAI,GAAGL,SAAS,CAACK,IAAI,CAAC;EACtB,MAAMC,MAAM,GAAGC,UAAU,CAACV,KAAK,EAAEC,GAAG,CAAC;EACrC,MAAMU,KAAK,GAAG;IACZV,GAAG;IACHM,SAAS,EAAEA,SAAS,IAAIzB,IAAI,CAAC8B,SAAS,CAACL,SAAS,CAAC;IACjDM,IAAI,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC;IAChBV,IAAI,EAAEG,IAAI,CAACH,IAAI;IACfD,QAAQ,EAAEI,IAAI,CAACJ;EACjB,CAAC;EACD3B,QAAQ,CAACuC,QAAQ,CAACS,IAAI,CAACzB,KAAK,EAAEnB,IAAI,CAACoC,OAAO,CAACR,MAAM,CAAC,CAAC;EACnD,MAAMU,WAAW,GAAGC,IAAI,CAACR,SAAS,CAACD,KAAK,CAAC;EACzCjC,EAAE,CAACiD,cAAc,CACflB,MAAM,EAAE,KAAKY,SAAS,CAACF,WAAW,CAAC,KAAKA,WAAW,EACrD,CAAC;EACD,IAAI;IACF1C,QAAQ,CAAC6C,MAAM,CAACG,IAAI,CAACzB,KAAK,EAAES,MAAM,CAAC;EACrC,CAAC,CAAC,OAAOmB,GAAG,EAAE;IACZ,IAAIA,GAAG,CAAC1B,IAAI,KAAK,QAAQ,EAAE;MACzB,MAAM0B,GAAG;IACX;EACF;EACA,OAAOJ,WAAW,CAACxB,KAAK,EAAEW,KAAK,CAAC;AAClC;AAEAhB,MAAM,CAACC,OAAO,CAACiC,IAAI,GAAGA,IAAI;AAC1B,SAASA,IAAIA,CAAE7B,KAAK,EAAEC,GAAG,EAAE;EACzB,MAAMQ,MAAM,GAAGC,UAAU,CAACV,KAAK,EAAEC,GAAG,CAAC;EACrC,OAAO6B,aAAa,CAACrB,MAAM,CAAC,CAACS,IAAI,CAACa,OAAO,IAAI;IAC3C,OAAOA,OAAO,CAACC,MAAM,CAAC,CAACC,MAAM,EAAEC,IAAI,KAAK;MACtC,IAAIA,IAAI,IAAIA,IAAI,CAACjC,GAAG,KAAKA,GAAG,EAAE;QAC5B,OAAOuB,WAAW,CAACxB,KAAK,EAAEkC,IAAI,CAAC;MACjC,CAAC,MAAM;QACL,OAAOD,MAAM;MACf;IACF,CAAC,EAAE,IAAI,CAAC;EACV,CAAC,CAAC,CAACV,KAAK,CAACK,GAAG,IAAI;IACd,IAAIA,GAAG,CAAC1B,IAAI,KAAK,QAAQ,EAAE;MACzB,OAAO,IAAI;IACb,CAAC,MAAM;MACL,MAAM0B,GAAG;IACX;EACF,CAAC,CAAC;AACJ;AAEAjC,MAAM,CAACC,OAAO,CAACiC,IAAI,CAACJ,IAAI,GAAGU,QAAQ;AACnC,SAASA,QAAQA,CAAEnC,KAAK,EAAEC,GAAG,EAAE;EAC7B,MAAMQ,MAAM,GAAGC,UAAU,CAACV,KAAK,EAAEC,GAAG,CAAC;EACrC,IAAI;IACF,OAAOmC,iBAAiB,CAAC3B,MAAM,CAAC,CAACuB,MAAM,CAAC,CAACC,MAAM,EAAEC,IAAI,KAAK;MACxD,IAAIA,IAAI,IAAIA,IAAI,CAACjC,GAAG,KAAKA,GAAG,EAAE;QAC5B,OAAOuB,WAAW,CAACxB,KAAK,EAAEkC,IAAI,CAAC;MACjC,CAAC,MAAM;QACL,OAAOD,MAAM;MACf;IACF,CAAC,EAAE,IAAI,CAAC;EACV,CAAC,CAAC,OAAOL,GAAG,EAAE;IACZ,IAAIA,GAAG,CAAC1B,IAAI,KAAK,QAAQ,EAAE;MACzB,OAAO,IAAI;IACb,CAAC,MAAM;MACL,MAAM0B,GAAG;IACX;EACF;AACF;AAEAjC,MAAM,CAACC,OAAO,CAACyC,MAAM,GAAGC,GAAG;AAC3B,SAASA,GAAGA,CAAEtC,KAAK,EAAEC,GAAG,EAAEO,IAAI,EAAE;EAC9B,OAAOF,MAAM,CAACN,KAAK,EAAEC,GAAG,EAAE,IAAI,EAAEO,IAAI,CAAC;AACvC;AAEAb,MAAM,CAACC,OAAO,CAACyC,MAAM,CAACZ,IAAI,GAAGc,OAAO;AACpC,SAASA,OAAOA,CAAEvC,KAAK,EAAEC,GAAG,EAAEO,IAAI,EAAE;EAClC,OAAOkB,UAAU,CAAC1B,KAAK,EAAEC,GAAG,EAAE,IAAI,EAAEO,IAAI,CAAC;AAC3C;AAEAb,MAAM,CAACC,OAAO,CAAC4C,QAAQ,GAAGA,QAAQ;AAClC,SAASA,QAAQA,CAAExC,KAAK,EAAE;EACxB,MAAMyC,QAAQ,GAAGC,SAAS,CAAC1C,KAAK,CAAC;EACjC,MAAM2C,MAAM,GAAGjD,IAAI,CAACkD,GAAG,CAAC,CAAC;;EAEzB;EACAC,cAAc,CAACJ,QAAQ,CAAC,CAACK,GAAG,CAACrC,MAAM,IAAI;IACrC,MAAMC,UAAU,GAAG7B,IAAI,CAACkE,IAAI,CAACN,QAAQ,EAAEhC,MAAM,CAAC;;IAE9C;IACA,OAAOoC,cAAc,CAACnC,UAAU,CAAC,CAACoC,GAAG,CAACE,SAAS,IAAI;MACjD,MAAMC,aAAa,GAAGpE,IAAI,CAACkE,IAAI,CAACrC,UAAU,EAAEsC,SAAS,CAAC;;MAEtD;MACA,OAAOH,cAAc,CAACI,aAAa,CAAC,CAACH,GAAG,CAACnC,KAAK,IAAI;QAChD,MAAMuC,aAAa,GAAGpB,aAAa,CACjCjD,IAAI,CAACkE,IAAI,CAACE,aAAa,EAAEtC,KAAK,CAChC,CAAC,CAACqB,MAAM,CAAC,CAACmB,GAAG,EAAExC,KAAK,KAAK;UACvBwC,GAAG,CAACC,GAAG,CAACzC,KAAK,CAACV,GAAG,EAAEU,KAAK,CAAC;UACzB,OAAOwC,GAAG;QACZ,CAAC,EAAE,IAAIE,GAAG,CAAC,CAAC,CAAC;QAEb,OAAOH,aAAa,CAAChC,IAAI,CAACoC,OAAO,IAAI;UACnC,KAAK,IAAI3C,KAAK,IAAI2C,OAAO,CAACC,MAAM,CAAC,CAAC,EAAE;YAClC,MAAMC,SAAS,GAAGhC,WAAW,CAACxB,KAAK,EAAEW,KAAK,CAAC;YAC3C6C,SAAS,IAAIb,MAAM,CAACc,IAAI,CAACD,SAAS,CAAC;UACrC;QACF,CAAC,CAAC,CAACjC,KAAK,CAAC;UAAErB,IAAI,EAAE;QAAS,CAAC,EAAEwD,GAAG,CAAC;MACnC,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC,CAAC,CAACxC,IAAI,CAAC,MAAM;IACZyB,MAAM,CAACc,IAAI,CAAC,IAAI,CAAC;EACnB,CAAC,EAAE7B,GAAG,IAAI;IACRe,MAAM,CAACgB,IAAI,CAAC,OAAO,EAAE/B,GAAG,CAAC;EAC3B,CAAC,CAAC;EAEF,OAAOe,MAAM;AACf;AAEAhD,MAAM,CAACC,OAAO,CAACgE,EAAE,GAAGA,EAAE;AACtB,SAASA,EAAEA,CAAE5D,KAAK,EAAE;EAClB,OAAO5B,EAAE,CAACyF,QAAQ,CAACC,EAAE,IAAI;IACvBtB,QAAQ,CAACxC,KAAK,CAAC,CAAC+D,EAAE,CAAC,OAAO,EAAED,EAAE,CAAC,CAACE,IAAI,CAACvE,MAAM,CAACsC,OAAO,IAAI;MACrD+B,EAAE,CAAC,IAAI,EAAE/B,OAAO,CAACC,MAAM,CAAC,CAACmB,GAAG,EAAEc,EAAE,KAAK;QACnCd,GAAG,CAACc,EAAE,CAAChE,GAAG,CAAC,GAAGgE,EAAE;QAChB,OAAOd,GAAG;MACZ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACT,CAAC,CAAC,CAAC;EACL,CAAC,CAAC;AACJ;AAEA,SAASrB,aAAaA,CAAErB,MAAM,EAAEyD,MAAM,EAAE;EACtC,OAAO7E,aAAa,CAClBoB,MAAM,EAAE,MACV,CAAC,CAACS,IAAI,CAACiD,IAAI,IAAIC,cAAc,CAACD,IAAI,EAAED,MAAM,CAAC,CAAC;AAC9C;AAEA,SAAS9B,iBAAiBA,CAAE3B,MAAM,EAAEyD,MAAM,EAAE;EAC1C,MAAMC,IAAI,GAAGzF,EAAE,CAAC2F,YAAY,CAAC5D,MAAM,EAAE,MAAM,CAAC;EAC5C,OAAO2D,cAAc,CAACD,IAAI,EAAED,MAAM,CAAC;AACrC;AAEA,SAASE,cAAcA,CAAED,IAAI,EAAED,MAAM,EAAE;EACrC,IAAInC,OAAO,GAAG,EAAE;EAChBoC,IAAI,CAACG,KAAK,CAAC,IAAI,CAAC,CAACC,OAAO,CAAC5D,KAAK,IAAI;IAChC,IAAI,CAACA,KAAK,EAAE;MAAE;IAAO;IACrB,MAAM6D,MAAM,GAAG7D,KAAK,CAAC2D,KAAK,CAAC,IAAI,CAAC;IAChC,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC,IAAInD,SAAS,CAACmD,MAAM,CAAC,CAAC,CAAC,CAAC,KAAKA,MAAM,CAAC,CAAC,CAAC,EAAE;MACpD;MACA;MACA;IACF;IACA,IAAI5B,GAAG;IACP,IAAI;MACFA,GAAG,GAAGxB,IAAI,CAACqD,KAAK,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC;IAC7B,CAAC,CAAC,OAAOE,CAAC,EAAE;MACV;MACA;IACF;IACA,IAAI9B,GAAG,EAAE;MACPb,OAAO,CAAC0B,IAAI,CAACb,GAAG,CAAC;IACnB;EACF,CAAC,CAAC;EACF,OAAOb,OAAO;AAChB;AAEApC,MAAM,CAACC,OAAO,CAAC+E,UAAU,GAAGjC,SAAS;AACrC,SAASA,SAASA,CAAE1C,KAAK,EAAE;EACzB,OAAOnB,IAAI,CAACkE,IAAI,CAAC/C,KAAK,EAAE,UAAUhB,MAAM,EAAE,CAAC;AAC7C;AAEAW,MAAM,CAACC,OAAO,CAACgF,WAAW,GAAGlE,UAAU;AACvC,SAASA,UAAUA,CAAEV,KAAK,EAAEC,GAAG,EAAE;EAC/B,MAAM4E,MAAM,GAAGC,OAAO,CAAC7E,GAAG,CAAC;EAC3B,OAAOpB,IAAI,CAACkE,IAAI,CAACgC,KAAK,CAAClG,IAAI,EAAE,CAAC6D,SAAS,CAAC1C,KAAK,CAAC,CAAC,CAACP,MAAM,CACpDd,cAAc,CAACkG,MAAM,CACvB,CAAC,CAAC;AACJ;AAEAlF,MAAM,CAACC,OAAO,CAACoF,QAAQ,GAAGF,OAAO;AACjC,SAASA,OAAOA,CAAE7E,GAAG,EAAE;EACrB,OAAOgF,IAAI,CAAChF,GAAG,EAAE,QAAQ,CAAC;AAC5B;AAEAN,MAAM,CAACC,OAAO,CAACsF,UAAU,GAAG7D,SAAS;AACrC,SAASA,SAASA,CAAE8D,GAAG,EAAE;EACvB,OAAOF,IAAI,CAACE,GAAG,EAAE,MAAM,CAAC;AAC1B;AAEA,SAASF,IAAIA,CAAEE,GAAG,EAAEC,MAAM,EAAE;EAC1B,OAAO7G,MAAM,CACV8G,UAAU,CAACD,MAAM,CAAC,CAClBE,MAAM,CAACH,GAAG,CAAC,CACXC,MAAM,CAAC,KAAK,CAAC;AAClB;AAEA,SAAS5D,WAAWA,CAAExB,KAAK,EAAEW,KAAK,EAAE;EAClC;EACA,IAAI,CAACA,KAAK,CAACJ,SAAS,EAAE;IAAE,OAAO,IAAI;EAAC;EACpC,OAAO;IACLN,GAAG,EAAEU,KAAK,CAACV,GAAG;IACdM,SAAS,EAAEI,KAAK,CAACJ,SAAS;IAC1B1B,IAAI,EAAEP,WAAW,CAAC0B,KAAK,EAAEW,KAAK,CAACJ,SAAS,CAAC;IACzCF,IAAI,EAAEM,KAAK,CAACN,IAAI;IAChBQ,IAAI,EAAEF,KAAK,CAACE,IAAI;IAChBT,QAAQ,EAAEO,KAAK,CAACP;EAClB,CAAC;AACH;AAEA,SAASyC,cAAcA,CAAE0C,GAAG,EAAE;EAC5B,OAAOhG,YAAY,CAACgG,GAAG,CAAC,CACrBhE,KAAK,CAAC;IAAErB,IAAI,EAAE;EAAS,CAAC,EAAE,MAAM,EAAE,CAAC,CACnCqB,KAAK,CAAC;IAAErB,IAAI,EAAE;EAAU,CAAC,EAAE,MAAM,EAAE,CAAC;AACzC;AAEA,SAASwD,GAAGA,CAAA,EAAI,CAChB","ignoreList":[]},"metadata":{},"sourceType":"script"}