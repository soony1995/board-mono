{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\");\nconst LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\nconst addToSetMap = (map, key, value) => {\n  const set = map.get(key);\n  if (set === undefined) {\n    map.set(key, new Set([value]));\n  } else {\n    set.add(value);\n  }\n};\nclass LimitChunkCountPlugin {\n  /**\n   * @param {LimitChunkCountPluginOptions=} options options object\n   */\n  constructor(options) {\n    if (!options) options = {};\n    validateOptions(schema, options, \"Limit Chunk Count Plugin\");\n    this.options = options;\n  }\n\n  /**\n   * @param {Compiler} compiler the webpack compiler\n   * @returns {void}\n   */\n  apply(compiler) {\n    const options = this.options;\n    compiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", compilation => {\n      compilation.hooks.optimizeChunksAdvanced.tap(\"LimitChunkCountPlugin\", chunks => {\n        const maxChunks = options.maxChunks;\n        if (!maxChunks) return;\n        if (maxChunks < 1) return;\n        if (chunks.length <= maxChunks) return;\n        let remainingChunksToMerge = chunks.length - maxChunks;\n\n        // order chunks in a deterministic way\n        const orderedChunks = chunks.slice().sort((a, b) => a.compareTo(b));\n\n        // create a lazy sorted data structure to keep all combinations\n        // this is large. Size = chunks * (chunks - 1) / 2\n        // It uses a multi layer bucket sort plus normal sort in the last layer\n        // It's also lazy so only accessed buckets are sorted\n        const combinations = new LazyBucketSortedSet(\n        // Layer 1: ordered by largest size benefit\n        c => c.sizeDiff, (a, b) => b - a,\n        // Layer 2: ordered by smallest combined size\n        c => c.integratedSize, (a, b) => a - b,\n        // Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n        c => c.bIdx - c.aIdx, (a, b) => a - b,\n        // Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n        (a, b) => a.bIdx - b.bIdx);\n\n        // we keep a mappng from chunk to all combinations\n        // but this mapping is not kept up-to-date with deletions\n        // so `deleted` flag need to be considered when iterating this\n        /** @type {Map<Chunk, Set<ChunkCombination>>} */\n        const combinationsByChunk = new Map();\n        orderedChunks.forEach((b, bIdx) => {\n          // create combination pairs with size and integrated size\n          for (let aIdx = 0; aIdx < bIdx; aIdx++) {\n            const a = orderedChunks[aIdx];\n            const integratedSize = a.integratedSize(b, options);\n\n            // filter pairs that do not have an integratedSize\n            // meaning they can NOT be integrated!\n            if (integratedSize === false) continue;\n            const aSize = a.size(options);\n            const bSize = b.size(options);\n            const c = {\n              deleted: false,\n              sizeDiff: aSize + bSize - integratedSize,\n              integratedSize,\n              a,\n              b,\n              aIdx,\n              bIdx,\n              aSize,\n              bSize\n            };\n            combinations.add(c);\n            addToSetMap(combinationsByChunk, a, c);\n            addToSetMap(combinationsByChunk, b, c);\n          }\n          return combinations;\n        });\n\n        // list of modified chunks during this run\n        // combinations affected by this change are skipped to allow\n        // futher optimizations\n        /** @type {Set<Chunk>} */\n        const modifiedChunks = new Set();\n        let changed = false;\n        // eslint-disable-next-line no-constant-condition\n        loop: while (true) {\n          const combination = combinations.popFirst();\n          if (combination === undefined) break;\n          combination.deleted = true;\n          const {\n            a,\n            b,\n            integratedSize\n          } = combination;\n\n          // skip over pair when\n          // one of the already merged chunks is a parent of one of the chunks\n          if (modifiedChunks.size > 0) {\n            const queue = new Set(a.groupsIterable);\n            for (const group of b.groupsIterable) {\n              queue.add(group);\n            }\n            for (const group of queue) {\n              for (const mChunk of modifiedChunks) {\n                if (mChunk !== a && mChunk !== b && mChunk.isInGroup(group)) {\n                  // This is a potential pair which needs recalculation\n                  // We can't do that now, but it merge before following pairs\n                  // so we leave space for it, and consider chunks as modified\n                  // just for the worse case\n                  remainingChunksToMerge--;\n                  if (remainingChunksToMerge <= 0) break loop;\n                  modifiedChunks.add(a);\n                  modifiedChunks.add(b);\n                  continue loop;\n                }\n              }\n              for (const parent of group.parentsIterable) {\n                queue.add(parent);\n              }\n            }\n          }\n\n          // merge the chunks\n          if (a.integrate(b, \"limit\")) {\n            chunks.splice(chunks.indexOf(b), 1);\n\n            // flag chunk a as modified as further optimization are possible for all children here\n            modifiedChunks.add(a);\n            changed = true;\n            remainingChunksToMerge--;\n            if (remainingChunksToMerge <= 0) break;\n\n            // Update all affected combinations\n            // delete all combination with the removed chunk\n            // we will use combinations with the kept chunk instead\n            for (const combination of combinationsByChunk.get(b)) {\n              if (combination.deleted) continue;\n              combination.deleted = true;\n              combinations.delete(combination);\n            }\n\n            // Update combinations with the kept chunk with new sizes\n            for (const combination of combinationsByChunk.get(a)) {\n              if (combination.deleted) continue;\n              if (combination.a === a) {\n                // Update size\n                const newIntegratedSize = a.integratedSize(combination.b, options);\n                if (newIntegratedSize === false) {\n                  combination.deleted = true;\n                  combinations.delete(combination);\n                  continue;\n                }\n                const finishUpdate = combinations.startUpdate(combination);\n                combination.integratedSize = newIntegratedSize;\n                combination.aSize = integratedSize;\n                combination.sizeDiff = combination.bSize + integratedSize - newIntegratedSize;\n                finishUpdate();\n              } else if (combination.b === a) {\n                // Update size\n                const newIntegratedSize = combination.a.integratedSize(a, options);\n                if (newIntegratedSize === false) {\n                  combination.deleted = true;\n                  combinations.delete(combination);\n                  continue;\n                }\n                const finishUpdate = combinations.startUpdate(combination);\n                combination.integratedSize = newIntegratedSize;\n                combination.bSize = integratedSize;\n                combination.sizeDiff = integratedSize + combination.aSize - newIntegratedSize;\n                finishUpdate();\n              }\n            }\n          }\n        }\n        if (changed) return true;\n      });\n    });\n  }\n}\nmodule.exports = LimitChunkCountPlugin;","map":{"version":3,"names":["validateOptions","require","schema","LazyBucketSortedSet","addToSetMap","map","key","value","set","get","undefined","Set","add","LimitChunkCountPlugin","constructor","options","apply","compiler","hooks","compilation","tap","optimizeChunksAdvanced","chunks","maxChunks","length","remainingChunksToMerge","orderedChunks","slice","sort","a","b","compareTo","combinations","c","sizeDiff","integratedSize","bIdx","aIdx","combinationsByChunk","Map","forEach","aSize","size","bSize","deleted","modifiedChunks","changed","loop","combination","popFirst","queue","groupsIterable","group","mChunk","isInGroup","parent","parentsIterable","integrate","splice","indexOf","delete","newIntegratedSize","finishUpdate","startUpdate","module","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/optimize/LimitChunkCountPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\");\nconst LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\nconst addToSetMap = (map, key, value) => {\n\tconst set = map.get(key);\n\tif (set === undefined) {\n\t\tmap.set(key, new Set([value]));\n\t} else {\n\t\tset.add(value);\n\t}\n};\n\nclass LimitChunkCountPlugin {\n\t/**\n\t * @param {LimitChunkCountPluginOptions=} options options object\n\t */\n\tconstructor(options) {\n\t\tif (!options) options = {};\n\n\t\tvalidateOptions(schema, options, \"Limit Chunk Count Plugin\");\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tcompiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeChunksAdvanced.tap(\n\t\t\t\t\"LimitChunkCountPlugin\",\n\t\t\t\tchunks => {\n\t\t\t\t\tconst maxChunks = options.maxChunks;\n\t\t\t\t\tif (!maxChunks) return;\n\t\t\t\t\tif (maxChunks < 1) return;\n\t\t\t\t\tif (chunks.length <= maxChunks) return;\n\n\t\t\t\t\tlet remainingChunksToMerge = chunks.length - maxChunks;\n\n\t\t\t\t\t// order chunks in a deterministic way\n\t\t\t\t\tconst orderedChunks = chunks.slice().sort((a, b) => a.compareTo(b));\n\n\t\t\t\t\t// create a lazy sorted data structure to keep all combinations\n\t\t\t\t\t// this is large. Size = chunks * (chunks - 1) / 2\n\t\t\t\t\t// It uses a multi layer bucket sort plus normal sort in the last layer\n\t\t\t\t\t// It's also lazy so only accessed buckets are sorted\n\t\t\t\t\tconst combinations = new LazyBucketSortedSet(\n\t\t\t\t\t\t// Layer 1: ordered by largest size benefit\n\t\t\t\t\t\tc => c.sizeDiff,\n\t\t\t\t\t\t(a, b) => b - a,\n\t\t\t\t\t\t// Layer 2: ordered by smallest combined size\n\t\t\t\t\t\tc => c.integratedSize,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t\t// Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n\t\t\t\t\t\tc => c.bIdx - c.aIdx,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t\t// Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n\t\t\t\t\t\t(a, b) => a.bIdx - b.bIdx\n\t\t\t\t\t);\n\n\t\t\t\t\t// we keep a mappng from chunk to all combinations\n\t\t\t\t\t// but this mapping is not kept up-to-date with deletions\n\t\t\t\t\t// so `deleted` flag need to be considered when iterating this\n\t\t\t\t\t/** @type {Map<Chunk, Set<ChunkCombination>>} */\n\t\t\t\t\tconst combinationsByChunk = new Map();\n\n\t\t\t\t\torderedChunks.forEach((b, bIdx) => {\n\t\t\t\t\t\t// create combination pairs with size and integrated size\n\t\t\t\t\t\tfor (let aIdx = 0; aIdx < bIdx; aIdx++) {\n\t\t\t\t\t\t\tconst a = orderedChunks[aIdx];\n\t\t\t\t\t\t\tconst integratedSize = a.integratedSize(b, options);\n\n\t\t\t\t\t\t\t// filter pairs that do not have an integratedSize\n\t\t\t\t\t\t\t// meaning they can NOT be integrated!\n\t\t\t\t\t\t\tif (integratedSize === false) continue;\n\n\t\t\t\t\t\t\tconst aSize = a.size(options);\n\t\t\t\t\t\t\tconst bSize = b.size(options);\n\t\t\t\t\t\t\tconst c = {\n\t\t\t\t\t\t\t\tdeleted: false,\n\t\t\t\t\t\t\t\tsizeDiff: aSize + bSize - integratedSize,\n\t\t\t\t\t\t\t\tintegratedSize,\n\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\tb,\n\t\t\t\t\t\t\t\taIdx,\n\t\t\t\t\t\t\t\tbIdx,\n\t\t\t\t\t\t\t\taSize,\n\t\t\t\t\t\t\t\tbSize\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcombinations.add(c);\n\t\t\t\t\t\t\taddToSetMap(combinationsByChunk, a, c);\n\t\t\t\t\t\t\taddToSetMap(combinationsByChunk, b, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn combinations;\n\t\t\t\t\t});\n\n\t\t\t\t\t// list of modified chunks during this run\n\t\t\t\t\t// combinations affected by this change are skipped to allow\n\t\t\t\t\t// futher optimizations\n\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\tconst modifiedChunks = new Set();\n\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\t\t\tloop: while (true) {\n\t\t\t\t\t\tconst combination = combinations.popFirst();\n\t\t\t\t\t\tif (combination === undefined) break;\n\n\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\tconst { a, b, integratedSize } = combination;\n\n\t\t\t\t\t\t// skip over pair when\n\t\t\t\t\t\t// one of the already merged chunks is a parent of one of the chunks\n\t\t\t\t\t\tif (modifiedChunks.size > 0) {\n\t\t\t\t\t\t\tconst queue = new Set(a.groupsIterable);\n\t\t\t\t\t\t\tfor (const group of b.groupsIterable) {\n\t\t\t\t\t\t\t\tqueue.add(group);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const group of queue) {\n\t\t\t\t\t\t\t\tfor (const mChunk of modifiedChunks) {\n\t\t\t\t\t\t\t\t\tif (mChunk !== a && mChunk !== b && mChunk.isInGroup(group)) {\n\t\t\t\t\t\t\t\t\t\t// This is a potential pair which needs recalculation\n\t\t\t\t\t\t\t\t\t\t// We can't do that now, but it merge before following pairs\n\t\t\t\t\t\t\t\t\t\t// so we leave space for it, and consider chunks as modified\n\t\t\t\t\t\t\t\t\t\t// just for the worse case\n\t\t\t\t\t\t\t\t\t\tremainingChunksToMerge--;\n\t\t\t\t\t\t\t\t\t\tif (remainingChunksToMerge <= 0) break loop;\n\t\t\t\t\t\t\t\t\t\tmodifiedChunks.add(a);\n\t\t\t\t\t\t\t\t\t\tmodifiedChunks.add(b);\n\t\t\t\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const parent of group.parentsIterable) {\n\t\t\t\t\t\t\t\t\tqueue.add(parent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// merge the chunks\n\t\t\t\t\t\tif (a.integrate(b, \"limit\")) {\n\t\t\t\t\t\t\tchunks.splice(chunks.indexOf(b), 1);\n\n\t\t\t\t\t\t\t// flag chunk a as modified as further optimization are possible for all children here\n\t\t\t\t\t\t\tmodifiedChunks.add(a);\n\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tremainingChunksToMerge--;\n\t\t\t\t\t\t\tif (remainingChunksToMerge <= 0) break;\n\n\t\t\t\t\t\t\t// Update all affected combinations\n\t\t\t\t\t\t\t// delete all combination with the removed chunk\n\t\t\t\t\t\t\t// we will use combinations with the kept chunk instead\n\t\t\t\t\t\t\tfor (const combination of combinationsByChunk.get(b)) {\n\t\t\t\t\t\t\t\tif (combination.deleted) continue;\n\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Update combinations with the kept chunk with new sizes\n\t\t\t\t\t\t\tfor (const combination of combinationsByChunk.get(a)) {\n\t\t\t\t\t\t\t\tif (combination.deleted) continue;\n\t\t\t\t\t\t\t\tif (combination.a === a) {\n\t\t\t\t\t\t\t\t\t// Update size\n\t\t\t\t\t\t\t\t\tconst newIntegratedSize = a.integratedSize(\n\t\t\t\t\t\t\t\t\t\tcombination.b,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (newIntegratedSize === false) {\n\t\t\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst finishUpdate = combinations.startUpdate(combination);\n\t\t\t\t\t\t\t\t\tcombination.integratedSize = newIntegratedSize;\n\t\t\t\t\t\t\t\t\tcombination.aSize = integratedSize;\n\t\t\t\t\t\t\t\t\tcombination.sizeDiff =\n\t\t\t\t\t\t\t\t\t\tcombination.bSize + integratedSize - newIntegratedSize;\n\t\t\t\t\t\t\t\t\tfinishUpdate();\n\t\t\t\t\t\t\t\t} else if (combination.b === a) {\n\t\t\t\t\t\t\t\t\t// Update size\n\t\t\t\t\t\t\t\t\tconst newIntegratedSize = combination.a.integratedSize(\n\t\t\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (newIntegratedSize === false) {\n\t\t\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst finishUpdate = combinations.startUpdate(combination);\n\t\t\t\t\t\t\t\t\tcombination.integratedSize = newIntegratedSize;\n\t\t\t\t\t\t\t\t\tcombination.bSize = integratedSize;\n\t\t\t\t\t\t\t\t\tcombination.sizeDiff =\n\t\t\t\t\t\t\t\t\t\tintegratedSize + combination.aSize - newIntegratedSize;\n\t\t\t\t\t\t\t\t\tfinishUpdate();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) return true;\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = LimitChunkCountPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}