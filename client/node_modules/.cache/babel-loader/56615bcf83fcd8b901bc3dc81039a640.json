{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Generator = require(\"../Generator\");\nconst Template = require(\"../Template\");\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\nconst {\n  RawSource\n} = require(\"webpack-sources\");\nconst {\n  editWithAST,\n  addWithAST\n} = require(\"@webassemblyjs/wasm-edit\");\nconst {\n  decode\n} = require(\"@webassemblyjs/wasm-parser\");\nconst t = require(\"@webassemblyjs/ast\");\nconst {\n  moduleContextFromModuleAST\n} = require(\"@webassemblyjs/helper-module-context\");\nconst WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"./WebAssemblyUtils\").UsedWasmDependency} UsedWasmDependency */\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Dependency\").DependencyTemplate} DependencyTemplate */\n\n/**\n * @typedef {(ArrayBuffer) => ArrayBuffer} ArrayBufferTransform\n */\n\n/**\n * @template T\n * @param {Function[]} fns transforms\n * @returns {Function} composed transform\n */\nconst compose = (...fns) => {\n  return fns.reduce((prevFn, nextFn) => {\n    return value => nextFn(prevFn(value));\n  }, value => value);\n};\n\n// TODO replace with @callback\n\n/**\n * Removes the start instruction\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\nconst removeStartFunc = state => bin => {\n  return editWithAST(state.ast, bin, {\n    Start(path) {\n      path.remove();\n    }\n  });\n};\n\n/**\n * Get imported globals\n *\n * @param {Object} ast Module's AST\n * @returns {Array<t.ModuleImport>} - nodes\n */\nconst getImportedGlobals = ast => {\n  const importedGlobals = [];\n  t.traverse(ast, {\n    ModuleImport({\n      node\n    }) {\n      if (t.isGlobalType(node.descr)) {\n        importedGlobals.push(node);\n      }\n    }\n  });\n  return importedGlobals;\n};\n\n/**\n * Get the count for imported func\n *\n * @param {Object} ast Module's AST\n * @returns {Number} - count\n */\nconst getCountImportedFunc = ast => {\n  let count = 0;\n  t.traverse(ast, {\n    ModuleImport({\n      node\n    }) {\n      if (t.isFuncImportDescr(node.descr)) {\n        count++;\n      }\n    }\n  });\n  return count;\n};\n\n/**\n * Get next type index\n *\n * @param {Object} ast Module's AST\n * @returns {t.Index} - index\n */\nconst getNextTypeIndex = ast => {\n  const typeSectionMetadata = t.getSectionMetadata(ast, \"type\");\n  if (typeSectionMetadata === undefined) {\n    return t.indexLiteral(0);\n  }\n  return t.indexLiteral(typeSectionMetadata.vectorOfSize.value);\n};\n\n/**\n * Get next func index\n *\n * The Func section metadata provide informations for implemented funcs\n * in order to have the correct index we shift the index by number of external\n * functions.\n *\n * @param {Object} ast Module's AST\n * @param {Number} countImportedFunc number of imported funcs\n * @returns {t.Index} - index\n */\nconst getNextFuncIndex = (ast, countImportedFunc) => {\n  const funcSectionMetadata = t.getSectionMetadata(ast, \"func\");\n  if (funcSectionMetadata === undefined) {\n    return t.indexLiteral(0 + countImportedFunc);\n  }\n  const vectorOfSize = funcSectionMetadata.vectorOfSize.value;\n  return t.indexLiteral(vectorOfSize + countImportedFunc);\n};\n\n/**\n * Creates an init instruction for a global type\n * @param {t.GlobalType} globalType the global type\n * @returns {t.Instruction} init expression\n */\nconst createDefaultInitForGlobal = globalType => {\n  if (globalType.valtype[0] === \"i\") {\n    // create NumberLiteral global initializer\n    return t.objectInstruction(\"const\", globalType.valtype, [t.numberLiteralFromRaw(66)]);\n  } else if (globalType.valtype[0] === \"f\") {\n    // create FloatLiteral global initializer\n    return t.objectInstruction(\"const\", globalType.valtype, [t.floatLiteral(66, false, false, \"66\")]);\n  } else {\n    throw new Error(\"unknown type: \" + globalType.valtype);\n  }\n};\n\n/**\n * Rewrite the import globals:\n * - removes the ModuleImport instruction\n * - injects at the same offset a mutable global of the same type\n *\n * Since the imported globals are before the other global declarations, our\n * indices will be preserved.\n *\n * Note that globals will become mutable.\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\nconst rewriteImportedGlobals = state => bin => {\n  const additionalInitCode = state.additionalInitCode;\n  const newGlobals = [];\n  bin = editWithAST(state.ast, bin, {\n    ModuleImport(path) {\n      if (t.isGlobalType(path.node.descr)) {\n        const globalType = path.node.descr;\n        globalType.mutability = \"var\";\n        const init = [createDefaultInitForGlobal(globalType), t.instruction(\"end\")];\n        newGlobals.push(t.global(globalType, init));\n        path.remove();\n      }\n    },\n    // in order to preserve non-imported global's order we need to re-inject\n    // those as well\n    Global(path) {\n      const {\n        node\n      } = path;\n      const [init] = node.init;\n      if (init.id === \"get_global\") {\n        node.globalType.mutability = \"var\";\n        const initialGlobalidx = init.args[0];\n        node.init = [createDefaultInitForGlobal(node.globalType), t.instruction(\"end\")];\n        additionalInitCode.push(\n        /**\n         * get_global in global initializer only works for imported globals.\n         * They have the same indices as the init params, so use the\n         * same index.\n         */\n        t.instruction(\"get_local\", [initialGlobalidx]), t.instruction(\"set_global\", [t.indexLiteral(newGlobals.length)]));\n      }\n      newGlobals.push(node);\n      path.remove();\n    }\n  });\n\n  // Add global declaration instructions\n  return addWithAST(state.ast, bin, newGlobals);\n};\n\n/**\n * Rewrite the export names\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Module} state.module Module\n * @param {Set<string>} state.externalExports Module\n * @returns {ArrayBufferTransform} transform\n */\nconst rewriteExportNames = ({\n  ast,\n  module,\n  externalExports\n}) => bin => {\n  return editWithAST(ast, bin, {\n    ModuleExport(path) {\n      const isExternal = externalExports.has(path.node.name);\n      if (isExternal) {\n        path.remove();\n        return;\n      }\n      const usedName = module.isUsed(path.node.name);\n      if (!usedName) {\n        path.remove();\n        return;\n      }\n      path.node.name = usedName;\n    }\n  });\n};\n\n/**\n * Mangle import names and modules\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Map<string, UsedWasmDependency>} state.usedDependencyMap mappings to mangle names\n * @returns {ArrayBufferTransform} transform\n */\nconst rewriteImports = ({\n  ast,\n  usedDependencyMap\n}) => bin => {\n  return editWithAST(ast, bin, {\n    ModuleImport(path) {\n      const result = usedDependencyMap.get(path.node.module + \":\" + path.node.name);\n      if (result !== undefined) {\n        path.node.module = result.module;\n        path.node.name = result.name;\n      }\n    }\n  });\n};\n\n/**\n * Add an init function.\n *\n * The init function fills the globals given input arguments.\n *\n * @param {Object} state transformation state\n * @param {Object} state.ast Module's ast\n * @param {t.Identifier} state.initFuncId identifier of the init function\n * @param {t.Index} state.startAtFuncOffset index of the start function\n * @param {t.ModuleImport[]} state.importedGlobals list of imported globals\n * @param {t.Instruction[]} state.additionalInitCode list of addition instructions for the init function\n * @param {t.Index} state.nextFuncIndex index of the next function\n * @param {t.Index} state.nextTypeIndex index of the next type\n * @returns {ArrayBufferTransform} transform\n */\nconst addInitFunction = ({\n  ast,\n  initFuncId,\n  startAtFuncOffset,\n  importedGlobals,\n  additionalInitCode,\n  nextFuncIndex,\n  nextTypeIndex\n}) => bin => {\n  const funcParams = importedGlobals.map(importedGlobal => {\n    // used for debugging\n    const id = t.identifier(`${importedGlobal.module}.${importedGlobal.name}`);\n    return t.funcParam(importedGlobal.descr.valtype, id);\n  });\n  const funcBody = importedGlobals.reduce((acc, importedGlobal, index) => {\n    const args = [t.indexLiteral(index)];\n    const body = [t.instruction(\"get_local\", args), t.instruction(\"set_global\", args)];\n    return [...acc, ...body];\n  }, []);\n  if (typeof startAtFuncOffset === \"number\") {\n    funcBody.push(t.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset)));\n  }\n  for (const instr of additionalInitCode) {\n    funcBody.push(instr);\n  }\n  funcBody.push(t.instruction(\"end\"));\n  const funcResults = [];\n\n  // Code section\n  const funcSignature = t.signature(funcParams, funcResults);\n  const func = t.func(initFuncId, funcSignature, funcBody);\n\n  // Type section\n  const functype = t.typeInstruction(undefined, funcSignature);\n\n  // Func section\n  const funcindex = t.indexInFuncSection(nextTypeIndex);\n\n  // Export section\n  const moduleExport = t.moduleExport(initFuncId.value, t.moduleExportDescr(\"Func\", nextFuncIndex));\n  return addWithAST(ast, bin, [func, moduleExport, funcindex, functype]);\n};\n\n/**\n * Extract mangle mappings from module\n * @param {Module} module current module\n * @param {boolean} mangle mangle imports\n * @returns {Map<string, UsedWasmDependency>} mappings to mangled names\n */\nconst getUsedDependencyMap = (module, mangle) => {\n  /** @type {Map<string, UsedWasmDependency>} */\n  const map = new Map();\n  for (const usedDep of WebAssemblyUtils.getUsedDependencies(module, mangle)) {\n    const dep = usedDep.dependency;\n    const request = dep.request;\n    const exportName = dep.name;\n    map.set(request + \":\" + exportName, usedDep);\n  }\n  return map;\n};\nclass WebAssemblyGenerator extends Generator {\n  constructor(options) {\n    super();\n    this.options = options;\n  }\n\n  /**\n   * @param {NormalModule} module module for which the code should be generated\n   * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates\n   * @param {RuntimeTemplate} runtimeTemplate the runtime template\n   * @param {string} type which kind of code should be generated\n   * @returns {Source} generated code\n   */\n  generate(module, dependencyTemplates, runtimeTemplate, type) {\n    let bin = module.originalSource().source();\n    const initFuncId = t.identifier(Array.isArray(module.usedExports) ? Template.numberToIdentifer(module.usedExports.length) : \"__webpack_init__\");\n\n    // parse it\n    const ast = decode(bin, {\n      ignoreDataSection: true,\n      ignoreCodeSection: true,\n      ignoreCustomNameSection: true\n    });\n    const moduleContext = moduleContextFromModuleAST(ast.body[0]);\n    const importedGlobals = getImportedGlobals(ast);\n    const countImportedFunc = getCountImportedFunc(ast);\n    const startAtFuncOffset = moduleContext.getStart();\n    const nextFuncIndex = getNextFuncIndex(ast, countImportedFunc);\n    const nextTypeIndex = getNextTypeIndex(ast);\n    const usedDependencyMap = getUsedDependencyMap(module, this.options.mangleImports);\n    const externalExports = new Set(module.dependencies.filter(d => d instanceof WebAssemblyExportImportedDependency).map(d => {\n      const wasmDep = /** @type {WebAssemblyExportImportedDependency} */d;\n      return wasmDep.exportName;\n    }));\n\n    /** @type {t.Instruction[]} */\n    const additionalInitCode = [];\n    const transform = compose(rewriteExportNames({\n      ast,\n      module,\n      externalExports\n    }), removeStartFunc({\n      ast\n    }), rewriteImportedGlobals({\n      ast,\n      additionalInitCode\n    }), rewriteImports({\n      ast,\n      usedDependencyMap\n    }), addInitFunction({\n      ast,\n      initFuncId,\n      importedGlobals,\n      additionalInitCode,\n      startAtFuncOffset,\n      nextFuncIndex,\n      nextTypeIndex\n    }));\n    const newBin = transform(bin);\n    return new RawSource(newBin);\n  }\n}\nmodule.exports = WebAssemblyGenerator;","map":{"version":3,"names":["Generator","require","Template","WebAssemblyUtils","RawSource","editWithAST","addWithAST","decode","t","moduleContextFromModuleAST","WebAssemblyExportImportedDependency","compose","fns","reduce","prevFn","nextFn","value","removeStartFunc","state","bin","ast","Start","path","remove","getImportedGlobals","importedGlobals","traverse","ModuleImport","node","isGlobalType","descr","push","getCountImportedFunc","count","isFuncImportDescr","getNextTypeIndex","typeSectionMetadata","getSectionMetadata","undefined","indexLiteral","vectorOfSize","getNextFuncIndex","countImportedFunc","funcSectionMetadata","createDefaultInitForGlobal","globalType","valtype","objectInstruction","numberLiteralFromRaw","floatLiteral","Error","rewriteImportedGlobals","additionalInitCode","newGlobals","mutability","init","instruction","global","Global","id","initialGlobalidx","args","length","rewriteExportNames","module","externalExports","ModuleExport","isExternal","has","name","usedName","isUsed","rewriteImports","usedDependencyMap","result","get","addInitFunction","initFuncId","startAtFuncOffset","nextFuncIndex","nextTypeIndex","funcParams","map","importedGlobal","identifier","funcParam","funcBody","acc","index","body","callInstruction","instr","funcResults","funcSignature","signature","func","functype","typeInstruction","funcindex","indexInFuncSection","moduleExport","moduleExportDescr","getUsedDependencyMap","mangle","Map","usedDep","getUsedDependencies","dep","dependency","request","exportName","set","WebAssemblyGenerator","constructor","options","generate","dependencyTemplates","runtimeTemplate","type","originalSource","source","Array","isArray","usedExports","numberToIdentifer","ignoreDataSection","ignoreCodeSection","ignoreCustomNameSection","moduleContext","getStart","mangleImports","Set","dependencies","filter","d","wasmDep","transform","newBin","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/wasm/WebAssemblyGenerator.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Generator = require(\"../Generator\");\nconst Template = require(\"../Template\");\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\nconst { RawSource } = require(\"webpack-sources\");\n\nconst { editWithAST, addWithAST } = require(\"@webassemblyjs/wasm-edit\");\nconst { decode } = require(\"@webassemblyjs/wasm-parser\");\nconst t = require(\"@webassemblyjs/ast\");\nconst {\n\tmoduleContextFromModuleAST\n} = require(\"@webassemblyjs/helper-module-context\");\n\nconst WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"./WebAssemblyUtils\").UsedWasmDependency} UsedWasmDependency */\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Dependency\").DependencyTemplate} DependencyTemplate */\n\n/**\n * @typedef {(ArrayBuffer) => ArrayBuffer} ArrayBufferTransform\n */\n\n/**\n * @template T\n * @param {Function[]} fns transforms\n * @returns {Function} composed transform\n */\nconst compose = (...fns) => {\n\treturn fns.reduce(\n\t\t(prevFn, nextFn) => {\n\t\t\treturn value => nextFn(prevFn(value));\n\t\t},\n\t\tvalue => value\n\t);\n};\n\n// TODO replace with @callback\n\n/**\n * Removes the start instruction\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\nconst removeStartFunc = state => bin => {\n\treturn editWithAST(state.ast, bin, {\n\t\tStart(path) {\n\t\t\tpath.remove();\n\t\t}\n\t});\n};\n\n/**\n * Get imported globals\n *\n * @param {Object} ast Module's AST\n * @returns {Array<t.ModuleImport>} - nodes\n */\nconst getImportedGlobals = ast => {\n\tconst importedGlobals = [];\n\n\tt.traverse(ast, {\n\t\tModuleImport({ node }) {\n\t\t\tif (t.isGlobalType(node.descr)) {\n\t\t\t\timportedGlobals.push(node);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn importedGlobals;\n};\n\n/**\n * Get the count for imported func\n *\n * @param {Object} ast Module's AST\n * @returns {Number} - count\n */\nconst getCountImportedFunc = ast => {\n\tlet count = 0;\n\n\tt.traverse(ast, {\n\t\tModuleImport({ node }) {\n\t\t\tif (t.isFuncImportDescr(node.descr)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn count;\n};\n\n/**\n * Get next type index\n *\n * @param {Object} ast Module's AST\n * @returns {t.Index} - index\n */\nconst getNextTypeIndex = ast => {\n\tconst typeSectionMetadata = t.getSectionMetadata(ast, \"type\");\n\n\tif (typeSectionMetadata === undefined) {\n\t\treturn t.indexLiteral(0);\n\t}\n\n\treturn t.indexLiteral(typeSectionMetadata.vectorOfSize.value);\n};\n\n/**\n * Get next func index\n *\n * The Func section metadata provide informations for implemented funcs\n * in order to have the correct index we shift the index by number of external\n * functions.\n *\n * @param {Object} ast Module's AST\n * @param {Number} countImportedFunc number of imported funcs\n * @returns {t.Index} - index\n */\nconst getNextFuncIndex = (ast, countImportedFunc) => {\n\tconst funcSectionMetadata = t.getSectionMetadata(ast, \"func\");\n\n\tif (funcSectionMetadata === undefined) {\n\t\treturn t.indexLiteral(0 + countImportedFunc);\n\t}\n\n\tconst vectorOfSize = funcSectionMetadata.vectorOfSize.value;\n\n\treturn t.indexLiteral(vectorOfSize + countImportedFunc);\n};\n\n/**\n * Creates an init instruction for a global type\n * @param {t.GlobalType} globalType the global type\n * @returns {t.Instruction} init expression\n */\nconst createDefaultInitForGlobal = globalType => {\n\tif (globalType.valtype[0] === \"i\") {\n\t\t// create NumberLiteral global initializer\n\t\treturn t.objectInstruction(\"const\", globalType.valtype, [\n\t\t\tt.numberLiteralFromRaw(66)\n\t\t]);\n\t} else if (globalType.valtype[0] === \"f\") {\n\t\t// create FloatLiteral global initializer\n\t\treturn t.objectInstruction(\"const\", globalType.valtype, [\n\t\t\tt.floatLiteral(66, false, false, \"66\")\n\t\t]);\n\t} else {\n\t\tthrow new Error(\"unknown type: \" + globalType.valtype);\n\t}\n};\n\n/**\n * Rewrite the import globals:\n * - removes the ModuleImport instruction\n * - injects at the same offset a mutable global of the same type\n *\n * Since the imported globals are before the other global declarations, our\n * indices will be preserved.\n *\n * Note that globals will become mutable.\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\nconst rewriteImportedGlobals = state => bin => {\n\tconst additionalInitCode = state.additionalInitCode;\n\tconst newGlobals = [];\n\n\tbin = editWithAST(state.ast, bin, {\n\t\tModuleImport(path) {\n\t\t\tif (t.isGlobalType(path.node.descr)) {\n\t\t\t\tconst globalType = path.node.descr;\n\n\t\t\t\tglobalType.mutability = \"var\";\n\n\t\t\t\tconst init = [\n\t\t\t\t\tcreateDefaultInitForGlobal(globalType),\n\t\t\t\t\tt.instruction(\"end\")\n\t\t\t\t];\n\n\t\t\t\tnewGlobals.push(t.global(globalType, init));\n\n\t\t\t\tpath.remove();\n\t\t\t}\n\t\t},\n\n\t\t// in order to preserve non-imported global's order we need to re-inject\n\t\t// those as well\n\t\tGlobal(path) {\n\t\t\tconst { node } = path;\n\t\t\tconst [init] = node.init;\n\n\t\t\tif (init.id === \"get_global\") {\n\t\t\t\tnode.globalType.mutability = \"var\";\n\n\t\t\t\tconst initialGlobalidx = init.args[0];\n\n\t\t\t\tnode.init = [\n\t\t\t\t\tcreateDefaultInitForGlobal(node.globalType),\n\t\t\t\t\tt.instruction(\"end\")\n\t\t\t\t];\n\n\t\t\t\tadditionalInitCode.push(\n\t\t\t\t\t/**\n\t\t\t\t\t * get_global in global initializer only works for imported globals.\n\t\t\t\t\t * They have the same indices as the init params, so use the\n\t\t\t\t\t * same index.\n\t\t\t\t\t */\n\t\t\t\t\tt.instruction(\"get_local\", [initialGlobalidx]),\n\t\t\t\t\tt.instruction(\"set_global\", [t.indexLiteral(newGlobals.length)])\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tnewGlobals.push(node);\n\n\t\t\tpath.remove();\n\t\t}\n\t});\n\n\t// Add global declaration instructions\n\treturn addWithAST(state.ast, bin, newGlobals);\n};\n\n/**\n * Rewrite the export names\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Module} state.module Module\n * @param {Set<string>} state.externalExports Module\n * @returns {ArrayBufferTransform} transform\n */\nconst rewriteExportNames = ({ ast, module, externalExports }) => bin => {\n\treturn editWithAST(ast, bin, {\n\t\tModuleExport(path) {\n\t\t\tconst isExternal = externalExports.has(path.node.name);\n\t\t\tif (isExternal) {\n\t\t\t\tpath.remove();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst usedName = module.isUsed(path.node.name);\n\t\t\tif (!usedName) {\n\t\t\t\tpath.remove();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpath.node.name = usedName;\n\t\t}\n\t});\n};\n\n/**\n * Mangle import names and modules\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Map<string, UsedWasmDependency>} state.usedDependencyMap mappings to mangle names\n * @returns {ArrayBufferTransform} transform\n */\nconst rewriteImports = ({ ast, usedDependencyMap }) => bin => {\n\treturn editWithAST(ast, bin, {\n\t\tModuleImport(path) {\n\t\t\tconst result = usedDependencyMap.get(\n\t\t\t\tpath.node.module + \":\" + path.node.name\n\t\t\t);\n\n\t\t\tif (result !== undefined) {\n\t\t\t\tpath.node.module = result.module;\n\t\t\t\tpath.node.name = result.name;\n\t\t\t}\n\t\t}\n\t});\n};\n\n/**\n * Add an init function.\n *\n * The init function fills the globals given input arguments.\n *\n * @param {Object} state transformation state\n * @param {Object} state.ast Module's ast\n * @param {t.Identifier} state.initFuncId identifier of the init function\n * @param {t.Index} state.startAtFuncOffset index of the start function\n * @param {t.ModuleImport[]} state.importedGlobals list of imported globals\n * @param {t.Instruction[]} state.additionalInitCode list of addition instructions for the init function\n * @param {t.Index} state.nextFuncIndex index of the next function\n * @param {t.Index} state.nextTypeIndex index of the next type\n * @returns {ArrayBufferTransform} transform\n */\nconst addInitFunction = ({\n\tast,\n\tinitFuncId,\n\tstartAtFuncOffset,\n\timportedGlobals,\n\tadditionalInitCode,\n\tnextFuncIndex,\n\tnextTypeIndex\n}) => bin => {\n\tconst funcParams = importedGlobals.map(importedGlobal => {\n\t\t// used for debugging\n\t\tconst id = t.identifier(`${importedGlobal.module}.${importedGlobal.name}`);\n\n\t\treturn t.funcParam(importedGlobal.descr.valtype, id);\n\t});\n\n\tconst funcBody = importedGlobals.reduce((acc, importedGlobal, index) => {\n\t\tconst args = [t.indexLiteral(index)];\n\t\tconst body = [\n\t\t\tt.instruction(\"get_local\", args),\n\t\t\tt.instruction(\"set_global\", args)\n\t\t];\n\n\t\treturn [...acc, ...body];\n\t}, []);\n\n\tif (typeof startAtFuncOffset === \"number\") {\n\t\tfuncBody.push(t.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset)));\n\t}\n\n\tfor (const instr of additionalInitCode) {\n\t\tfuncBody.push(instr);\n\t}\n\n\tfuncBody.push(t.instruction(\"end\"));\n\n\tconst funcResults = [];\n\n\t// Code section\n\tconst funcSignature = t.signature(funcParams, funcResults);\n\tconst func = t.func(initFuncId, funcSignature, funcBody);\n\n\t// Type section\n\tconst functype = t.typeInstruction(undefined, funcSignature);\n\n\t// Func section\n\tconst funcindex = t.indexInFuncSection(nextTypeIndex);\n\n\t// Export section\n\tconst moduleExport = t.moduleExport(\n\t\tinitFuncId.value,\n\t\tt.moduleExportDescr(\"Func\", nextFuncIndex)\n\t);\n\n\treturn addWithAST(ast, bin, [func, moduleExport, funcindex, functype]);\n};\n\n/**\n * Extract mangle mappings from module\n * @param {Module} module current module\n * @param {boolean} mangle mangle imports\n * @returns {Map<string, UsedWasmDependency>} mappings to mangled names\n */\nconst getUsedDependencyMap = (module, mangle) => {\n\t/** @type {Map<string, UsedWasmDependency>} */\n\tconst map = new Map();\n\tfor (const usedDep of WebAssemblyUtils.getUsedDependencies(module, mangle)) {\n\t\tconst dep = usedDep.dependency;\n\t\tconst request = dep.request;\n\t\tconst exportName = dep.name;\n\t\tmap.set(request + \":\" + exportName, usedDep);\n\t}\n\treturn map;\n};\n\nclass WebAssemblyGenerator extends Generator {\n\tconstructor(options) {\n\t\tsuper();\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {NormalModule} module module for which the code should be generated\n\t * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates\n\t * @param {RuntimeTemplate} runtimeTemplate the runtime template\n\t * @param {string} type which kind of code should be generated\n\t * @returns {Source} generated code\n\t */\n\tgenerate(module, dependencyTemplates, runtimeTemplate, type) {\n\t\tlet bin = module.originalSource().source();\n\n\t\tconst initFuncId = t.identifier(\n\t\t\tArray.isArray(module.usedExports)\n\t\t\t\t? Template.numberToIdentifer(module.usedExports.length)\n\t\t\t\t: \"__webpack_init__\"\n\t\t);\n\n\t\t// parse it\n\t\tconst ast = decode(bin, {\n\t\t\tignoreDataSection: true,\n\t\t\tignoreCodeSection: true,\n\t\t\tignoreCustomNameSection: true\n\t\t});\n\n\t\tconst moduleContext = moduleContextFromModuleAST(ast.body[0]);\n\n\t\tconst importedGlobals = getImportedGlobals(ast);\n\t\tconst countImportedFunc = getCountImportedFunc(ast);\n\t\tconst startAtFuncOffset = moduleContext.getStart();\n\t\tconst nextFuncIndex = getNextFuncIndex(ast, countImportedFunc);\n\t\tconst nextTypeIndex = getNextTypeIndex(ast);\n\n\t\tconst usedDependencyMap = getUsedDependencyMap(\n\t\t\tmodule,\n\t\t\tthis.options.mangleImports\n\t\t);\n\t\tconst externalExports = new Set(\n\t\t\tmodule.dependencies\n\t\t\t\t.filter(d => d instanceof WebAssemblyExportImportedDependency)\n\t\t\t\t.map(d => {\n\t\t\t\t\tconst wasmDep = /** @type {WebAssemblyExportImportedDependency} */ (d);\n\t\t\t\t\treturn wasmDep.exportName;\n\t\t\t\t})\n\t\t);\n\n\t\t/** @type {t.Instruction[]} */\n\t\tconst additionalInitCode = [];\n\n\t\tconst transform = compose(\n\t\t\trewriteExportNames({\n\t\t\t\tast,\n\t\t\t\tmodule,\n\t\t\t\texternalExports\n\t\t\t}),\n\n\t\t\tremoveStartFunc({ ast }),\n\n\t\t\trewriteImportedGlobals({ ast, additionalInitCode }),\n\n\t\t\trewriteImports({\n\t\t\t\tast,\n\t\t\t\tusedDependencyMap\n\t\t\t}),\n\n\t\t\taddInitFunction({\n\t\t\t\tast,\n\t\t\t\tinitFuncId,\n\t\t\t\timportedGlobals,\n\t\t\t\tadditionalInitCode,\n\t\t\t\tstartAtFuncOffset,\n\t\t\t\tnextFuncIndex,\n\t\t\t\tnextTypeIndex\n\t\t\t})\n\t\t);\n\n\t\tconst newBin = transform(bin);\n\n\t\treturn new RawSource(newBin);\n\t}\n}\n\nmodule.exports = WebAssemblyGenerator;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}