{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst SortableSet = require(\"./util/SortableSet\");\nconst compareLocations = require(\"./compareLocations\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleReason\")} ModuleReason */\n\n/** @typedef {{module: Module, loc: TODO, request: string}} OriginRecord */\n/** @typedef {string|{name: string}} ChunkGroupOptions */\n\nlet debugId = 5000;\n\n/**\n * @template T\n * @param {SortableSet<T>} set set to convert to array.\n * @returns {T[]} the array format of existing set\n */\nconst getArray = set => Array.from(set);\n\n/**\n * A convenience method used to sort chunks based on their id's\n * @param {ChunkGroup} a first sorting comparator\n * @param {ChunkGroup} b second sorting comparator\n * @returns {1|0|-1} a sorting index to determine order\n */\nconst sortById = (a, b) => {\n  if (a.id < b.id) return -1;\n  if (b.id < a.id) return 1;\n  return 0;\n};\n\n/**\n * @param {OriginRecord} a the first comparator in sort\n * @param {OriginRecord} b the second comparator in sort\n * @returns {1|-1|0} returns sorting order as index\n */\nconst sortOrigin = (a, b) => {\n  const aIdent = a.module ? a.module.identifier() : \"\";\n  const bIdent = b.module ? b.module.identifier() : \"\";\n  if (aIdent < bIdent) return -1;\n  if (aIdent > bIdent) return 1;\n  return compareLocations(a.loc, b.loc);\n};\nclass ChunkGroup {\n  /**\n   * Creates an instance of ChunkGroup.\n   * @param {ChunkGroupOptions=} options chunk group options passed to chunkGroup\n   */\n  constructor(options) {\n    if (typeof options === \"string\") {\n      options = {\n        name: options\n      };\n    } else if (!options) {\n      options = {\n        name: undefined\n      };\n    }\n    /** @type {number} */\n    this.groupDebugId = debugId++;\n    this.options = options;\n    /** @type {SortableSet<ChunkGroup>} */\n    this._children = new SortableSet(undefined, sortById);\n    this._parents = new SortableSet(undefined, sortById);\n    this._blocks = new SortableSet();\n    /** @type {Chunk[]} */\n    this.chunks = [];\n    /** @type {OriginRecord[]} */\n    this.origins = [];\n    /** Indices in top-down order */\n    /** @private @type {Map<Module, number>} */\n    this._moduleIndices = new Map();\n    /** Indices in bottom-up order */\n    /** @private @type {Map<Module, number>} */\n    this._moduleIndices2 = new Map();\n  }\n\n  /**\n   * when a new chunk is added to a chunkGroup, addingOptions will occur.\n   * @param {ChunkGroupOptions} options the chunkGroup options passed to addOptions\n   * @returns {void}\n   */\n  addOptions(options) {\n    for (const key of Object.keys(options)) {\n      if (this.options[key] === undefined) {\n        this.options[key] = options[key];\n      } else if (this.options[key] !== options[key]) {\n        if (key.endsWith(\"Order\")) {\n          this.options[key] = Math.max(this.options[key], options[key]);\n        } else {\n          throw new Error(`ChunkGroup.addOptions: No option merge strategy for ${key}`);\n        }\n      }\n    }\n  }\n\n  /**\n   * returns the name of current ChunkGroup\n   * @returns {string|undefined} returns the ChunkGroup name\n   */\n  get name() {\n    return this.options.name;\n  }\n\n  /**\n   * sets a new name for current ChunkGroup\n   * @param {string} value the new name for ChunkGroup\n   * @returns {void}\n   */\n  set name(value) {\n    this.options.name = value;\n  }\n\n  /**\n   * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's\n   * @returns {string} a unique concatenation of chunk debugId's\n   */\n  get debugId() {\n    return Array.from(this.chunks, x => x.debugId).join(\"+\");\n  }\n\n  /**\n   * get a unique id for ChunkGroup, made up of its member Chunk id's\n   * @returns {string} a unique concatenation of chunk ids\n   */\n  get id() {\n    return Array.from(this.chunks, x => x.id).join(\"+\");\n  }\n\n  /**\n   * Performs an unshift of a specific chunk\n   * @param {Chunk} chunk chunk being unshifted\n   * @returns {boolean} returns true if attempted chunk shift is accepted\n   */\n  unshiftChunk(chunk) {\n    const oldIdx = this.chunks.indexOf(chunk);\n    if (oldIdx > 0) {\n      this.chunks.splice(oldIdx, 1);\n      this.chunks.unshift(chunk);\n    } else if (oldIdx < 0) {\n      this.chunks.unshift(chunk);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * inserts a chunk before another existing chunk in group\n   * @param {Chunk} chunk Chunk being inserted\n   * @param {Chunk} before Placeholder/target chunk marking new chunk insertion point\n   * @returns {boolean} return true if insertion was successful\n   */\n  insertChunk(chunk, before) {\n    const oldIdx = this.chunks.indexOf(chunk);\n    const idx = this.chunks.indexOf(before);\n    if (idx < 0) {\n      throw new Error(\"before chunk not found\");\n    }\n    if (oldIdx >= 0 && oldIdx > idx) {\n      this.chunks.splice(oldIdx, 1);\n      this.chunks.splice(idx, 0, chunk);\n    } else if (oldIdx < 0) {\n      this.chunks.splice(idx, 0, chunk);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * add a chunk into ChunkGroup. Is pushed on or prepended\n   * @param {Chunk} chunk chunk being pushed into ChunkGroupS\n   * @returns {boolean} returns true if chunk addition was successful.\n   */\n  pushChunk(chunk) {\n    const oldIdx = this.chunks.indexOf(chunk);\n    if (oldIdx >= 0) {\n      return false;\n    }\n    this.chunks.push(chunk);\n    return true;\n  }\n\n  /**\n   * @param {Chunk} oldChunk chunk to be replaced\n   * @param {Chunk} newChunk New chunk that will be replaced with\n   * @returns {boolean} returns true if the replacement was successful\n   */\n  replaceChunk(oldChunk, newChunk) {\n    const oldIdx = this.chunks.indexOf(oldChunk);\n    if (oldIdx < 0) return false;\n    const newIdx = this.chunks.indexOf(newChunk);\n    if (newIdx < 0) {\n      this.chunks[oldIdx] = newChunk;\n      return true;\n    }\n    if (newIdx < oldIdx) {\n      this.chunks.splice(oldIdx, 1);\n      return true;\n    } else if (newIdx !== oldIdx) {\n      this.chunks[oldIdx] = newChunk;\n      this.chunks.splice(newIdx, 1);\n      return true;\n    }\n  }\n  removeChunk(chunk) {\n    const idx = this.chunks.indexOf(chunk);\n    if (idx >= 0) {\n      this.chunks.splice(idx, 1);\n      return true;\n    }\n    return false;\n  }\n  isInitial() {\n    return false;\n  }\n  addChild(chunk) {\n    if (this._children.has(chunk)) {\n      return false;\n    }\n    this._children.add(chunk);\n    return true;\n  }\n  getChildren() {\n    return this._children.getFromCache(getArray);\n  }\n  getNumberOfChildren() {\n    return this._children.size;\n  }\n  get childrenIterable() {\n    return this._children;\n  }\n  removeChild(chunk) {\n    if (!this._children.has(chunk)) {\n      return false;\n    }\n    this._children.delete(chunk);\n    chunk.removeParent(this);\n    return true;\n  }\n  addParent(parentChunk) {\n    if (!this._parents.has(parentChunk)) {\n      this._parents.add(parentChunk);\n      return true;\n    }\n    return false;\n  }\n  getParents() {\n    return this._parents.getFromCache(getArray);\n  }\n  setParents(newParents) {\n    this._parents.clear();\n    for (const p of newParents) {\n      this._parents.add(p);\n    }\n  }\n  getNumberOfParents() {\n    return this._parents.size;\n  }\n  hasParent(parent) {\n    return this._parents.has(parent);\n  }\n  get parentsIterable() {\n    return this._parents;\n  }\n  removeParent(chunk) {\n    if (this._parents.delete(chunk)) {\n      chunk.removeChunk(this);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns {Array} - an array containing the blocks\n   */\n  getBlocks() {\n    return this._blocks.getFromCache(getArray);\n  }\n  getNumberOfBlocks() {\n    return this._blocks.size;\n  }\n  hasBlock(block) {\n    return this._blocks.has(block);\n  }\n  get blocksIterable() {\n    return this._blocks;\n  }\n  addBlock(block) {\n    if (!this._blocks.has(block)) {\n      this._blocks.add(block);\n      return true;\n    }\n    return false;\n  }\n  addOrigin(module, loc, request) {\n    this.origins.push({\n      module,\n      loc,\n      request\n    });\n  }\n  containsModule(module) {\n    for (const chunk of this.chunks) {\n      if (chunk.containsModule(module)) return true;\n    }\n    return false;\n  }\n  getFiles() {\n    const files = new Set();\n    for (const chunk of this.chunks) {\n      for (const file of chunk.files) {\n        files.add(file);\n      }\n    }\n    return Array.from(files);\n  }\n\n  /**\n   * @param {string=} reason reason for removing ChunkGroup\n   * @returns {void}\n   */\n  remove(reason) {\n    // cleanup parents\n    for (const parentChunkGroup of this._parents) {\n      // remove this chunk from its parents\n      parentChunkGroup._children.delete(this);\n\n      // cleanup \"sub chunks\"\n      for (const chunkGroup of this._children) {\n        /**\n         * remove this chunk as \"intermediary\" and connect\n         * it \"sub chunks\" and parents directly\n         */\n        // add parent to each \"sub chunk\"\n        chunkGroup.addParent(parentChunkGroup);\n        // add \"sub chunk\" to parent\n        parentChunkGroup.addChild(chunkGroup);\n      }\n    }\n\n    /**\n     * we need to iterate again over the children\n     * to remove this from the child's parents.\n     * This can not be done in the above loop\n     * as it is not guaranteed that `this._parents` contains anything.\n     */\n    for (const chunkGroup of this._children) {\n      // remove this as parent of every \"sub chunk\"\n      chunkGroup._parents.delete(this);\n    }\n\n    // cleanup blocks\n    for (const block of this._blocks) {\n      block.chunkGroup = null;\n    }\n\n    // remove chunks\n    for (const chunk of this.chunks) {\n      chunk.removeGroup(this);\n    }\n  }\n  sortItems() {\n    this.origins.sort(sortOrigin);\n    this._parents.sort();\n    this._children.sort();\n  }\n\n  /**\n   * Sorting predicate which allows current ChunkGroup to be compared against another.\n   * Sorting values are based off of number of chunks in ChunkGroup.\n   *\n   * @param {ChunkGroup} otherGroup the chunkGroup to compare this against\n   * @returns {-1|0|1} sort position for comparison\n   */\n  compareTo(otherGroup) {\n    if (this.chunks.length > otherGroup.chunks.length) return -1;\n    if (this.chunks.length < otherGroup.chunks.length) return 1;\n    const a = this.chunks[Symbol.iterator]();\n    const b = otherGroup.chunks[Symbol.iterator]();\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const aItem = a.next();\n      const bItem = b.next();\n      if (aItem.done) return 0;\n      const cmp = aItem.value.compareTo(bItem.value);\n      if (cmp !== 0) return cmp;\n    }\n  }\n  getChildrenByOrders() {\n    const lists = new Map();\n    for (const childGroup of this._children) {\n      // TODO webpack 5 remove this check for options\n      if (typeof childGroup.options === \"object\") {\n        for (const key of Object.keys(childGroup.options)) {\n          if (key.endsWith(\"Order\")) {\n            const name = key.substr(0, key.length - \"Order\".length);\n            let list = lists.get(name);\n            if (list === undefined) {\n              lists.set(name, list = []);\n            }\n            list.push({\n              order: childGroup.options[key],\n              group: childGroup\n            });\n          }\n        }\n      }\n    }\n    const result = Object.create(null);\n    for (const [name, list] of lists) {\n      list.sort((a, b) => {\n        const cmp = b.order - a.order;\n        if (cmp !== 0) return cmp;\n        // TODO webpack 5 remove this check of compareTo\n        if (a.group.compareTo) {\n          return a.group.compareTo(b.group);\n        }\n        return 0;\n      });\n      result[name] = list.map(i => i.group);\n    }\n    return result;\n  }\n\n  /**\n   * Sets the top-down index of a module in this ChunkGroup\n   * @param {Module} module module for which the index should be set\n   * @param {number} index the index of the module\n   * @returns {void}\n   */\n  setModuleIndex(module, index) {\n    this._moduleIndices.set(module, index);\n  }\n\n  /**\n   * Gets the top-down index of a module in this ChunkGroup\n   * @param {Module} module the module\n   * @returns {number} index\n   */\n  getModuleIndex(module) {\n    return this._moduleIndices.get(module);\n  }\n\n  /**\n   * Sets the bottom-up index of a module in this ChunkGroup\n   * @param {Module} module module for which the index should be set\n   * @param {number} index the index of the module\n   * @returns {void}\n   */\n  setModuleIndex2(module, index) {\n    this._moduleIndices2.set(module, index);\n  }\n\n  /**\n   * Gets the bottom-up index of a module in this ChunkGroup\n   * @param {Module} module the module\n   * @returns {number} index\n   */\n  getModuleIndex2(module) {\n    return this._moduleIndices2.get(module);\n  }\n  checkConstraints() {\n    const chunk = this;\n    for (const child of chunk._children) {\n      if (!child._parents.has(chunk)) {\n        throw new Error(`checkConstraints: child missing parent ${chunk.debugId} -> ${child.debugId}`);\n      }\n    }\n    for (const parentChunk of chunk._parents) {\n      if (!parentChunk._children.has(chunk)) {\n        throw new Error(`checkConstraints: parent missing child ${parentChunk.debugId} <- ${chunk.debugId}`);\n      }\n    }\n  }\n}\nmodule.exports = ChunkGroup;","map":{"version":3,"names":["SortableSet","require","compareLocations","debugId","getArray","set","Array","from","sortById","a","b","id","sortOrigin","aIdent","module","identifier","bIdent","loc","ChunkGroup","constructor","options","name","undefined","groupDebugId","_children","_parents","_blocks","chunks","origins","_moduleIndices","Map","_moduleIndices2","addOptions","key","Object","keys","endsWith","Math","max","Error","value","x","join","unshiftChunk","chunk","oldIdx","indexOf","splice","unshift","insertChunk","before","idx","pushChunk","push","replaceChunk","oldChunk","newChunk","newIdx","removeChunk","isInitial","addChild","has","add","getChildren","getFromCache","getNumberOfChildren","size","childrenIterable","removeChild","delete","removeParent","addParent","parentChunk","getParents","setParents","newParents","clear","p","getNumberOfParents","hasParent","parent","parentsIterable","getBlocks","getNumberOfBlocks","hasBlock","block","blocksIterable","addBlock","addOrigin","request","containsModule","getFiles","files","Set","file","remove","reason","parentChunkGroup","chunkGroup","removeGroup","sortItems","sort","compareTo","otherGroup","length","Symbol","iterator","aItem","next","bItem","done","cmp","getChildrenByOrders","lists","childGroup","substr","list","get","order","group","result","create","map","i","setModuleIndex","index","getModuleIndex","setModuleIndex2","getModuleIndex2","checkConstraints","child","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/ChunkGroup.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst SortableSet = require(\"./util/SortableSet\");\nconst compareLocations = require(\"./compareLocations\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleReason\")} ModuleReason */\n\n/** @typedef {{module: Module, loc: TODO, request: string}} OriginRecord */\n/** @typedef {string|{name: string}} ChunkGroupOptions */\n\nlet debugId = 5000;\n\n/**\n * @template T\n * @param {SortableSet<T>} set set to convert to array.\n * @returns {T[]} the array format of existing set\n */\nconst getArray = set => Array.from(set);\n\n/**\n * A convenience method used to sort chunks based on their id's\n * @param {ChunkGroup} a first sorting comparator\n * @param {ChunkGroup} b second sorting comparator\n * @returns {1|0|-1} a sorting index to determine order\n */\nconst sortById = (a, b) => {\n\tif (a.id < b.id) return -1;\n\tif (b.id < a.id) return 1;\n\treturn 0;\n};\n\n/**\n * @param {OriginRecord} a the first comparator in sort\n * @param {OriginRecord} b the second comparator in sort\n * @returns {1|-1|0} returns sorting order as index\n */\nconst sortOrigin = (a, b) => {\n\tconst aIdent = a.module ? a.module.identifier() : \"\";\n\tconst bIdent = b.module ? b.module.identifier() : \"\";\n\tif (aIdent < bIdent) return -1;\n\tif (aIdent > bIdent) return 1;\n\treturn compareLocations(a.loc, b.loc);\n};\n\nclass ChunkGroup {\n\t/**\n\t * Creates an instance of ChunkGroup.\n\t * @param {ChunkGroupOptions=} options chunk group options passed to chunkGroup\n\t */\n\tconstructor(options) {\n\t\tif (typeof options === \"string\") {\n\t\t\toptions = { name: options };\n\t\t} else if (!options) {\n\t\t\toptions = { name: undefined };\n\t\t}\n\t\t/** @type {number} */\n\t\tthis.groupDebugId = debugId++;\n\t\tthis.options = options;\n\t\t/** @type {SortableSet<ChunkGroup>} */\n\t\tthis._children = new SortableSet(undefined, sortById);\n\t\tthis._parents = new SortableSet(undefined, sortById);\n\t\tthis._blocks = new SortableSet();\n\t\t/** @type {Chunk[]} */\n\t\tthis.chunks = [];\n\t\t/** @type {OriginRecord[]} */\n\t\tthis.origins = [];\n\t\t/** Indices in top-down order */\n\t\t/** @private @type {Map<Module, number>} */\n\t\tthis._moduleIndices = new Map();\n\t\t/** Indices in bottom-up order */\n\t\t/** @private @type {Map<Module, number>} */\n\t\tthis._moduleIndices2 = new Map();\n\t}\n\n\t/**\n\t * when a new chunk is added to a chunkGroup, addingOptions will occur.\n\t * @param {ChunkGroupOptions} options the chunkGroup options passed to addOptions\n\t * @returns {void}\n\t */\n\taddOptions(options) {\n\t\tfor (const key of Object.keys(options)) {\n\t\t\tif (this.options[key] === undefined) {\n\t\t\t\tthis.options[key] = options[key];\n\t\t\t} else if (this.options[key] !== options[key]) {\n\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\tthis.options[key] = Math.max(this.options[key], options[key]);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`ChunkGroup.addOptions: No option merge strategy for ${key}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * returns the name of current ChunkGroup\n\t * @returns {string|undefined} returns the ChunkGroup name\n\t */\n\tget name() {\n\t\treturn this.options.name;\n\t}\n\n\t/**\n\t * sets a new name for current ChunkGroup\n\t * @param {string} value the new name for ChunkGroup\n\t * @returns {void}\n\t */\n\tset name(value) {\n\t\tthis.options.name = value;\n\t}\n\n\t/**\n\t * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's\n\t * @returns {string} a unique concatenation of chunk debugId's\n\t */\n\tget debugId() {\n\t\treturn Array.from(this.chunks, x => x.debugId).join(\"+\");\n\t}\n\n\t/**\n\t * get a unique id for ChunkGroup, made up of its member Chunk id's\n\t * @returns {string} a unique concatenation of chunk ids\n\t */\n\tget id() {\n\t\treturn Array.from(this.chunks, x => x.id).join(\"+\");\n\t}\n\n\t/**\n\t * Performs an unshift of a specific chunk\n\t * @param {Chunk} chunk chunk being unshifted\n\t * @returns {boolean} returns true if attempted chunk shift is accepted\n\t */\n\tunshiftChunk(chunk) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tif (oldIdx > 0) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\tthis.chunks.unshift(chunk);\n\t\t} else if (oldIdx < 0) {\n\t\t\tthis.chunks.unshift(chunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * inserts a chunk before another existing chunk in group\n\t * @param {Chunk} chunk Chunk being inserted\n\t * @param {Chunk} before Placeholder/target chunk marking new chunk insertion point\n\t * @returns {boolean} return true if insertion was successful\n\t */\n\tinsertChunk(chunk, before) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tconst idx = this.chunks.indexOf(before);\n\t\tif (idx < 0) {\n\t\t\tthrow new Error(\"before chunk not found\");\n\t\t}\n\t\tif (oldIdx >= 0 && oldIdx > idx) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\tthis.chunks.splice(idx, 0, chunk);\n\t\t} else if (oldIdx < 0) {\n\t\t\tthis.chunks.splice(idx, 0, chunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * add a chunk into ChunkGroup. Is pushed on or prepended\n\t * @param {Chunk} chunk chunk being pushed into ChunkGroupS\n\t * @returns {boolean} returns true if chunk addition was successful.\n\t */\n\tpushChunk(chunk) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tif (oldIdx >= 0) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.chunks.push(chunk);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Chunk} oldChunk chunk to be replaced\n\t * @param {Chunk} newChunk New chunk that will be replaced with\n\t * @returns {boolean} returns true if the replacement was successful\n\t */\n\treplaceChunk(oldChunk, newChunk) {\n\t\tconst oldIdx = this.chunks.indexOf(oldChunk);\n\t\tif (oldIdx < 0) return false;\n\t\tconst newIdx = this.chunks.indexOf(newChunk);\n\t\tif (newIdx < 0) {\n\t\t\tthis.chunks[oldIdx] = newChunk;\n\t\t\treturn true;\n\t\t}\n\t\tif (newIdx < oldIdx) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\treturn true;\n\t\t} else if (newIdx !== oldIdx) {\n\t\t\tthis.chunks[oldIdx] = newChunk;\n\t\t\tthis.chunks.splice(newIdx, 1);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tremoveChunk(chunk) {\n\t\tconst idx = this.chunks.indexOf(chunk);\n\t\tif (idx >= 0) {\n\t\t\tthis.chunks.splice(idx, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tisInitial() {\n\t\treturn false;\n\t}\n\n\taddChild(chunk) {\n\t\tif (this._children.has(chunk)) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._children.add(chunk);\n\t\treturn true;\n\t}\n\n\tgetChildren() {\n\t\treturn this._children.getFromCache(getArray);\n\t}\n\n\tgetNumberOfChildren() {\n\t\treturn this._children.size;\n\t}\n\n\tget childrenIterable() {\n\t\treturn this._children;\n\t}\n\n\tremoveChild(chunk) {\n\t\tif (!this._children.has(chunk)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._children.delete(chunk);\n\t\tchunk.removeParent(this);\n\t\treturn true;\n\t}\n\n\taddParent(parentChunk) {\n\t\tif (!this._parents.has(parentChunk)) {\n\t\t\tthis._parents.add(parentChunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tgetParents() {\n\t\treturn this._parents.getFromCache(getArray);\n\t}\n\n\tsetParents(newParents) {\n\t\tthis._parents.clear();\n\t\tfor (const p of newParents) {\n\t\t\tthis._parents.add(p);\n\t\t}\n\t}\n\n\tgetNumberOfParents() {\n\t\treturn this._parents.size;\n\t}\n\n\thasParent(parent) {\n\t\treturn this._parents.has(parent);\n\t}\n\n\tget parentsIterable() {\n\t\treturn this._parents;\n\t}\n\n\tremoveParent(chunk) {\n\t\tif (this._parents.delete(chunk)) {\n\t\t\tchunk.removeChunk(this);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {Array} - an array containing the blocks\n\t */\n\tgetBlocks() {\n\t\treturn this._blocks.getFromCache(getArray);\n\t}\n\n\tgetNumberOfBlocks() {\n\t\treturn this._blocks.size;\n\t}\n\n\thasBlock(block) {\n\t\treturn this._blocks.has(block);\n\t}\n\n\tget blocksIterable() {\n\t\treturn this._blocks;\n\t}\n\n\taddBlock(block) {\n\t\tif (!this._blocks.has(block)) {\n\t\t\tthis._blocks.add(block);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\taddOrigin(module, loc, request) {\n\t\tthis.origins.push({\n\t\t\tmodule,\n\t\t\tloc,\n\t\t\trequest\n\t\t});\n\t}\n\n\tcontainsModule(module) {\n\t\tfor (const chunk of this.chunks) {\n\t\t\tif (chunk.containsModule(module)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tgetFiles() {\n\t\tconst files = new Set();\n\n\t\tfor (const chunk of this.chunks) {\n\t\t\tfor (const file of chunk.files) {\n\t\t\t\tfiles.add(file);\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(files);\n\t}\n\n\t/**\n\t * @param {string=} reason reason for removing ChunkGroup\n\t * @returns {void}\n\t */\n\tremove(reason) {\n\t\t// cleanup parents\n\t\tfor (const parentChunkGroup of this._parents) {\n\t\t\t// remove this chunk from its parents\n\t\t\tparentChunkGroup._children.delete(this);\n\n\t\t\t// cleanup \"sub chunks\"\n\t\t\tfor (const chunkGroup of this._children) {\n\t\t\t\t/**\n\t\t\t\t * remove this chunk as \"intermediary\" and connect\n\t\t\t\t * it \"sub chunks\" and parents directly\n\t\t\t\t */\n\t\t\t\t// add parent to each \"sub chunk\"\n\t\t\t\tchunkGroup.addParent(parentChunkGroup);\n\t\t\t\t// add \"sub chunk\" to parent\n\t\t\t\tparentChunkGroup.addChild(chunkGroup);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * we need to iterate again over the children\n\t\t * to remove this from the child's parents.\n\t\t * This can not be done in the above loop\n\t\t * as it is not guaranteed that `this._parents` contains anything.\n\t\t */\n\t\tfor (const chunkGroup of this._children) {\n\t\t\t// remove this as parent of every \"sub chunk\"\n\t\t\tchunkGroup._parents.delete(this);\n\t\t}\n\n\t\t// cleanup blocks\n\t\tfor (const block of this._blocks) {\n\t\t\tblock.chunkGroup = null;\n\t\t}\n\n\t\t// remove chunks\n\t\tfor (const chunk of this.chunks) {\n\t\t\tchunk.removeGroup(this);\n\t\t}\n\t}\n\n\tsortItems() {\n\t\tthis.origins.sort(sortOrigin);\n\t\tthis._parents.sort();\n\t\tthis._children.sort();\n\t}\n\n\t/**\n\t * Sorting predicate which allows current ChunkGroup to be compared against another.\n\t * Sorting values are based off of number of chunks in ChunkGroup.\n\t *\n\t * @param {ChunkGroup} otherGroup the chunkGroup to compare this against\n\t * @returns {-1|0|1} sort position for comparison\n\t */\n\tcompareTo(otherGroup) {\n\t\tif (this.chunks.length > otherGroup.chunks.length) return -1;\n\t\tif (this.chunks.length < otherGroup.chunks.length) return 1;\n\t\tconst a = this.chunks[Symbol.iterator]();\n\t\tconst b = otherGroup.chunks[Symbol.iterator]();\n\t\t// eslint-disable-next-line no-constant-condition\n\t\twhile (true) {\n\t\t\tconst aItem = a.next();\n\t\t\tconst bItem = b.next();\n\t\t\tif (aItem.done) return 0;\n\t\t\tconst cmp = aItem.value.compareTo(bItem.value);\n\t\t\tif (cmp !== 0) return cmp;\n\t\t}\n\t}\n\n\tgetChildrenByOrders() {\n\t\tconst lists = new Map();\n\t\tfor (const childGroup of this._children) {\n\t\t\t// TODO webpack 5 remove this check for options\n\t\t\tif (typeof childGroup.options === \"object\") {\n\t\t\t\tfor (const key of Object.keys(childGroup.options)) {\n\t\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\t\tconst name = key.substr(0, key.length - \"Order\".length);\n\t\t\t\t\t\tlet list = lists.get(name);\n\t\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\t\tlists.set(name, (list = []));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.push({\n\t\t\t\t\t\t\torder: childGroup.options[key],\n\t\t\t\t\t\t\tgroup: childGroup\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst result = Object.create(null);\n\t\tfor (const [name, list] of lists) {\n\t\t\tlist.sort((a, b) => {\n\t\t\t\tconst cmp = b.order - a.order;\n\t\t\t\tif (cmp !== 0) return cmp;\n\t\t\t\t// TODO webpack 5 remove this check of compareTo\n\t\t\t\tif (a.group.compareTo) {\n\t\t\t\t\treturn a.group.compareTo(b.group);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t\tresult[name] = list.map(i => i.group);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Sets the top-down index of a module in this ChunkGroup\n\t * @param {Module} module module for which the index should be set\n\t * @param {number} index the index of the module\n\t * @returns {void}\n\t */\n\tsetModuleIndex(module, index) {\n\t\tthis._moduleIndices.set(module, index);\n\t}\n\n\t/**\n\t * Gets the top-down index of a module in this ChunkGroup\n\t * @param {Module} module the module\n\t * @returns {number} index\n\t */\n\tgetModuleIndex(module) {\n\t\treturn this._moduleIndices.get(module);\n\t}\n\n\t/**\n\t * Sets the bottom-up index of a module in this ChunkGroup\n\t * @param {Module} module module for which the index should be set\n\t * @param {number} index the index of the module\n\t * @returns {void}\n\t */\n\tsetModuleIndex2(module, index) {\n\t\tthis._moduleIndices2.set(module, index);\n\t}\n\n\t/**\n\t * Gets the bottom-up index of a module in this ChunkGroup\n\t * @param {Module} module the module\n\t * @returns {number} index\n\t */\n\tgetModuleIndex2(module) {\n\t\treturn this._moduleIndices2.get(module);\n\t}\n\n\tcheckConstraints() {\n\t\tconst chunk = this;\n\t\tfor (const child of chunk._children) {\n\t\t\tif (!child._parents.has(chunk)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`checkConstraints: child missing parent ${chunk.debugId} -> ${child.debugId}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tfor (const parentChunk of chunk._parents) {\n\t\t\tif (!parentChunk._children.has(chunk)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`checkConstraints: parent missing child ${parentChunk.debugId} <- ${chunk.debugId}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = ChunkGroup;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}