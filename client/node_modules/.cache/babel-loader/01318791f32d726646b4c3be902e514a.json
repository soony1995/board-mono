{"ast":null,"code":"'use strict';\n\nconst pLimit = require('p-limit');\nclass EndError extends Error {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n}\n\n// The input can also be a promise, so we `Promise.resolve()` it\nconst testElement = (el, tester) => Promise.resolve(el).then(tester);\n\n// The input can also be a promise, so we `Promise.all()` them both\nconst finder = el => Promise.all(el).then(val => val[1] === true && Promise.reject(new EndError(val[0])));\nmodule.exports = (iterable, tester, opts) => {\n  opts = Object.assign({\n    concurrency: Infinity,\n    preserveOrder: true\n  }, opts);\n  const limit = pLimit(opts.concurrency);\n\n  // Start all the promises concurrently with optional limit\n  const items = [...iterable].map(el => [el, limit(testElement, el, tester)]);\n\n  // Check the promises either serially or concurrently\n  const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);\n  return Promise.all(items.map(el => checkLimit(finder, el))).then(() => {}).catch(err => err instanceof EndError ? err.value : Promise.reject(err));\n};","map":{"version":3,"names":["pLimit","require","EndError","Error","constructor","value","testElement","el","tester","Promise","resolve","then","finder","all","val","reject","module","exports","iterable","opts","Object","assign","concurrency","Infinity","preserveOrder","limit","items","map","checkLimit","catch","err"],"sources":["/home/soon/bulletin-board/node_modules/p-locate/index.js"],"sourcesContent":["'use strict';\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.value = value;\n\t}\n}\n\n// The input can also be a promise, so we `Promise.resolve()` it\nconst testElement = (el, tester) => Promise.resolve(el).then(tester);\n\n// The input can also be a promise, so we `Promise.all()` them both\nconst finder = el => Promise.all(el).then(val => val[1] === true && Promise.reject(new EndError(val[0])));\n\nmodule.exports = (iterable, tester, opts) => {\n\topts = Object.assign({\n\t\tconcurrency: Infinity,\n\t\tpreserveOrder: true\n\t}, opts);\n\n\tconst limit = pLimit(opts.concurrency);\n\n\t// Start all the promises concurrently with optional limit\n\tconst items = [...iterable].map(el => [el, limit(testElement, el, tester)]);\n\n\t// Check the promises either serially or concurrently\n\tconst checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);\n\n\treturn Promise.all(items.map(el => checkLimit(finder, el)))\n\t\t.then(() => {})\n\t\t.catch(err => err instanceof EndError ? err.value : Promise.reject(err));\n};\n"],"mappings":"AAAA,YAAY;;AACZ,MAAMA,MAAM,GAAGC,OAAO,CAAC,SAAS,CAAC;AAEjC,MAAMC,QAAQ,SAASC,KAAK,CAAC;EAC5BC,WAAWA,CAACC,KAAK,EAAE;IAClB,KAAK,CAAC,CAAC;IACP,IAAI,CAACA,KAAK,GAAGA,KAAK;EACnB;AACD;;AAEA;AACA,MAAMC,WAAW,GAAGA,CAACC,EAAE,EAAEC,MAAM,KAAKC,OAAO,CAACC,OAAO,CAACH,EAAE,CAAC,CAACI,IAAI,CAACH,MAAM,CAAC;;AAEpE;AACA,MAAMI,MAAM,GAAGL,EAAE,IAAIE,OAAO,CAACI,GAAG,CAACN,EAAE,CAAC,CAACI,IAAI,CAACG,GAAG,IAAIA,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIL,OAAO,CAACM,MAAM,CAAC,IAAIb,QAAQ,CAACY,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAEzGE,MAAM,CAACC,OAAO,GAAG,CAACC,QAAQ,EAAEV,MAAM,EAAEW,IAAI,KAAK;EAC5CA,IAAI,GAAGC,MAAM,CAACC,MAAM,CAAC;IACpBC,WAAW,EAAEC,QAAQ;IACrBC,aAAa,EAAE;EAChB,CAAC,EAAEL,IAAI,CAAC;EAER,MAAMM,KAAK,GAAGzB,MAAM,CAACmB,IAAI,CAACG,WAAW,CAAC;;EAEtC;EACA,MAAMI,KAAK,GAAG,CAAC,GAAGR,QAAQ,CAAC,CAACS,GAAG,CAACpB,EAAE,IAAI,CAACA,EAAE,EAAEkB,KAAK,CAACnB,WAAW,EAAEC,EAAE,EAAEC,MAAM,CAAC,CAAC,CAAC;;EAE3E;EACA,MAAMoB,UAAU,GAAG5B,MAAM,CAACmB,IAAI,CAACK,aAAa,GAAG,CAAC,GAAGD,QAAQ,CAAC;EAE5D,OAAOd,OAAO,CAACI,GAAG,CAACa,KAAK,CAACC,GAAG,CAACpB,EAAE,IAAIqB,UAAU,CAAChB,MAAM,EAAEL,EAAE,CAAC,CAAC,CAAC,CACzDI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CACdkB,KAAK,CAACC,GAAG,IAAIA,GAAG,YAAY5B,QAAQ,GAAG4B,GAAG,CAACzB,KAAK,GAAGI,OAAO,CAACM,MAAM,CAACe,GAAG,CAAC,CAAC;AAC1E,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script"}