{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Jason Anderson @diurnalist\n*/\n\"use strict\";\n\nconst REGEXP_HASH = /\\[hash(?::(\\d+))?\\]/gi,\n  REGEXP_CHUNKHASH = /\\[chunkhash(?::(\\d+))?\\]/gi,\n  REGEXP_MODULEHASH = /\\[modulehash(?::(\\d+))?\\]/gi,\n  REGEXP_CONTENTHASH = /\\[contenthash(?::(\\d+))?\\]/gi,\n  REGEXP_NAME = /\\[name\\]/gi,\n  REGEXP_ID = /\\[id\\]/gi,\n  REGEXP_MODULEID = /\\[moduleid\\]/gi,\n  REGEXP_FILE = /\\[file\\]/gi,\n  REGEXP_QUERY = /\\[query\\]/gi,\n  REGEXP_FILEBASE = /\\[filebase\\]/gi,\n  REGEXP_URL = /\\[url\\]/gi;\n\n// Using global RegExp for .test is dangerous\n// We use a normal RegExp instead of .test\nconst REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, \"i\"),\n  REGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, \"i\"),\n  REGEXP_CONTENTHASH_FOR_TEST = new RegExp(REGEXP_CONTENTHASH.source, \"i\"),\n  REGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, \"i\");\nconst withHashLength = (replacer, handlerFn, assetInfo) => {\n  const fn = (match, hashLength, ...args) => {\n    if (assetInfo) assetInfo.immutable = true;\n    const length = hashLength && parseInt(hashLength, 10);\n    if (length && handlerFn) {\n      return handlerFn(length);\n    }\n    const hash = replacer(match, hashLength, ...args);\n    return length ? hash.slice(0, length) : hash;\n  };\n  return fn;\n};\nconst getReplacer = (value, allowEmpty) => {\n  const fn = (match, ...args) => {\n    // last argument in replacer is the entire input string\n    const input = args[args.length - 1];\n    if (value === null || value === undefined) {\n      if (!allowEmpty) {\n        throw new Error(`Path variable ${match} not implemented in this context: ${input}`);\n      }\n      return \"\";\n    } else {\n      return `${escapePathVariables(value)}`;\n    }\n  };\n  return fn;\n};\nconst escapePathVariables = value => {\n  return typeof value === \"string\" ? value.replace(/\\[(\\\\*[\\w:]+\\\\*)\\]/gi, \"[\\\\$1\\\\]\") : value;\n};\nconst replacePathVariables = (path, data, assetInfo) => {\n  const chunk = data.chunk;\n  const chunkId = chunk && chunk.id;\n  const chunkName = chunk && (chunk.name || chunk.id);\n  const chunkHash = chunk && (chunk.renderedHash || chunk.hash);\n  const chunkHashWithLength = chunk && chunk.hashWithLength;\n  const contentHashType = data.contentHashType;\n  const contentHash = chunk && chunk.contentHash && chunk.contentHash[contentHashType] || data.contentHash;\n  const contentHashWithLength = chunk && chunk.contentHashWithLength && chunk.contentHashWithLength[contentHashType] || data.contentHashWithLength;\n  const module = data.module;\n  const moduleId = module && module.id;\n  const moduleHash = module && (module.renderedHash || module.hash);\n  const moduleHashWithLength = module && module.hashWithLength;\n  if (typeof path === \"function\") {\n    path = path(data);\n  }\n  if (data.noChunkHash && (REGEXP_CHUNKHASH_FOR_TEST.test(path) || REGEXP_CONTENTHASH_FOR_TEST.test(path))) {\n    throw new Error(`Cannot use [chunkhash] or [contenthash] for chunk in '${path}' (use [hash] instead)`);\n  }\n  return path.replace(REGEXP_HASH, withHashLength(getReplacer(data.hash), data.hashWithLength, assetInfo)).replace(REGEXP_CHUNKHASH, withHashLength(getReplacer(chunkHash), chunkHashWithLength, assetInfo)).replace(REGEXP_CONTENTHASH, withHashLength(getReplacer(contentHash), contentHashWithLength, assetInfo)).replace(REGEXP_MODULEHASH, withHashLength(getReplacer(moduleHash), moduleHashWithLength, assetInfo)).replace(REGEXP_ID, getReplacer(chunkId)).replace(REGEXP_MODULEID, getReplacer(moduleId)).replace(REGEXP_NAME, getReplacer(chunkName)).replace(REGEXP_FILE, getReplacer(data.filename)).replace(REGEXP_FILEBASE, getReplacer(data.basename))\n  // query is optional, it's OK if it's in a path but there's nothing to replace it with\n  .replace(REGEXP_QUERY, getReplacer(data.query, true))\n  // only available in sourceMappingURLComment\n  .replace(REGEXP_URL, getReplacer(data.url)).replace(/\\[\\\\(\\\\*[\\w:]+\\\\*)\\\\\\]/gi, \"[$1]\");\n};\nclass TemplatedPathPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"TemplatedPathPlugin\", compilation => {\n      const mainTemplate = compilation.mainTemplate;\n      mainTemplate.hooks.assetPath.tap(\"TemplatedPathPlugin\", replacePathVariables);\n      mainTemplate.hooks.globalHash.tap(\"TemplatedPathPlugin\", (chunk, paths) => {\n        const outputOptions = mainTemplate.outputOptions;\n        const publicPath = outputOptions.publicPath || \"\";\n        const filename = outputOptions.filename || \"\";\n        const chunkFilename = outputOptions.chunkFilename || outputOptions.filename;\n        if (REGEXP_HASH_FOR_TEST.test(publicPath) || REGEXP_CHUNKHASH_FOR_TEST.test(publicPath) || REGEXP_CONTENTHASH_FOR_TEST.test(publicPath) || REGEXP_NAME_FOR_TEST.test(publicPath)) return true;\n        if (REGEXP_HASH_FOR_TEST.test(filename)) return true;\n        if (REGEXP_HASH_FOR_TEST.test(chunkFilename)) return true;\n        if (REGEXP_HASH_FOR_TEST.test(paths.join(\"|\"))) return true;\n      });\n      mainTemplate.hooks.hashForChunk.tap(\"TemplatedPathPlugin\", (hash, chunk) => {\n        const outputOptions = mainTemplate.outputOptions;\n        const chunkFilename = outputOptions.chunkFilename || outputOptions.filename;\n        if (REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));\n        }\n        if (REGEXP_CONTENTHASH_FOR_TEST.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).contentHash.javascript || {}));\n        }\n        if (REGEXP_NAME_FOR_TEST.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).name));\n        }\n      });\n    });\n  }\n}\nmodule.exports = TemplatedPathPlugin;","map":{"version":3,"names":["REGEXP_HASH","REGEXP_CHUNKHASH","REGEXP_MODULEHASH","REGEXP_CONTENTHASH","REGEXP_NAME","REGEXP_ID","REGEXP_MODULEID","REGEXP_FILE","REGEXP_QUERY","REGEXP_FILEBASE","REGEXP_URL","REGEXP_HASH_FOR_TEST","RegExp","source","REGEXP_CHUNKHASH_FOR_TEST","REGEXP_CONTENTHASH_FOR_TEST","REGEXP_NAME_FOR_TEST","withHashLength","replacer","handlerFn","assetInfo","fn","match","hashLength","args","immutable","length","parseInt","hash","slice","getReplacer","value","allowEmpty","input","undefined","Error","escapePathVariables","replace","replacePathVariables","path","data","chunk","chunkId","id","chunkName","name","chunkHash","renderedHash","chunkHashWithLength","hashWithLength","contentHashType","contentHash","contentHashWithLength","module","moduleId","moduleHash","moduleHashWithLength","noChunkHash","test","filename","basename","query","url","TemplatedPathPlugin","apply","compiler","hooks","compilation","tap","mainTemplate","assetPath","globalHash","paths","outputOptions","publicPath","chunkFilename","join","hashForChunk","update","JSON","stringify","getChunkMaps","javascript","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/TemplatedPathPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Jason Anderson @diurnalist\n*/\n\"use strict\";\n\nconst REGEXP_HASH = /\\[hash(?::(\\d+))?\\]/gi,\n\tREGEXP_CHUNKHASH = /\\[chunkhash(?::(\\d+))?\\]/gi,\n\tREGEXP_MODULEHASH = /\\[modulehash(?::(\\d+))?\\]/gi,\n\tREGEXP_CONTENTHASH = /\\[contenthash(?::(\\d+))?\\]/gi,\n\tREGEXP_NAME = /\\[name\\]/gi,\n\tREGEXP_ID = /\\[id\\]/gi,\n\tREGEXP_MODULEID = /\\[moduleid\\]/gi,\n\tREGEXP_FILE = /\\[file\\]/gi,\n\tREGEXP_QUERY = /\\[query\\]/gi,\n\tREGEXP_FILEBASE = /\\[filebase\\]/gi,\n\tREGEXP_URL = /\\[url\\]/gi;\n\n// Using global RegExp for .test is dangerous\n// We use a normal RegExp instead of .test\nconst REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, \"i\"),\n\tREGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, \"i\"),\n\tREGEXP_CONTENTHASH_FOR_TEST = new RegExp(REGEXP_CONTENTHASH.source, \"i\"),\n\tREGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, \"i\");\n\nconst withHashLength = (replacer, handlerFn, assetInfo) => {\n\tconst fn = (match, hashLength, ...args) => {\n\t\tif (assetInfo) assetInfo.immutable = true;\n\t\tconst length = hashLength && parseInt(hashLength, 10);\n\t\tif (length && handlerFn) {\n\t\t\treturn handlerFn(length);\n\t\t}\n\t\tconst hash = replacer(match, hashLength, ...args);\n\t\treturn length ? hash.slice(0, length) : hash;\n\t};\n\treturn fn;\n};\n\nconst getReplacer = (value, allowEmpty) => {\n\tconst fn = (match, ...args) => {\n\t\t// last argument in replacer is the entire input string\n\t\tconst input = args[args.length - 1];\n\t\tif (value === null || value === undefined) {\n\t\t\tif (!allowEmpty) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Path variable ${match} not implemented in this context: ${input}`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn `${escapePathVariables(value)}`;\n\t\t}\n\t};\n\treturn fn;\n};\n\nconst escapePathVariables = value => {\n\treturn typeof value === \"string\"\n\t\t? value.replace(/\\[(\\\\*[\\w:]+\\\\*)\\]/gi, \"[\\\\$1\\\\]\")\n\t\t: value;\n};\n\nconst replacePathVariables = (path, data, assetInfo) => {\n\tconst chunk = data.chunk;\n\tconst chunkId = chunk && chunk.id;\n\tconst chunkName = chunk && (chunk.name || chunk.id);\n\tconst chunkHash = chunk && (chunk.renderedHash || chunk.hash);\n\tconst chunkHashWithLength = chunk && chunk.hashWithLength;\n\tconst contentHashType = data.contentHashType;\n\tconst contentHash =\n\t\t(chunk && chunk.contentHash && chunk.contentHash[contentHashType]) ||\n\t\tdata.contentHash;\n\tconst contentHashWithLength =\n\t\t(chunk &&\n\t\t\tchunk.contentHashWithLength &&\n\t\t\tchunk.contentHashWithLength[contentHashType]) ||\n\t\tdata.contentHashWithLength;\n\tconst module = data.module;\n\tconst moduleId = module && module.id;\n\tconst moduleHash = module && (module.renderedHash || module.hash);\n\tconst moduleHashWithLength = module && module.hashWithLength;\n\n\tif (typeof path === \"function\") {\n\t\tpath = path(data);\n\t}\n\n\tif (\n\t\tdata.noChunkHash &&\n\t\t(REGEXP_CHUNKHASH_FOR_TEST.test(path) ||\n\t\t\tREGEXP_CONTENTHASH_FOR_TEST.test(path))\n\t) {\n\t\tthrow new Error(\n\t\t\t`Cannot use [chunkhash] or [contenthash] for chunk in '${path}' (use [hash] instead)`\n\t\t);\n\t}\n\n\treturn (\n\t\tpath\n\t\t\t.replace(\n\t\t\t\tREGEXP_HASH,\n\t\t\t\twithHashLength(getReplacer(data.hash), data.hashWithLength, assetInfo)\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\tREGEXP_CHUNKHASH,\n\t\t\t\twithHashLength(getReplacer(chunkHash), chunkHashWithLength, assetInfo)\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\tREGEXP_CONTENTHASH,\n\t\t\t\twithHashLength(\n\t\t\t\t\tgetReplacer(contentHash),\n\t\t\t\t\tcontentHashWithLength,\n\t\t\t\t\tassetInfo\n\t\t\t\t)\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\tREGEXP_MODULEHASH,\n\t\t\t\twithHashLength(getReplacer(moduleHash), moduleHashWithLength, assetInfo)\n\t\t\t)\n\t\t\t.replace(REGEXP_ID, getReplacer(chunkId))\n\t\t\t.replace(REGEXP_MODULEID, getReplacer(moduleId))\n\t\t\t.replace(REGEXP_NAME, getReplacer(chunkName))\n\t\t\t.replace(REGEXP_FILE, getReplacer(data.filename))\n\t\t\t.replace(REGEXP_FILEBASE, getReplacer(data.basename))\n\t\t\t// query is optional, it's OK if it's in a path but there's nothing to replace it with\n\t\t\t.replace(REGEXP_QUERY, getReplacer(data.query, true))\n\t\t\t// only available in sourceMappingURLComment\n\t\t\t.replace(REGEXP_URL, getReplacer(data.url))\n\t\t\t.replace(/\\[\\\\(\\\\*[\\w:]+\\\\*)\\\\\\]/gi, \"[$1]\")\n\t);\n};\n\nclass TemplatedPathPlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"TemplatedPathPlugin\", compilation => {\n\t\t\tconst mainTemplate = compilation.mainTemplate;\n\n\t\t\tmainTemplate.hooks.assetPath.tap(\n\t\t\t\t\"TemplatedPathPlugin\",\n\t\t\t\treplacePathVariables\n\t\t\t);\n\n\t\t\tmainTemplate.hooks.globalHash.tap(\n\t\t\t\t\"TemplatedPathPlugin\",\n\t\t\t\t(chunk, paths) => {\n\t\t\t\t\tconst outputOptions = mainTemplate.outputOptions;\n\t\t\t\t\tconst publicPath = outputOptions.publicPath || \"\";\n\t\t\t\t\tconst filename = outputOptions.filename || \"\";\n\t\t\t\t\tconst chunkFilename =\n\t\t\t\t\t\toutputOptions.chunkFilename || outputOptions.filename;\n\t\t\t\t\tif (\n\t\t\t\t\t\tREGEXP_HASH_FOR_TEST.test(publicPath) ||\n\t\t\t\t\t\tREGEXP_CHUNKHASH_FOR_TEST.test(publicPath) ||\n\t\t\t\t\t\tREGEXP_CONTENTHASH_FOR_TEST.test(publicPath) ||\n\t\t\t\t\t\tREGEXP_NAME_FOR_TEST.test(publicPath)\n\t\t\t\t\t)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif (REGEXP_HASH_FOR_TEST.test(filename)) return true;\n\t\t\t\t\tif (REGEXP_HASH_FOR_TEST.test(chunkFilename)) return true;\n\t\t\t\t\tif (REGEXP_HASH_FOR_TEST.test(paths.join(\"|\"))) return true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tmainTemplate.hooks.hashForChunk.tap(\n\t\t\t\t\"TemplatedPathPlugin\",\n\t\t\t\t(hash, chunk) => {\n\t\t\t\t\tconst outputOptions = mainTemplate.outputOptions;\n\t\t\t\t\tconst chunkFilename =\n\t\t\t\t\t\toutputOptions.chunkFilename || outputOptions.filename;\n\t\t\t\t\tif (REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename)) {\n\t\t\t\t\t\thash.update(JSON.stringify(chunk.getChunkMaps(true).hash));\n\t\t\t\t\t}\n\t\t\t\t\tif (REGEXP_CONTENTHASH_FOR_TEST.test(chunkFilename)) {\n\t\t\t\t\t\thash.update(\n\t\t\t\t\t\t\tJSON.stringify(\n\t\t\t\t\t\t\t\tchunk.getChunkMaps(true).contentHash.javascript || {}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (REGEXP_NAME_FOR_TEST.test(chunkFilename)) {\n\t\t\t\t\t\thash.update(JSON.stringify(chunk.getChunkMaps(true).name));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = TemplatedPathPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}