{"ast":null,"code":"\"use strict\";\n\n// Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\nconst similarity = (a, b) => {\n  const l = Math.min(a.length, b.length);\n  let dist = 0;\n  for (let i = 0; i < l; i++) {\n    const ca = a.charCodeAt(i);\n    const cb = b.charCodeAt(i);\n    dist += Math.max(0, 10 - Math.abs(ca - cb));\n  }\n  return dist;\n};\n\n/**\n * @param {string} a key\n * @param {string} b key\n * @returns {string} the common part and a single char for the difference\n */\nconst getName = (a, b) => {\n  const l = Math.min(a.length, b.length);\n  let r = \"\";\n  for (let i = 0; i < l; i++) {\n    const ca = a.charAt(i);\n    const cb = b.charAt(i);\n    r += ca;\n    if (ca === cb) {\n      continue;\n    }\n    return r;\n  }\n  return a;\n};\n\n/**\n * @template T\n */\nclass Node {\n  /**\n   * @param {T} item item\n   * @param {string} key key\n   * @param {number} size size\n   */\n  constructor(item, key, size) {\n    this.item = item;\n    this.key = key;\n    this.size = size;\n  }\n}\n\n/**\n * @template T\n */\nclass Group {\n  /**\n   * @param {Node<T>[]} nodes nodes\n   * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n   */\n  constructor(nodes, similarities) {\n    this.nodes = nodes;\n    this.similarities = similarities;\n    this.size = nodes.reduce((size, node) => size + node.size, 0);\n    /** @type {string} */\n    this.key = undefined;\n  }\n}\n\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {number} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {number} maxSize maximum size of a group\n * @property {number} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): number} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\nmodule.exports = ({\n  maxSize,\n  minSize,\n  items,\n  getSize,\n  getKey\n}) => {\n  /** @type {Group<T>[]} */\n  const result = [];\n  const nodes = Array.from(items, item => new Node(item, getKey(item), getSize(item)));\n\n  /** @type {Node<T>[]} */\n  const initialNodes = [];\n\n  // lexically ordering of keys\n  nodes.sort((a, b) => {\n    if (a.key < b.key) return -1;\n    if (a.key > b.key) return 1;\n    return 0;\n  });\n\n  // return nodes bigger than maxSize directly as group\n  for (const node of nodes) {\n    if (node.size >= maxSize) {\n      result.push(new Group([node], []));\n    } else {\n      initialNodes.push(node);\n    }\n  }\n  if (initialNodes.length > 0) {\n    // calculate similarities between lexically adjacent nodes\n    /** @type {number[]} */\n    const similarities = [];\n    for (let i = 1; i < initialNodes.length; i++) {\n      const a = initialNodes[i - 1];\n      const b = initialNodes[i];\n      similarities.push(similarity(a.key, b.key));\n    }\n    const initialGroup = new Group(initialNodes, similarities);\n    if (initialGroup.size < minSize) {\n      // We hit an edgecase where the working set is already smaller than minSize\n      // We merge it with the smallest result node to keep minSize intact\n      if (result.length > 0) {\n        const smallestGroup = result.reduce((min, group) => min.size > group.size ? group : min);\n        for (const node of initialGroup.nodes) smallestGroup.nodes.push(node);\n        smallestGroup.nodes.sort((a, b) => {\n          if (a.key < b.key) return -1;\n          if (a.key > b.key) return 1;\n          return 0;\n        });\n      } else {\n        // There are no other nodes\n        // We use all nodes and have to accept that it's smaller than minSize\n        result.push(initialGroup);\n      }\n    } else {\n      const queue = [initialGroup];\n      while (queue.length) {\n        const group = queue.pop();\n        // only groups bigger than maxSize need to be splitted\n        if (group.size < maxSize) {\n          result.push(group);\n          continue;\n        }\n\n        // find unsplittable area from left and right\n        // going minSize from left and right\n        // at least one node need to be included otherwise we get stuck\n        let left = 0;\n        let leftSize = 0;\n        while (leftSize <= minSize) {\n          leftSize += group.nodes[left].size;\n          left++;\n        }\n        let right = group.nodes.length - 1;\n        let rightSize = 0;\n        while (rightSize <= minSize) {\n          rightSize += group.nodes[right].size;\n          right--;\n        }\n        if (left - 1 > right) {\n          // can't split group while holding minSize\n          // because minSize is preferred of maxSize we return\n          // the group here even while it's too big\n          // To avoid this make sure maxSize > minSize * 3\n          result.push(group);\n          continue;\n        }\n        if (left <= right) {\n          // when there is a area between left and right\n          // we look for best split point\n          // we split at the minimum similarity\n          // here key space is separated the most\n          let best = left - 1;\n          let bestSimilarity = group.similarities[best];\n          for (let i = left; i <= right; i++) {\n            const similarity = group.similarities[i];\n            if (similarity < bestSimilarity) {\n              best = i;\n              bestSimilarity = similarity;\n            }\n          }\n          left = best + 1;\n          right = best;\n        }\n\n        // create two new groups for left and right area\n        // and queue them up\n        const rightNodes = [group.nodes[right + 1]];\n        /** @type {number[]} */\n        const rightSimilaries = [];\n        for (let i = right + 2; i < group.nodes.length; i++) {\n          rightSimilaries.push(group.similarities[i - 1]);\n          rightNodes.push(group.nodes[i]);\n        }\n        queue.push(new Group(rightNodes, rightSimilaries));\n        const leftNodes = [group.nodes[0]];\n        /** @type {number[]} */\n        const leftSimilaries = [];\n        for (let i = 1; i < left; i++) {\n          leftSimilaries.push(group.similarities[i - 1]);\n          leftNodes.push(group.nodes[i]);\n        }\n        queue.push(new Group(leftNodes, leftSimilaries));\n      }\n    }\n  }\n\n  // lexically ordering\n  result.sort((a, b) => {\n    if (a.nodes[0].key < b.nodes[0].key) return -1;\n    if (a.nodes[0].key > b.nodes[0].key) return 1;\n    return 0;\n  });\n\n  // give every group a name\n  for (let i = 0; i < result.length; i++) {\n    const group = result[i];\n    const first = group.nodes[0];\n    const last = group.nodes[group.nodes.length - 1];\n    let name = getName(first.key, last.key);\n    group.key = name;\n  }\n\n  // return the results\n  return result.map(group => {\n    /** @type {GroupedItems} */\n    return {\n      key: group.key,\n      items: group.nodes.map(node => node.item),\n      size: group.size\n    };\n  });\n};","map":{"version":3,"names":["similarity","a","b","l","Math","min","length","dist","i","ca","charCodeAt","cb","max","abs","getName","r","charAt","Node","constructor","item","key","size","Group","nodes","similarities","reduce","node","undefined","module","exports","maxSize","minSize","items","getSize","getKey","result","Array","from","initialNodes","sort","push","initialGroup","smallestGroup","group","queue","pop","left","leftSize","right","rightSize","best","bestSimilarity","rightNodes","rightSimilaries","leftNodes","leftSimilaries","first","last","name","map"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/util/deterministicGrouping.js"],"sourcesContent":["\"use strict\";\n\n// Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\nconst similarity = (a, b) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet dist = 0;\n\tfor (let i = 0; i < l; i++) {\n\t\tconst ca = a.charCodeAt(i);\n\t\tconst cb = b.charCodeAt(i);\n\t\tdist += Math.max(0, 10 - Math.abs(ca - cb));\n\t}\n\treturn dist;\n};\n\n/**\n * @param {string} a key\n * @param {string} b key\n * @returns {string} the common part and a single char for the difference\n */\nconst getName = (a, b) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet r = \"\";\n\tfor (let i = 0; i < l; i++) {\n\t\tconst ca = a.charAt(i);\n\t\tconst cb = b.charAt(i);\n\t\tr += ca;\n\t\tif (ca === cb) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn r;\n\t}\n\treturn a;\n};\n\n/**\n * @template T\n */\nclass Node {\n\t/**\n\t * @param {T} item item\n\t * @param {string} key key\n\t * @param {number} size size\n\t */\n\tconstructor(item, key, size) {\n\t\tthis.item = item;\n\t\tthis.key = key;\n\t\tthis.size = size;\n\t}\n}\n\n/**\n * @template T\n */\nclass Group {\n\t/**\n\t * @param {Node<T>[]} nodes nodes\n\t * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n\t */\n\tconstructor(nodes, similarities) {\n\t\tthis.nodes = nodes;\n\t\tthis.similarities = similarities;\n\t\tthis.size = nodes.reduce((size, node) => size + node.size, 0);\n\t\t/** @type {string} */\n\t\tthis.key = undefined;\n\t}\n}\n\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {number} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {number} maxSize maximum size of a group\n * @property {number} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): number} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\nmodule.exports = ({ maxSize, minSize, items, getSize, getKey }) => {\n\t/** @type {Group<T>[]} */\n\tconst result = [];\n\n\tconst nodes = Array.from(\n\t\titems,\n\t\titem => new Node(item, getKey(item), getSize(item))\n\t);\n\n\t/** @type {Node<T>[]} */\n\tconst initialNodes = [];\n\n\t// lexically ordering of keys\n\tnodes.sort((a, b) => {\n\t\tif (a.key < b.key) return -1;\n\t\tif (a.key > b.key) return 1;\n\t\treturn 0;\n\t});\n\n\t// return nodes bigger than maxSize directly as group\n\tfor (const node of nodes) {\n\t\tif (node.size >= maxSize) {\n\t\t\tresult.push(new Group([node], []));\n\t\t} else {\n\t\t\tinitialNodes.push(node);\n\t\t}\n\t}\n\n\tif (initialNodes.length > 0) {\n\t\t// calculate similarities between lexically adjacent nodes\n\t\t/** @type {number[]} */\n\t\tconst similarities = [];\n\t\tfor (let i = 1; i < initialNodes.length; i++) {\n\t\t\tconst a = initialNodes[i - 1];\n\t\t\tconst b = initialNodes[i];\n\t\t\tsimilarities.push(similarity(a.key, b.key));\n\t\t}\n\n\t\tconst initialGroup = new Group(initialNodes, similarities);\n\n\t\tif (initialGroup.size < minSize) {\n\t\t\t// We hit an edgecase where the working set is already smaller than minSize\n\t\t\t// We merge it with the smallest result node to keep minSize intact\n\t\t\tif (result.length > 0) {\n\t\t\t\tconst smallestGroup = result.reduce((min, group) =>\n\t\t\t\t\tmin.size > group.size ? group : min\n\t\t\t\t);\n\t\t\t\tfor (const node of initialGroup.nodes) smallestGroup.nodes.push(node);\n\t\t\t\tsmallestGroup.nodes.sort((a, b) => {\n\t\t\t\t\tif (a.key < b.key) return -1;\n\t\t\t\t\tif (a.key > b.key) return 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// There are no other nodes\n\t\t\t\t// We use all nodes and have to accept that it's smaller than minSize\n\t\t\t\tresult.push(initialGroup);\n\t\t\t}\n\t\t} else {\n\t\t\tconst queue = [initialGroup];\n\n\t\t\twhile (queue.length) {\n\t\t\t\tconst group = queue.pop();\n\t\t\t\t// only groups bigger than maxSize need to be splitted\n\t\t\t\tif (group.size < maxSize) {\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// find unsplittable area from left and right\n\t\t\t\t// going minSize from left and right\n\t\t\t\t// at least one node need to be included otherwise we get stuck\n\t\t\t\tlet left = 0;\n\t\t\t\tlet leftSize = 0;\n\t\t\t\twhile (leftSize <= minSize) {\n\t\t\t\t\tleftSize += group.nodes[left].size;\n\t\t\t\t\tleft++;\n\t\t\t\t}\n\t\t\t\tlet right = group.nodes.length - 1;\n\t\t\t\tlet rightSize = 0;\n\t\t\t\twhile (rightSize <= minSize) {\n\t\t\t\t\trightSize += group.nodes[right].size;\n\t\t\t\t\tright--;\n\t\t\t\t}\n\n\t\t\t\tif (left - 1 > right) {\n\t\t\t\t\t// can't split group while holding minSize\n\t\t\t\t\t// because minSize is preferred of maxSize we return\n\t\t\t\t\t// the group here even while it's too big\n\t\t\t\t\t// To avoid this make sure maxSize > minSize * 3\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (left <= right) {\n\t\t\t\t\t// when there is a area between left and right\n\t\t\t\t\t// we look for best split point\n\t\t\t\t\t// we split at the minimum similarity\n\t\t\t\t\t// here key space is separated the most\n\t\t\t\t\tlet best = left - 1;\n\t\t\t\t\tlet bestSimilarity = group.similarities[best];\n\t\t\t\t\tfor (let i = left; i <= right; i++) {\n\t\t\t\t\t\tconst similarity = group.similarities[i];\n\t\t\t\t\t\tif (similarity < bestSimilarity) {\n\t\t\t\t\t\t\tbest = i;\n\t\t\t\t\t\t\tbestSimilarity = similarity;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tleft = best + 1;\n\t\t\t\t\tright = best;\n\t\t\t\t}\n\n\t\t\t\t// create two new groups for left and right area\n\t\t\t\t// and queue them up\n\t\t\t\tconst rightNodes = [group.nodes[right + 1]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst rightSimilaries = [];\n\t\t\t\tfor (let i = right + 2; i < group.nodes.length; i++) {\n\t\t\t\t\trightSimilaries.push(group.similarities[i - 1]);\n\t\t\t\t\trightNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(rightNodes, rightSimilaries));\n\n\t\t\t\tconst leftNodes = [group.nodes[0]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst leftSimilaries = [];\n\t\t\t\tfor (let i = 1; i < left; i++) {\n\t\t\t\t\tleftSimilaries.push(group.similarities[i - 1]);\n\t\t\t\t\tleftNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(leftNodes, leftSimilaries));\n\t\t\t}\n\t\t}\n\t}\n\n\t// lexically ordering\n\tresult.sort((a, b) => {\n\t\tif (a.nodes[0].key < b.nodes[0].key) return -1;\n\t\tif (a.nodes[0].key > b.nodes[0].key) return 1;\n\t\treturn 0;\n\t});\n\n\t// give every group a name\n\tfor (let i = 0; i < result.length; i++) {\n\t\tconst group = result[i];\n\t\tconst first = group.nodes[0];\n\t\tconst last = group.nodes[group.nodes.length - 1];\n\t\tlet name = getName(first.key, last.key);\n\t\tgroup.key = name;\n\t}\n\n\t// return the results\n\treturn result.map(group => {\n\t\t/** @type {GroupedItems} */\n\t\treturn {\n\t\t\tkey: group.key,\n\t\t\titems: group.nodes.map(node => node.item),\n\t\t\tsize: group.size\n\t\t};\n\t});\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}