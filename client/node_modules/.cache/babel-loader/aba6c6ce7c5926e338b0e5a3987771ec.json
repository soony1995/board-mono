{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst globToRegExp = require(\"./globToRegExp\").globToRegExp;\nfunction parseType(type) {\n  const items = type.split(\"+\");\n  const t = items.shift();\n  return {\n    type: t === \"*\" ? null : t,\n    features: items\n  };\n}\nfunction isTypeMatched(baseType, testedType) {\n  if (typeof baseType === \"string\") baseType = parseType(baseType);\n  if (typeof testedType === \"string\") testedType = parseType(testedType);\n  if (testedType.type && testedType.type !== baseType.type) return false;\n  return testedType.features.every(requiredFeature => {\n    return baseType.features.indexOf(requiredFeature) >= 0;\n  });\n}\nfunction isResourceTypeMatched(baseType, testedType) {\n  baseType = baseType.split(\"/\");\n  testedType = testedType.split(\"/\");\n  if (baseType.length !== testedType.length) return false;\n  for (let i = 0; i < baseType.length; i++) {\n    if (!isTypeMatched(baseType[i], testedType[i])) return false;\n  }\n  return true;\n}\nfunction isResourceTypeSupported(context, type) {\n  return context.supportedResourceTypes && context.supportedResourceTypes.some(supportedType => {\n    return isResourceTypeMatched(supportedType, type);\n  });\n}\nfunction isEnvironment(context, env) {\n  return context.environments && context.environments.every(environment => {\n    return isTypeMatched(environment, env);\n  });\n}\nconst globCache = {};\nfunction getGlobRegExp(glob) {\n  const regExp = globCache[glob] || (globCache[glob] = globToRegExp(glob));\n  return regExp;\n}\nfunction matchGlob(glob, relativePath) {\n  const regExp = getGlobRegExp(glob);\n  return regExp.exec(relativePath);\n}\nfunction isGlobMatched(glob, relativePath) {\n  return !!matchGlob(glob, relativePath);\n}\nfunction isConditionMatched(context, condition) {\n  const items = condition.split(\"|\");\n  return items.some(function testFn(item) {\n    item = item.trim();\n    const inverted = /^!/.test(item);\n    if (inverted) return !testFn(item.substr(1));\n    if (/^[a-z]+:/.test(item)) {\n      // match named condition\n      const match = /^([a-z]+):\\s*/.exec(item);\n      const value = item.substr(match[0].length);\n      const name = match[1];\n      switch (name) {\n        case \"referrer\":\n          return isGlobMatched(value, context.referrer);\n        default:\n          return false;\n      }\n    } else if (item.indexOf(\"/\") >= 0) {\n      // match supported type\n      return isResourceTypeSupported(context, item);\n    } else {\n      // match environment\n      return isEnvironment(context, item);\n    }\n  });\n}\nfunction isKeyMatched(context, key) {\n  for (;;) {\n    const match = /^\\[([^\\]]+)\\]\\s*/.exec(key);\n    if (!match) return key;\n    key = key.substr(match[0].length);\n    const condition = match[1];\n    if (!isConditionMatched(context, condition)) {\n      return false;\n    }\n  }\n}\nfunction getField(context, configuration, field) {\n  let value;\n  Object.keys(configuration).forEach(key => {\n    const pureKey = isKeyMatched(context, key);\n    if (pureKey === field) {\n      value = configuration[key];\n    }\n  });\n  return value;\n}\nfunction getMain(context, configuration) {\n  return getField(context, configuration, \"main\");\n}\nfunction getExtensions(context, configuration) {\n  return getField(context, configuration, \"extensions\");\n}\nfunction matchModule(context, configuration, request) {\n  const modulesField = getField(context, configuration, \"modules\");\n  if (!modulesField) return request;\n  let newRequest = request;\n  const keys = Object.keys(modulesField);\n  let iteration = 0;\n  let match;\n  let index;\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const pureKey = isKeyMatched(context, key);\n    match = matchGlob(pureKey, newRequest);\n    if (match) {\n      const value = modulesField[key];\n      if (typeof value !== \"string\") {\n        return value;\n      } else if (/^\\(.+\\)$/.test(pureKey)) {\n        newRequest = newRequest.replace(getGlobRegExp(pureKey), value);\n      } else {\n        index = 1;\n        newRequest = value.replace(/(\\/?\\*)?\\*/g, replaceMatcher);\n      }\n      i = -1;\n      if (iteration++ > keys.length) {\n        throw new Error(\"Request '\" + request + \"' matches recursively\");\n      }\n    }\n  }\n  return newRequest;\n  function replaceMatcher(find) {\n    switch (find) {\n      case \"/**\":\n        {\n          const m = match[index++];\n          return m ? \"/\" + m : \"\";\n        }\n      case \"**\":\n      case \"*\":\n        return match[index++];\n    }\n  }\n}\nfunction matchType(context, configuration, relativePath) {\n  const typesField = getField(context, configuration, \"types\");\n  if (!typesField) return undefined;\n  let type;\n  Object.keys(typesField).forEach(key => {\n    const pureKey = isKeyMatched(context, key);\n    if (isGlobMatched(pureKey, relativePath)) {\n      const value = typesField[key];\n      if (!type && /\\/\\*$/.test(value)) throw new Error(\"value ('\" + value + \"') of key '\" + key + \"' contains '*', but there is no previous value defined\");\n      type = value.replace(/\\/\\*$/, \"/\" + type);\n    }\n  });\n  return type;\n}\nexports.parseType = parseType;\nexports.isTypeMatched = isTypeMatched;\nexports.isResourceTypeSupported = isResourceTypeSupported;\nexports.isEnvironment = isEnvironment;\nexports.isGlobMatched = isGlobMatched;\nexports.isConditionMatched = isConditionMatched;\nexports.isKeyMatched = isKeyMatched;\nexports.getField = getField;\nexports.getMain = getMain;\nexports.getExtensions = getExtensions;\nexports.matchModule = matchModule;\nexports.matchType = matchType;","map":{"version":3,"names":["globToRegExp","require","parseType","type","items","split","t","shift","features","isTypeMatched","baseType","testedType","every","requiredFeature","indexOf","isResourceTypeMatched","length","i","isResourceTypeSupported","context","supportedResourceTypes","some","supportedType","isEnvironment","env","environments","environment","globCache","getGlobRegExp","glob","regExp","matchGlob","relativePath","exec","isGlobMatched","isConditionMatched","condition","testFn","item","trim","inverted","test","substr","match","value","name","referrer","isKeyMatched","key","getField","configuration","field","Object","keys","forEach","pureKey","getMain","getExtensions","matchModule","request","modulesField","newRequest","iteration","index","replace","replaceMatcher","Error","find","m","matchType","typesField","undefined","exports"],"sources":["/home/soon/bulletin-board/node_modules/enhanced-resolve/lib/concord.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst globToRegExp = require(\"./globToRegExp\").globToRegExp;\n\nfunction parseType(type) {\n\tconst items = type.split(\"+\");\n\tconst t = items.shift();\n\treturn {\n\t\ttype: t === \"*\" ? null : t,\n\t\tfeatures: items\n\t};\n}\n\nfunction isTypeMatched(baseType, testedType) {\n\tif (typeof baseType === \"string\") baseType = parseType(baseType);\n\tif (typeof testedType === \"string\") testedType = parseType(testedType);\n\tif (testedType.type && testedType.type !== baseType.type) return false;\n\treturn testedType.features.every(requiredFeature => {\n\t\treturn baseType.features.indexOf(requiredFeature) >= 0;\n\t});\n}\n\nfunction isResourceTypeMatched(baseType, testedType) {\n\tbaseType = baseType.split(\"/\");\n\ttestedType = testedType.split(\"/\");\n\tif (baseType.length !== testedType.length) return false;\n\tfor (let i = 0; i < baseType.length; i++) {\n\t\tif (!isTypeMatched(baseType[i], testedType[i])) return false;\n\t}\n\treturn true;\n}\n\nfunction isResourceTypeSupported(context, type) {\n\treturn (\n\t\tcontext.supportedResourceTypes &&\n\t\tcontext.supportedResourceTypes.some(supportedType => {\n\t\t\treturn isResourceTypeMatched(supportedType, type);\n\t\t})\n\t);\n}\n\nfunction isEnvironment(context, env) {\n\treturn (\n\t\tcontext.environments &&\n\t\tcontext.environments.every(environment => {\n\t\t\treturn isTypeMatched(environment, env);\n\t\t})\n\t);\n}\n\nconst globCache = {};\n\nfunction getGlobRegExp(glob) {\n\tconst regExp = globCache[glob] || (globCache[glob] = globToRegExp(glob));\n\treturn regExp;\n}\n\nfunction matchGlob(glob, relativePath) {\n\tconst regExp = getGlobRegExp(glob);\n\treturn regExp.exec(relativePath);\n}\n\nfunction isGlobMatched(glob, relativePath) {\n\treturn !!matchGlob(glob, relativePath);\n}\n\nfunction isConditionMatched(context, condition) {\n\tconst items = condition.split(\"|\");\n\treturn items.some(function testFn(item) {\n\t\titem = item.trim();\n\t\tconst inverted = /^!/.test(item);\n\t\tif (inverted) return !testFn(item.substr(1));\n\t\tif (/^[a-z]+:/.test(item)) {\n\t\t\t// match named condition\n\t\t\tconst match = /^([a-z]+):\\s*/.exec(item);\n\t\t\tconst value = item.substr(match[0].length);\n\t\t\tconst name = match[1];\n\t\t\tswitch (name) {\n\t\t\t\tcase \"referrer\":\n\t\t\t\t\treturn isGlobMatched(value, context.referrer);\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (item.indexOf(\"/\") >= 0) {\n\t\t\t// match supported type\n\t\t\treturn isResourceTypeSupported(context, item);\n\t\t} else {\n\t\t\t// match environment\n\t\t\treturn isEnvironment(context, item);\n\t\t}\n\t});\n}\n\nfunction isKeyMatched(context, key) {\n\tfor (;;) {\n\t\tconst match = /^\\[([^\\]]+)\\]\\s*/.exec(key);\n\t\tif (!match) return key;\n\t\tkey = key.substr(match[0].length);\n\t\tconst condition = match[1];\n\t\tif (!isConditionMatched(context, condition)) {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nfunction getField(context, configuration, field) {\n\tlet value;\n\tObject.keys(configuration).forEach(key => {\n\t\tconst pureKey = isKeyMatched(context, key);\n\t\tif (pureKey === field) {\n\t\t\tvalue = configuration[key];\n\t\t}\n\t});\n\treturn value;\n}\n\nfunction getMain(context, configuration) {\n\treturn getField(context, configuration, \"main\");\n}\n\nfunction getExtensions(context, configuration) {\n\treturn getField(context, configuration, \"extensions\");\n}\n\nfunction matchModule(context, configuration, request) {\n\tconst modulesField = getField(context, configuration, \"modules\");\n\tif (!modulesField) return request;\n\tlet newRequest = request;\n\tconst keys = Object.keys(modulesField);\n\tlet iteration = 0;\n\tlet match;\n\tlet index;\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\t\tconst pureKey = isKeyMatched(context, key);\n\t\tmatch = matchGlob(pureKey, newRequest);\n\t\tif (match) {\n\t\t\tconst value = modulesField[key];\n\t\t\tif (typeof value !== \"string\") {\n\t\t\t\treturn value;\n\t\t\t} else if (/^\\(.+\\)$/.test(pureKey)) {\n\t\t\t\tnewRequest = newRequest.replace(getGlobRegExp(pureKey), value);\n\t\t\t} else {\n\t\t\t\tindex = 1;\n\t\t\t\tnewRequest = value.replace(/(\\/?\\*)?\\*/g, replaceMatcher);\n\t\t\t}\n\t\t\ti = -1;\n\t\t\tif (iteration++ > keys.length) {\n\t\t\t\tthrow new Error(\"Request '\" + request + \"' matches recursively\");\n\t\t\t}\n\t\t}\n\t}\n\treturn newRequest;\n\n\tfunction replaceMatcher(find) {\n\t\tswitch (find) {\n\t\t\tcase \"/**\": {\n\t\t\t\tconst m = match[index++];\n\t\t\t\treturn m ? \"/\" + m : \"\";\n\t\t\t}\n\t\t\tcase \"**\":\n\t\t\tcase \"*\":\n\t\t\t\treturn match[index++];\n\t\t}\n\t}\n}\n\nfunction matchType(context, configuration, relativePath) {\n\tconst typesField = getField(context, configuration, \"types\");\n\tif (!typesField) return undefined;\n\tlet type;\n\tObject.keys(typesField).forEach(key => {\n\t\tconst pureKey = isKeyMatched(context, key);\n\t\tif (isGlobMatched(pureKey, relativePath)) {\n\t\t\tconst value = typesField[key];\n\t\t\tif (!type && /\\/\\*$/.test(value))\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"value ('\" +\n\t\t\t\t\t\tvalue +\n\t\t\t\t\t\t\"') of key '\" +\n\t\t\t\t\t\tkey +\n\t\t\t\t\t\t\"' contains '*', but there is no previous value defined\"\n\t\t\t\t);\n\t\t\ttype = value.replace(/\\/\\*$/, \"/\" + type);\n\t\t}\n\t});\n\treturn type;\n}\n\nexports.parseType = parseType;\nexports.isTypeMatched = isTypeMatched;\nexports.isResourceTypeSupported = isResourceTypeSupported;\nexports.isEnvironment = isEnvironment;\nexports.isGlobMatched = isGlobMatched;\nexports.isConditionMatched = isConditionMatched;\nexports.isKeyMatched = isKeyMatched;\nexports.getField = getField;\nexports.getMain = getMain;\nexports.getExtensions = getExtensions;\nexports.matchModule = matchModule;\nexports.matchType = matchType;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}