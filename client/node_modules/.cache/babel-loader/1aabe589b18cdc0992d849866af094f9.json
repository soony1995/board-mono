{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst mm = require(\"micromatch\");\nconst HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\nconst HarmonyImportSideEffectDependency = require(\"../dependencies/HarmonyImportSideEffectDependency\");\nconst HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n */\n\nclass SideEffectsFlagPlugin {\n  apply(compiler) {\n    compiler.hooks.normalModuleFactory.tap(\"SideEffectsFlagPlugin\", nmf => {\n      nmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n        const resolveData = data.resourceResolveData;\n        if (resolveData && resolveData.descriptionFileData && resolveData.relativePath) {\n          const sideEffects = resolveData.descriptionFileData.sideEffects;\n          const hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(resolveData.relativePath, sideEffects);\n          if (!hasSideEffects) {\n            module.factoryMeta.sideEffectFree = true;\n          }\n        }\n        return module;\n      });\n      nmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n        if (data.settings.sideEffects === false) {\n          module.factoryMeta.sideEffectFree = true;\n        } else if (data.settings.sideEffects === true) {\n          module.factoryMeta.sideEffectFree = false;\n        }\n      });\n    });\n    compiler.hooks.compilation.tap(\"SideEffectsFlagPlugin\", compilation => {\n      compilation.hooks.optimizeDependencies.tap(\"SideEffectsFlagPlugin\", modules => {\n        /** @type {Map<Module, Map<string, ExportInModule>>} */\n        const reexportMaps = new Map();\n\n        // Capture reexports of sideEffectFree modules\n        for (const module of modules) {\n          /** @type {Dependency[]} */\n          const removeDependencies = [];\n          for (const dep of module.dependencies) {\n            if (dep instanceof HarmonyImportSideEffectDependency) {\n              if (dep.module && dep.module.factoryMeta.sideEffectFree) {\n                removeDependencies.push(dep);\n              }\n            } else if (dep instanceof HarmonyExportImportedSpecifierDependency) {\n              if (module.factoryMeta.sideEffectFree) {\n                const mode = dep.getMode(true);\n                if (mode.type === \"safe-reexport\") {\n                  let map = reexportMaps.get(module);\n                  if (!map) {\n                    reexportMaps.set(module, map = new Map());\n                  }\n                  for (const pair of mode.map) {\n                    map.set(pair[0], {\n                      module: mode.module,\n                      exportName: pair[1]\n                    });\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        // Flatten reexports\n        for (const map of reexportMaps.values()) {\n          for (const pair of map) {\n            let mapping = pair[1];\n            while (mapping) {\n              const innerMap = reexportMaps.get(mapping.module);\n              if (!innerMap) break;\n              const newMapping = innerMap.get(mapping.exportName);\n              if (newMapping) {\n                map.set(pair[0], newMapping);\n              }\n              mapping = newMapping;\n            }\n          }\n        }\n\n        // Update imports along the reexports from sideEffectFree modules\n        for (const pair of reexportMaps) {\n          const module = pair[0];\n          const map = pair[1];\n          let newReasons = undefined;\n          for (let i = 0; i < module.reasons.length; i++) {\n            const reason = module.reasons[i];\n            const dep = reason.dependency;\n            if (dep instanceof HarmonyExportImportedSpecifierDependency || dep instanceof HarmonyImportSpecifierDependency && !dep.namespaceObjectAsContext) {\n              const mapping = map.get(dep._id);\n              if (mapping) {\n                dep.redirectedModule = mapping.module;\n                dep.redirectedId = mapping.exportName;\n                mapping.module.addReason(reason.module, dep, reason.explanation ? reason.explanation + \" (skipped side-effect-free modules)\" : \"(skipped side-effect-free modules)\");\n                // removing the currect reason, by not adding it to the newReasons array\n                // lazily create the newReasons array\n                if (newReasons === undefined) {\n                  newReasons = i === 0 ? [] : module.reasons.slice(0, i);\n                }\n                continue;\n              }\n            }\n            if (newReasons !== undefined) newReasons.push(reason);\n          }\n          if (newReasons !== undefined) {\n            module.reasons = newReasons;\n          }\n        }\n      });\n    });\n  }\n  static moduleHasSideEffects(moduleName, flagValue) {\n    switch (typeof flagValue) {\n      case \"undefined\":\n        return true;\n      case \"boolean\":\n        return flagValue;\n      case \"string\":\n        if (process.platform === \"win32\") {\n          flagValue = flagValue.replace(/\\\\/g, \"/\");\n        }\n        return mm.isMatch(moduleName, flagValue, {\n          matchBase: true\n        });\n      case \"object\":\n        return flagValue.some(glob => SideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob));\n    }\n  }\n}\nmodule.exports = SideEffectsFlagPlugin;","map":{"version":3,"names":["mm","require","HarmonyExportImportedSpecifierDependency","HarmonyImportSideEffectDependency","HarmonyImportSpecifierDependency","SideEffectsFlagPlugin","apply","compiler","hooks","normalModuleFactory","tap","nmf","module","data","resolveData","resourceResolveData","descriptionFileData","relativePath","sideEffects","hasSideEffects","moduleHasSideEffects","factoryMeta","sideEffectFree","settings","compilation","optimizeDependencies","modules","reexportMaps","Map","removeDependencies","dep","dependencies","push","mode","getMode","type","map","get","set","pair","exportName","values","mapping","innerMap","newMapping","newReasons","undefined","i","reasons","length","reason","dependency","namespaceObjectAsContext","_id","redirectedModule","redirectedId","addReason","explanation","slice","moduleName","flagValue","process","platform","replace","isMatch","matchBase","some","glob","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/optimize/SideEffectsFlagPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst mm = require(\"micromatch\");\nconst HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\nconst HarmonyImportSideEffectDependency = require(\"../dependencies/HarmonyImportSideEffectDependency\");\nconst HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n */\n\nclass SideEffectsFlagPlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.normalModuleFactory.tap(\"SideEffectsFlagPlugin\", nmf => {\n\t\t\tnmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n\t\t\t\tconst resolveData = data.resourceResolveData;\n\t\t\t\tif (\n\t\t\t\t\tresolveData &&\n\t\t\t\t\tresolveData.descriptionFileData &&\n\t\t\t\t\tresolveData.relativePath\n\t\t\t\t) {\n\t\t\t\t\tconst sideEffects = resolveData.descriptionFileData.sideEffects;\n\t\t\t\t\tconst hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(\n\t\t\t\t\t\tresolveData.relativePath,\n\t\t\t\t\t\tsideEffects\n\t\t\t\t\t);\n\t\t\t\t\tif (!hasSideEffects) {\n\t\t\t\t\t\tmodule.factoryMeta.sideEffectFree = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn module;\n\t\t\t});\n\t\t\tnmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n\t\t\t\tif (data.settings.sideEffects === false) {\n\t\t\t\t\tmodule.factoryMeta.sideEffectFree = true;\n\t\t\t\t} else if (data.settings.sideEffects === true) {\n\t\t\t\t\tmodule.factoryMeta.sideEffectFree = false;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tcompiler.hooks.compilation.tap(\"SideEffectsFlagPlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeDependencies.tap(\n\t\t\t\t\"SideEffectsFlagPlugin\",\n\t\t\t\tmodules => {\n\t\t\t\t\t/** @type {Map<Module, Map<string, ExportInModule>>} */\n\t\t\t\t\tconst reexportMaps = new Map();\n\n\t\t\t\t\t// Capture reexports of sideEffectFree modules\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t/** @type {Dependency[]} */\n\t\t\t\t\t\tconst removeDependencies = [];\n\t\t\t\t\t\tfor (const dep of module.dependencies) {\n\t\t\t\t\t\t\tif (dep instanceof HarmonyImportSideEffectDependency) {\n\t\t\t\t\t\t\t\tif (dep.module && dep.module.factoryMeta.sideEffectFree) {\n\t\t\t\t\t\t\t\t\tremoveDependencies.push(dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\tdep instanceof HarmonyExportImportedSpecifierDependency\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tif (module.factoryMeta.sideEffectFree) {\n\t\t\t\t\t\t\t\t\tconst mode = dep.getMode(true);\n\t\t\t\t\t\t\t\t\tif (mode.type === \"safe-reexport\") {\n\t\t\t\t\t\t\t\t\t\tlet map = reexportMaps.get(module);\n\t\t\t\t\t\t\t\t\t\tif (!map) {\n\t\t\t\t\t\t\t\t\t\t\treexportMaps.set(module, (map = new Map()));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor (const pair of mode.map) {\n\t\t\t\t\t\t\t\t\t\t\tmap.set(pair[0], {\n\t\t\t\t\t\t\t\t\t\t\t\tmodule: mode.module,\n\t\t\t\t\t\t\t\t\t\t\t\texportName: pair[1]\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Flatten reexports\n\t\t\t\t\tfor (const map of reexportMaps.values()) {\n\t\t\t\t\t\tfor (const pair of map) {\n\t\t\t\t\t\t\tlet mapping = pair[1];\n\t\t\t\t\t\t\twhile (mapping) {\n\t\t\t\t\t\t\t\tconst innerMap = reexportMaps.get(mapping.module);\n\t\t\t\t\t\t\t\tif (!innerMap) break;\n\t\t\t\t\t\t\t\tconst newMapping = innerMap.get(mapping.exportName);\n\t\t\t\t\t\t\t\tif (newMapping) {\n\t\t\t\t\t\t\t\t\tmap.set(pair[0], newMapping);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmapping = newMapping;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update imports along the reexports from sideEffectFree modules\n\t\t\t\t\tfor (const pair of reexportMaps) {\n\t\t\t\t\t\tconst module = pair[0];\n\t\t\t\t\t\tconst map = pair[1];\n\t\t\t\t\t\tlet newReasons = undefined;\n\t\t\t\t\t\tfor (let i = 0; i < module.reasons.length; i++) {\n\t\t\t\t\t\t\tconst reason = module.reasons[i];\n\t\t\t\t\t\t\tconst dep = reason.dependency;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tdep instanceof HarmonyExportImportedSpecifierDependency ||\n\t\t\t\t\t\t\t\t(dep instanceof HarmonyImportSpecifierDependency &&\n\t\t\t\t\t\t\t\t\t!dep.namespaceObjectAsContext)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst mapping = map.get(dep._id);\n\t\t\t\t\t\t\t\tif (mapping) {\n\t\t\t\t\t\t\t\t\tdep.redirectedModule = mapping.module;\n\t\t\t\t\t\t\t\t\tdep.redirectedId = mapping.exportName;\n\t\t\t\t\t\t\t\t\tmapping.module.addReason(\n\t\t\t\t\t\t\t\t\t\treason.module,\n\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\treason.explanation\n\t\t\t\t\t\t\t\t\t\t\t? reason.explanation +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\" (skipped side-effect-free modules)\"\n\t\t\t\t\t\t\t\t\t\t\t: \"(skipped side-effect-free modules)\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t// removing the currect reason, by not adding it to the newReasons array\n\t\t\t\t\t\t\t\t\t// lazily create the newReasons array\n\t\t\t\t\t\t\t\t\tif (newReasons === undefined) {\n\t\t\t\t\t\t\t\t\t\tnewReasons = i === 0 ? [] : module.reasons.slice(0, i);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (newReasons !== undefined) newReasons.push(reason);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (newReasons !== undefined) {\n\t\t\t\t\t\t\tmodule.reasons = newReasons;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\tstatic moduleHasSideEffects(moduleName, flagValue) {\n\t\tswitch (typeof flagValue) {\n\t\t\tcase \"undefined\":\n\t\t\t\treturn true;\n\t\t\tcase \"boolean\":\n\t\t\t\treturn flagValue;\n\t\t\tcase \"string\":\n\t\t\t\tif (process.platform === \"win32\") {\n\t\t\t\t\tflagValue = flagValue.replace(/\\\\/g, \"/\");\n\t\t\t\t}\n\t\t\t\treturn mm.isMatch(moduleName, flagValue, {\n\t\t\t\t\tmatchBase: true\n\t\t\t\t});\n\t\t\tcase \"object\":\n\t\t\t\treturn flagValue.some(glob =>\n\t\t\t\t\tSideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob)\n\t\t\t\t);\n\t\t}\n\t}\n}\nmodule.exports = SideEffectsFlagPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}