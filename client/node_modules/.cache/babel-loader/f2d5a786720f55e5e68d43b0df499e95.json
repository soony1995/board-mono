{"ast":null,"code":"/*\nMIT License http://www.opensource.org/licenses/mit-license.php\nAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst intersect = require(\"./util/SetHelpers\").intersect;\nconst GraphHelpers = require(\"./GraphHelpers\");\nconst Entrypoint = require(\"./Entrypoint\");\nlet debugId = 1000;\nconst ERR_CHUNK_ENTRY = \"Chunk.entry was removed. Use hasRuntime()\";\nconst ERR_CHUNK_INITIAL = \"Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\";\n\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./ModuleReason\")} ModuleReason */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n/**\n *  @typedef {Object} WithId an object who has an id property *\n *  @property {string | number} id the id of the object\n */\n\n/**\n * Compare two Modules based on their ids for sorting\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} sort value\n */\n\n// TODO use @callback\n/** @typedef {(a: Module, b: Module) => -1|0|1} ModuleSortPredicate */\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n/** @typedef {(c: Chunk) => boolean} ChunkFilterPredicate */\n\nconst sortModuleById = (a, b) => {\n  if (a.id < b.id) return -1;\n  if (b.id < a.id) return 1;\n  return 0;\n};\n\n/**\n * Compare two ChunkGroups based on their ids for sorting\n * @param {ChunkGroup} a chunk group\n * @param {ChunkGroup} b chunk group\n * @returns {-1|0|1} sort value\n */\nconst sortChunkGroupById = (a, b) => {\n  if (a.id < b.id) return -1;\n  if (b.id < a.id) return 1;\n  return 0;\n};\n\n/**\n * Compare two Identifiables , based on their ids for sorting\n * @param {Module} a first object with ident fn\n * @param {Module} b second object with ident fn\n * @returns {-1|0|1} The order number of the sort\n */\nconst sortByIdentifier = (a, b) => {\n  if (a.identifier() > b.identifier()) return 1;\n  if (a.identifier() < b.identifier()) return -1;\n  return 0;\n};\n\n/**\n * @returns {string} a concatenation of module identifiers sorted\n * @param {SortableSet} set to pull module identifiers from\n */\nconst getModulesIdent = set => {\n  set.sort();\n  let str = \"\";\n  for (const m of set) {\n    str += m.identifier() + \"#\";\n  }\n  return str;\n};\n\n/**\n * @template T\n * @param {SortableSet<T>} set the sortable set to convert to array\n * @returns {Array<T>} the array returned from Array.from(set)\n */\nconst getArray = set => Array.from(set);\n\n/**\n * @param {SortableSet<Module>} set the sortable Set to get the count/size of\n * @returns {number} the size of the modules\n */\nconst getModulesSize = set => {\n  let size = 0;\n  for (const module of set) {\n    size += module.size();\n  }\n  return size;\n};\n\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\nclass Chunk {\n  /**\n   * @param {string=} name of chunk being created, is optional (for subclasses)\n   */\n  constructor(name) {\n    /** @type {number | null} */\n    this.id = null;\n    /** @type {number[] | null} */\n    this.ids = null;\n    /** @type {number} */\n    this.debugId = debugId++;\n    /** @type {string} */\n    this.name = name;\n    /** @type {boolean} */\n    this.preventIntegration = false;\n    /** @type {Module=} */\n    this.entryModule = undefined;\n    /** @private @type {SortableSet<Module>} */\n    this._modules = new SortableSet(undefined, sortByIdentifier);\n    /** @type {string?} */\n    this.filenameTemplate = undefined;\n    /** @private @type {SortableSet<ChunkGroup>} */\n    this._groups = new SortableSet(undefined, sortChunkGroupById);\n    /** @type {string[]} */\n    this.files = [];\n    /** @type {boolean} */\n    this.rendered = false;\n    /** @type {string=} */\n    this.hash = undefined;\n    /** @type {Object} */\n    this.contentHash = Object.create(null);\n    /** @type {string=} */\n    this.renderedHash = undefined;\n    /** @type {string=} */\n    this.chunkReason = undefined;\n    /** @type {boolean} */\n    this.extraAsync = false;\n    this.removedModules = undefined;\n  }\n\n  /**\n   * @deprecated Chunk.entry has been deprecated. Please use .hasRuntime() instead\n   * @returns {never} Throws an error trying to access this property\n   */\n  get entry() {\n    throw new Error(ERR_CHUNK_ENTRY);\n  }\n\n  /**\n   * @deprecated .entry has been deprecated. Please use .hasRuntime() instead\n   * @param {never} data The data that was attempting to be set\n   * @returns {never} Throws an error trying to access this property\n   */\n  set entry(data) {\n    throw new Error(ERR_CHUNK_ENTRY);\n  }\n\n  /**\n   * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\n   * @returns {never} Throws an error trying to access this property\n   */\n  get initial() {\n    throw new Error(ERR_CHUNK_INITIAL);\n  }\n\n  /**\n   * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\n   * @param {never} data The data attempting to be set\n   * @returns {never} Throws an error trying to access this property\n   */\n  set initial(data) {\n    throw new Error(ERR_CHUNK_INITIAL);\n  }\n\n  /**\n   * @returns {boolean} whether or not the Chunk will have a runtime\n   */\n  hasRuntime() {\n    for (const chunkGroup of this._groups) {\n      if (chunkGroup.isInitial() && chunkGroup instanceof Entrypoint && chunkGroup.getRuntimeChunk() === this) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @returns {boolean} whether or not this chunk can be an initial chunk\n   */\n  canBeInitial() {\n    for (const chunkGroup of this._groups) {\n      if (chunkGroup.isInitial()) return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns {boolean} whether this chunk can only be an initial chunk\n   */\n  isOnlyInitial() {\n    if (this._groups.size <= 0) return false;\n    for (const chunkGroup of this._groups) {\n      if (!chunkGroup.isInitial()) return false;\n    }\n    return true;\n  }\n\n  /**\n   * @returns {boolean} if this chunk contains the entry module\n   */\n  hasEntryModule() {\n    return !!this.entryModule;\n  }\n\n  /**\n   * @param {Module} module the module that will be added to this chunk.\n   * @returns {boolean} returns true if the chunk doesn't have the module and it was added\n   */\n  addModule(module) {\n    if (!this._modules.has(module)) {\n      this._modules.add(module);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @param {Module} module the module that will be removed from this chunk\n   * @returns {boolean} returns true if chunk exists and is successfully deleted\n   */\n  removeModule(module) {\n    if (this._modules.delete(module)) {\n      module.removeChunk(this);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @param {Module[]} modules the new modules to be set\n   * @returns {void} set new modules to this chunk and return nothing\n   */\n  setModules(modules) {\n    this._modules = new SortableSet(modules, sortByIdentifier);\n  }\n\n  /**\n   * @returns {number} the amount of modules in chunk\n   */\n  getNumberOfModules() {\n    return this._modules.size;\n  }\n\n  /**\n   * @returns {SortableSet} return the modules SortableSet for this chunk\n   */\n  get modulesIterable() {\n    return this._modules;\n  }\n\n  /**\n   * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n   * @returns {boolean} returns true if chunk is not apart of chunkGroup and is added successfully\n   */\n  addGroup(chunkGroup) {\n    if (this._groups.has(chunkGroup)) return false;\n    this._groups.add(chunkGroup);\n    return true;\n  }\n\n  /**\n   * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n   * @returns {boolean} returns true if chunk does exist in chunkGroup and is removed\n   */\n  removeGroup(chunkGroup) {\n    if (!this._groups.has(chunkGroup)) return false;\n    this._groups.delete(chunkGroup);\n    return true;\n  }\n\n  /**\n   * @param {ChunkGroup} chunkGroup the chunkGroup to check\n   * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n   */\n  isInGroup(chunkGroup) {\n    return this._groups.has(chunkGroup);\n  }\n\n  /**\n   * @returns {number} the amount of groups said chunk is in\n   */\n  getNumberOfGroups() {\n    return this._groups.size;\n  }\n\n  /**\n   * @returns {SortableSet<ChunkGroup>} the chunkGroups that said chunk is referenced in\n   */\n  get groupsIterable() {\n    return this._groups;\n  }\n\n  /**\n   * @param {Chunk} otherChunk the chunk to compare itself with\n   * @returns {-1|0|1} this is a comparitor function like sort and returns -1, 0, or 1 based on sort order\n   */\n  compareTo(otherChunk) {\n    if (this.name && !otherChunk.name) return -1;\n    if (!this.name && otherChunk.name) return 1;\n    if (this.name < otherChunk.name) return -1;\n    if (this.name > otherChunk.name) return 1;\n    if (this._modules.size > otherChunk._modules.size) return -1;\n    if (this._modules.size < otherChunk._modules.size) return 1;\n    this._modules.sort();\n    otherChunk._modules.sort();\n    const a = this._modules[Symbol.iterator]();\n    const b = otherChunk._modules[Symbol.iterator]();\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const aItem = a.next();\n      if (aItem.done) return 0;\n      const bItem = b.next();\n      const aModuleIdentifier = aItem.value.identifier();\n      const bModuleIdentifier = bItem.value.identifier();\n      if (aModuleIdentifier < bModuleIdentifier) return -1;\n      if (aModuleIdentifier > bModuleIdentifier) return 1;\n    }\n  }\n\n  /**\n   * @param {Module} module Module to check\n   * @returns {boolean} returns true if module does exist in this chunk\n   */\n  containsModule(module) {\n    return this._modules.has(module);\n  }\n\n  /**\n   * @returns {Module[]} an array of modules (do not modify)\n   */\n  getModules() {\n    return this._modules.getFromCache(getArray);\n  }\n  getModulesIdent() {\n    return this._modules.getFromUnorderedCache(getModulesIdent);\n  }\n\n  /**\n   * @param {string=} reason reason why chunk is removed\n   * @returns {void}\n   */\n  remove(reason) {\n    // cleanup modules\n    // Array.from is used here to create a clone, because removeChunk modifies this._modules\n    for (const module of Array.from(this._modules)) {\n      module.removeChunk(this);\n    }\n    for (const chunkGroup of this._groups) {\n      chunkGroup.removeChunk(this);\n    }\n  }\n\n  /**\n   *\n   * @param {Module} module module to move\n   * @param {Chunk} otherChunk other chunk to move it to\n   * @returns {void}\n   */\n  moveModule(module, otherChunk) {\n    GraphHelpers.disconnectChunkAndModule(this, module);\n    GraphHelpers.connectChunkAndModule(otherChunk, module);\n    module.rewriteChunkInReasons(this, [otherChunk]);\n  }\n\n  /**\n   *\n   * @param {Chunk} otherChunk the chunk to integrate with\n   * @param {string} reason reason why the module is being integrated\n   * @returns {boolean} returns true or false if integration succeeds or fails\n   */\n  integrate(otherChunk, reason) {\n    if (!this.canBeIntegrated(otherChunk)) {\n      return false;\n    }\n\n    // Pick a new name for the integrated chunk\n    if (this.name && otherChunk.name) {\n      if (this.hasEntryModule() === otherChunk.hasEntryModule()) {\n        // When both chunks have entry modules or none have one, use\n        // shortest name\n        if (this.name.length !== otherChunk.name.length) {\n          this.name = this.name.length < otherChunk.name.length ? this.name : otherChunk.name;\n        } else {\n          this.name = this.name < otherChunk.name ? this.name : otherChunk.name;\n        }\n      } else if (otherChunk.hasEntryModule()) {\n        // Pick the name of the chunk with the entry module\n        this.name = otherChunk.name;\n      }\n    } else if (otherChunk.name) {\n      this.name = otherChunk.name;\n    }\n\n    // Array.from is used here to create a clone, because moveModule modifies otherChunk._modules\n    for (const module of Array.from(otherChunk._modules)) {\n      otherChunk.moveModule(module, this);\n    }\n    otherChunk._modules.clear();\n    if (otherChunk.entryModule) {\n      this.entryModule = otherChunk.entryModule;\n    }\n    for (const chunkGroup of otherChunk._groups) {\n      chunkGroup.replaceChunk(otherChunk, this);\n      this.addGroup(chunkGroup);\n    }\n    otherChunk._groups.clear();\n    return true;\n  }\n\n  /**\n   * @param {Chunk} newChunk the new chunk that will be split out of the current chunk\n   * @returns {void}\n   */\n  split(newChunk) {\n    for (const chunkGroup of this._groups) {\n      chunkGroup.insertChunk(newChunk, this);\n      newChunk.addGroup(chunkGroup);\n    }\n  }\n  isEmpty() {\n    return this._modules.size === 0;\n  }\n  updateHash(hash) {\n    hash.update(`${this.id} `);\n    hash.update(this.ids ? this.ids.join(\",\") : \"\");\n    hash.update(`${this.name || \"\"} `);\n    for (const m of this._modules) {\n      hash.update(m.hash);\n    }\n  }\n  canBeIntegrated(otherChunk) {\n    if (this.preventIntegration || otherChunk.preventIntegration) {\n      return false;\n    }\n\n    /**\n     * @param {Chunk} a chunk\n     * @param {Chunk} b chunk\n     * @returns {boolean} true, if a is always available when b is reached\n     */\n    const isAvailable = (a, b) => {\n      const queue = new Set(b.groupsIterable);\n      for (const chunkGroup of queue) {\n        if (a.isInGroup(chunkGroup)) continue;\n        if (chunkGroup.isInitial()) return false;\n        for (const parent of chunkGroup.parentsIterable) {\n          queue.add(parent);\n        }\n      }\n      return true;\n    };\n    const selfHasRuntime = this.hasRuntime();\n    const otherChunkHasRuntime = otherChunk.hasRuntime();\n    if (selfHasRuntime !== otherChunkHasRuntime) {\n      if (selfHasRuntime) {\n        return isAvailable(this, otherChunk);\n      } else if (otherChunkHasRuntime) {\n        return isAvailable(otherChunk, this);\n      } else {\n        return false;\n      }\n    }\n    if (this.hasEntryModule() || otherChunk.hasEntryModule()) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   *\n   * @param {number} size the size\n   * @param {Object} options the options passed in\n   * @returns {number} the multiplier returned\n   */\n  addMultiplierAndOverhead(size, options) {\n    const overhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n    const multiplicator = this.canBeInitial() ? options.entryChunkMultiplicator || 10 : 1;\n    return size * multiplicator + overhead;\n  }\n\n  /**\n   * @returns {number} the size of all modules\n   */\n  modulesSize() {\n    return this._modules.getFromUnorderedCache(getModulesSize);\n  }\n\n  /**\n   * @param {Object} options the size display options\n   * @returns {number} the chunk size\n   */\n  size(options = {}) {\n    return this.addMultiplierAndOverhead(this.modulesSize(), options);\n  }\n\n  /**\n   * @param {Chunk} otherChunk the other chunk\n   * @param {TODO} options the options for this function\n   * @returns {number | false} the size, or false if it can't be integrated\n   */\n  integratedSize(otherChunk, options) {\n    // Chunk if it's possible to integrate this chunk\n    if (!this.canBeIntegrated(otherChunk)) {\n      return false;\n    }\n    let integratedModulesSize = this.modulesSize();\n    // only count modules that do not exist in this chunk!\n    for (const otherModule of otherChunk._modules) {\n      if (!this._modules.has(otherModule)) {\n        integratedModulesSize += otherModule.size();\n      }\n    }\n    return this.addMultiplierAndOverhead(integratedModulesSize, options);\n  }\n\n  /**\n   * @param {function(Module, Module): -1|0|1=} sortByFn a predicate function used to sort modules\n   * @returns {void}\n   */\n  sortModules(sortByFn) {\n    this._modules.sortWith(sortByFn || sortModuleById);\n  }\n  sortItems() {\n    this.sortModules();\n  }\n\n  /**\n   * @returns {Set<Chunk>} a set of all the async chunks\n   */\n  getAllAsyncChunks() {\n    const queue = new Set();\n    const chunks = new Set();\n    const initialChunks = intersect(Array.from(this.groupsIterable, g => new Set(g.chunks)));\n    for (const chunkGroup of this.groupsIterable) {\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    for (const chunkGroup of queue) {\n      for (const chunk of chunkGroup.chunks) {\n        if (!initialChunks.has(chunk)) {\n          chunks.add(chunk);\n        }\n      }\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    return chunks;\n  }\n\n  /**\n   * @typedef {Object} ChunkMaps\n   * @property {Record<string|number, string>} hash\n   * @property {Record<string|number, Record<string, string>>} contentHash\n   * @property {Record<string|number, string>} name\n   */\n\n  /**\n   * @param {boolean} realHash should the full hash or the rendered hash be used\n   * @returns {ChunkMaps} the chunk map information\n   */\n  getChunkMaps(realHash) {\n    /** @type {Record<string|number, string>} */\n    const chunkHashMap = Object.create(null);\n    /** @type {Record<string|number, Record<string, string>>} */\n    const chunkContentHashMap = Object.create(null);\n    /** @type {Record<string|number, string>} */\n    const chunkNameMap = Object.create(null);\n    for (const chunk of this.getAllAsyncChunks()) {\n      chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n      for (const key of Object.keys(chunk.contentHash)) {\n        if (!chunkContentHashMap[key]) {\n          chunkContentHashMap[key] = Object.create(null);\n        }\n        chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n      }\n      if (chunk.name) {\n        chunkNameMap[chunk.id] = chunk.name;\n      }\n    }\n    return {\n      hash: chunkHashMap,\n      contentHash: chunkContentHashMap,\n      name: chunkNameMap\n    };\n  }\n\n  /**\n   * @returns {Record<string, Set<TODO>[]>} a record object of names to lists of child ids(?)\n   */\n  getChildIdsByOrders() {\n    const lists = new Map();\n    for (const group of this.groupsIterable) {\n      if (group.chunks[group.chunks.length - 1] === this) {\n        for (const childGroup of group.childrenIterable) {\n          // TODO webpack 5 remove this check for options\n          if (typeof childGroup.options === \"object\") {\n            for (const key of Object.keys(childGroup.options)) {\n              if (key.endsWith(\"Order\")) {\n                const name = key.substr(0, key.length - \"Order\".length);\n                let list = lists.get(name);\n                if (list === undefined) lists.set(name, list = []);\n                list.push({\n                  order: childGroup.options[key],\n                  group: childGroup\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n    const result = Object.create(null);\n    for (const [name, list] of lists) {\n      list.sort((a, b) => {\n        const cmp = b.order - a.order;\n        if (cmp !== 0) return cmp;\n        // TODO webpack 5 remove this check of compareTo\n        if (a.group.compareTo) {\n          return a.group.compareTo(b.group);\n        }\n        return 0;\n      });\n      result[name] = Array.from(list.reduce((set, item) => {\n        for (const chunk of item.group.chunks) {\n          set.add(chunk.id);\n        }\n        return set;\n      }, new Set()));\n    }\n    return result;\n  }\n  getChildIdsByOrdersMap(includeDirectChildren) {\n    const chunkMaps = Object.create(null);\n    const addChildIdsByOrdersToMap = chunk => {\n      const data = chunk.getChildIdsByOrders();\n      for (const key of Object.keys(data)) {\n        let chunkMap = chunkMaps[key];\n        if (chunkMap === undefined) {\n          chunkMaps[key] = chunkMap = Object.create(null);\n        }\n        chunkMap[chunk.id] = data[key];\n      }\n    };\n    if (includeDirectChildren) {\n      const chunks = new Set();\n      for (const chunkGroup of this.groupsIterable) {\n        for (const chunk of chunkGroup.chunks) {\n          chunks.add(chunk);\n        }\n      }\n      for (const chunk of chunks) {\n        addChildIdsByOrdersToMap(chunk);\n      }\n    }\n    for (const chunk of this.getAllAsyncChunks()) {\n      addChildIdsByOrdersToMap(chunk);\n    }\n    return chunkMaps;\n  }\n\n  /**\n   * @typedef {Object} ChunkModuleMaps\n   * @property {Record<string|number, (string|number)[]>} id\n   * @property {Record<string|number, string>} hash\n   */\n\n  /**\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules\n   * @returns {ChunkModuleMaps} module map information\n   */\n  getChunkModuleMaps(filterFn) {\n    /** @type {Record<string|number, (string|number)[]>} */\n    const chunkModuleIdMap = Object.create(null);\n    /** @type {Record<string|number, string>} */\n    const chunkModuleHashMap = Object.create(null);\n    for (const chunk of this.getAllAsyncChunks()) {\n      /** @type {(string|number)[]} */\n      let array;\n      for (const module of chunk.modulesIterable) {\n        if (filterFn(module)) {\n          if (array === undefined) {\n            array = [];\n            chunkModuleIdMap[chunk.id] = array;\n          }\n          array.push(module.id);\n          chunkModuleHashMap[module.id] = module.renderedHash;\n        }\n      }\n      if (array !== undefined) {\n        array.sort();\n      }\n    }\n    return {\n      id: chunkModuleIdMap,\n      hash: chunkModuleHashMap\n    };\n  }\n\n  /**\n   *\n   * @param {function(Module): boolean} filterFn predicate function used to filter modules\n   * @param {function(Chunk): boolean} filterChunkFn predicate function used to filter chunks\n   * @returns {boolean} return true if module exists in graph\n   */\n  hasModuleInGraph(filterFn, filterChunkFn) {\n    const queue = new Set(this.groupsIterable);\n    const chunksProcessed = new Set();\n    for (const chunkGroup of queue) {\n      for (const chunk of chunkGroup.chunks) {\n        if (!chunksProcessed.has(chunk)) {\n          chunksProcessed.add(chunk);\n          if (!filterChunkFn || filterChunkFn(chunk)) {\n            for (const module of chunk.modulesIterable) {\n              if (filterFn(module)) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n    return false;\n  }\n  toString() {\n    return `Chunk[${Array.from(this._modules).join()}]`;\n  }\n}\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"forEachModule\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @this {Chunk}\n   * @typedef {function(any, any, Set<any>): void} ForEachModuleCallback\n   * @param {ForEachModuleCallback} fn Callback function\n   * @returns {void}\n   */\n  function (fn) {\n    this._modules.forEach(fn);\n  }, \"Chunk.forEachModule: Use for(const module of chunk.modulesIterable) instead\")\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"mapModules\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @this {Chunk}\n   * @typedef {function(any, number): any} MapModulesCallback\n   * @param {MapModulesCallback} fn Callback function\n   * @returns {TODO[]} result of mapped modules\n   */\n  function (fn) {\n    return Array.from(this._modules, fn);\n  }, \"Chunk.mapModules: Use Array.from(chunk.modulesIterable, fn) instead\")\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"chunks\", {\n  configurable: false,\n  get() {\n    throw new Error(\"Chunk.chunks: Use ChunkGroup.getChildren() instead\");\n  },\n  set() {\n    throw new Error(\"Chunk.chunks: Use ChunkGroup.add/removeChild() instead\");\n  }\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"parents\", {\n  configurable: false,\n  get() {\n    throw new Error(\"Chunk.parents: Use ChunkGroup.getParents() instead\");\n  },\n  set() {\n    throw new Error(\"Chunk.parents: Use ChunkGroup.add/removeParent() instead\");\n  }\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"blocks\", {\n  configurable: false,\n  get() {\n    throw new Error(\"Chunk.blocks: Use ChunkGroup.getBlocks() instead\");\n  },\n  set() {\n    throw new Error(\"Chunk.blocks: Use ChunkGroup.add/removeBlock() instead\");\n  }\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"entrypoints\", {\n  configurable: false,\n  get() {\n    throw new Error(\"Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead\");\n  },\n  set() {\n    throw new Error(\"Chunk.entrypoints: Use Chunks.addGroup instead\");\n  }\n});\nmodule.exports = Chunk;","map":{"version":3,"names":["util","require","SortableSet","intersect","GraphHelpers","Entrypoint","debugId","ERR_CHUNK_ENTRY","ERR_CHUNK_INITIAL","sortModuleById","a","b","id","sortChunkGroupById","sortByIdentifier","identifier","getModulesIdent","set","sort","str","m","getArray","Array","from","getModulesSize","size","module","Chunk","constructor","name","ids","preventIntegration","entryModule","undefined","_modules","filenameTemplate","_groups","files","rendered","hash","contentHash","Object","create","renderedHash","chunkReason","extraAsync","removedModules","entry","Error","data","initial","hasRuntime","chunkGroup","isInitial","getRuntimeChunk","canBeInitial","isOnlyInitial","hasEntryModule","addModule","has","add","removeModule","delete","removeChunk","setModules","modules","getNumberOfModules","modulesIterable","addGroup","removeGroup","isInGroup","getNumberOfGroups","groupsIterable","compareTo","otherChunk","Symbol","iterator","aItem","next","done","bItem","aModuleIdentifier","value","bModuleIdentifier","containsModule","getModules","getFromCache","getFromUnorderedCache","remove","reason","moveModule","disconnectChunkAndModule","connectChunkAndModule","rewriteChunkInReasons","integrate","canBeIntegrated","length","clear","replaceChunk","split","newChunk","insertChunk","isEmpty","updateHash","update","join","isAvailable","queue","Set","parent","parentsIterable","selfHasRuntime","otherChunkHasRuntime","addMultiplierAndOverhead","options","overhead","chunkOverhead","multiplicator","entryChunkMultiplicator","modulesSize","integratedSize","integratedModulesSize","otherModule","sortModules","sortByFn","sortWith","sortItems","getAllAsyncChunks","chunks","initialChunks","g","child","childrenIterable","chunk","getChunkMaps","realHash","chunkHashMap","chunkContentHashMap","chunkNameMap","key","keys","getChildIdsByOrders","lists","Map","group","childGroup","endsWith","substr","list","get","push","order","result","cmp","reduce","item","getChildIdsByOrdersMap","includeDirectChildren","chunkMaps","addChildIdsByOrdersToMap","chunkMap","getChunkModuleMaps","filterFn","chunkModuleIdMap","chunkModuleHashMap","array","hasModuleInGraph","filterChunkFn","chunksProcessed","toString","defineProperty","prototype","configurable","deprecate","fn","forEach","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/Chunk.js"],"sourcesContent":["/*\nMIT License http://www.opensource.org/licenses/mit-license.php\nAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst intersect = require(\"./util/SetHelpers\").intersect;\nconst GraphHelpers = require(\"./GraphHelpers\");\nconst Entrypoint = require(\"./Entrypoint\");\nlet debugId = 1000;\nconst ERR_CHUNK_ENTRY = \"Chunk.entry was removed. Use hasRuntime()\";\nconst ERR_CHUNK_INITIAL =\n\t\"Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\";\n\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./ModuleReason\")} ModuleReason */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n/**\n *  @typedef {Object} WithId an object who has an id property *\n *  @property {string | number} id the id of the object\n */\n\n/**\n * Compare two Modules based on their ids for sorting\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} sort value\n */\n\n// TODO use @callback\n/** @typedef {(a: Module, b: Module) => -1|0|1} ModuleSortPredicate */\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n/** @typedef {(c: Chunk) => boolean} ChunkFilterPredicate */\n\nconst sortModuleById = (a, b) => {\n\tif (a.id < b.id) return -1;\n\tif (b.id < a.id) return 1;\n\treturn 0;\n};\n\n/**\n * Compare two ChunkGroups based on their ids for sorting\n * @param {ChunkGroup} a chunk group\n * @param {ChunkGroup} b chunk group\n * @returns {-1|0|1} sort value\n */\nconst sortChunkGroupById = (a, b) => {\n\tif (a.id < b.id) return -1;\n\tif (b.id < a.id) return 1;\n\treturn 0;\n};\n\n/**\n * Compare two Identifiables , based on their ids for sorting\n * @param {Module} a first object with ident fn\n * @param {Module} b second object with ident fn\n * @returns {-1|0|1} The order number of the sort\n */\nconst sortByIdentifier = (a, b) => {\n\tif (a.identifier() > b.identifier()) return 1;\n\tif (a.identifier() < b.identifier()) return -1;\n\treturn 0;\n};\n\n/**\n * @returns {string} a concatenation of module identifiers sorted\n * @param {SortableSet} set to pull module identifiers from\n */\nconst getModulesIdent = set => {\n\tset.sort();\n\tlet str = \"\";\n\tfor (const m of set) {\n\t\tstr += m.identifier() + \"#\";\n\t}\n\treturn str;\n};\n\n/**\n * @template T\n * @param {SortableSet<T>} set the sortable set to convert to array\n * @returns {Array<T>} the array returned from Array.from(set)\n */\nconst getArray = set => Array.from(set);\n\n/**\n * @param {SortableSet<Module>} set the sortable Set to get the count/size of\n * @returns {number} the size of the modules\n */\nconst getModulesSize = set => {\n\tlet size = 0;\n\tfor (const module of set) {\n\t\tsize += module.size();\n\t}\n\treturn size;\n};\n\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\nclass Chunk {\n\t/**\n\t * @param {string=} name of chunk being created, is optional (for subclasses)\n\t */\n\tconstructor(name) {\n\t\t/** @type {number | null} */\n\t\tthis.id = null;\n\t\t/** @type {number[] | null} */\n\t\tthis.ids = null;\n\t\t/** @type {number} */\n\t\tthis.debugId = debugId++;\n\t\t/** @type {string} */\n\t\tthis.name = name;\n\t\t/** @type {boolean} */\n\t\tthis.preventIntegration = false;\n\t\t/** @type {Module=} */\n\t\tthis.entryModule = undefined;\n\t\t/** @private @type {SortableSet<Module>} */\n\t\tthis._modules = new SortableSet(undefined, sortByIdentifier);\n\t\t/** @type {string?} */\n\t\tthis.filenameTemplate = undefined;\n\t\t/** @private @type {SortableSet<ChunkGroup>} */\n\t\tthis._groups = new SortableSet(undefined, sortChunkGroupById);\n\t\t/** @type {string[]} */\n\t\tthis.files = [];\n\t\t/** @type {boolean} */\n\t\tthis.rendered = false;\n\t\t/** @type {string=} */\n\t\tthis.hash = undefined;\n\t\t/** @type {Object} */\n\t\tthis.contentHash = Object.create(null);\n\t\t/** @type {string=} */\n\t\tthis.renderedHash = undefined;\n\t\t/** @type {string=} */\n\t\tthis.chunkReason = undefined;\n\t\t/** @type {boolean} */\n\t\tthis.extraAsync = false;\n\t\tthis.removedModules = undefined;\n\t}\n\n\t/**\n\t * @deprecated Chunk.entry has been deprecated. Please use .hasRuntime() instead\n\t * @returns {never} Throws an error trying to access this property\n\t */\n\tget entry() {\n\t\tthrow new Error(ERR_CHUNK_ENTRY);\n\t}\n\n\t/**\n\t * @deprecated .entry has been deprecated. Please use .hasRuntime() instead\n\t * @param {never} data The data that was attempting to be set\n\t * @returns {never} Throws an error trying to access this property\n\t */\n\tset entry(data) {\n\t\tthrow new Error(ERR_CHUNK_ENTRY);\n\t}\n\n\t/**\n\t * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\n\t * @returns {never} Throws an error trying to access this property\n\t */\n\tget initial() {\n\t\tthrow new Error(ERR_CHUNK_INITIAL);\n\t}\n\n\t/**\n\t * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\n\t * @param {never} data The data attempting to be set\n\t * @returns {never} Throws an error trying to access this property\n\t */\n\tset initial(data) {\n\t\tthrow new Error(ERR_CHUNK_INITIAL);\n\t}\n\n\t/**\n\t * @returns {boolean} whether or not the Chunk will have a runtime\n\t */\n\thasRuntime() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (\n\t\t\t\tchunkGroup.isInitial() &&\n\t\t\t\tchunkGroup instanceof Entrypoint &&\n\t\t\t\tchunkGroup.getRuntimeChunk() === this\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} whether or not this chunk can be an initial chunk\n\t */\n\tcanBeInitial() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (chunkGroup.isInitial()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} whether this chunk can only be an initial chunk\n\t */\n\tisOnlyInitial() {\n\t\tif (this._groups.size <= 0) return false;\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (!chunkGroup.isInitial()) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @returns {boolean} if this chunk contains the entry module\n\t */\n\thasEntryModule() {\n\t\treturn !!this.entryModule;\n\t}\n\n\t/**\n\t * @param {Module} module the module that will be added to this chunk.\n\t * @returns {boolean} returns true if the chunk doesn't have the module and it was added\n\t */\n\taddModule(module) {\n\t\tif (!this._modules.has(module)) {\n\t\t\tthis._modules.add(module);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module} module the module that will be removed from this chunk\n\t * @returns {boolean} returns true if chunk exists and is successfully deleted\n\t */\n\tremoveModule(module) {\n\t\tif (this._modules.delete(module)) {\n\t\t\tmodule.removeChunk(this);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module[]} modules the new modules to be set\n\t * @returns {void} set new modules to this chunk and return nothing\n\t */\n\tsetModules(modules) {\n\t\tthis._modules = new SortableSet(modules, sortByIdentifier);\n\t}\n\n\t/**\n\t * @returns {number} the amount of modules in chunk\n\t */\n\tgetNumberOfModules() {\n\t\treturn this._modules.size;\n\t}\n\n\t/**\n\t * @returns {SortableSet} return the modules SortableSet for this chunk\n\t */\n\tget modulesIterable() {\n\t\treturn this._modules;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n\t * @returns {boolean} returns true if chunk is not apart of chunkGroup and is added successfully\n\t */\n\taddGroup(chunkGroup) {\n\t\tif (this._groups.has(chunkGroup)) return false;\n\t\tthis._groups.add(chunkGroup);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n\t * @returns {boolean} returns true if chunk does exist in chunkGroup and is removed\n\t */\n\tremoveGroup(chunkGroup) {\n\t\tif (!this._groups.has(chunkGroup)) return false;\n\t\tthis._groups.delete(chunkGroup);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to check\n\t * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n\t */\n\tisInGroup(chunkGroup) {\n\t\treturn this._groups.has(chunkGroup);\n\t}\n\n\t/**\n\t * @returns {number} the amount of groups said chunk is in\n\t */\n\tgetNumberOfGroups() {\n\t\treturn this._groups.size;\n\t}\n\n\t/**\n\t * @returns {SortableSet<ChunkGroup>} the chunkGroups that said chunk is referenced in\n\t */\n\tget groupsIterable() {\n\t\treturn this._groups;\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the chunk to compare itself with\n\t * @returns {-1|0|1} this is a comparitor function like sort and returns -1, 0, or 1 based on sort order\n\t */\n\tcompareTo(otherChunk) {\n\t\tif (this.name && !otherChunk.name) return -1;\n\t\tif (!this.name && otherChunk.name) return 1;\n\t\tif (this.name < otherChunk.name) return -1;\n\t\tif (this.name > otherChunk.name) return 1;\n\t\tif (this._modules.size > otherChunk._modules.size) return -1;\n\t\tif (this._modules.size < otherChunk._modules.size) return 1;\n\t\tthis._modules.sort();\n\t\totherChunk._modules.sort();\n\t\tconst a = this._modules[Symbol.iterator]();\n\t\tconst b = otherChunk._modules[Symbol.iterator]();\n\t\t// eslint-disable-next-line no-constant-condition\n\t\twhile (true) {\n\t\t\tconst aItem = a.next();\n\t\t\tif (aItem.done) return 0;\n\t\t\tconst bItem = b.next();\n\t\t\tconst aModuleIdentifier = aItem.value.identifier();\n\t\t\tconst bModuleIdentifier = bItem.value.identifier();\n\t\t\tif (aModuleIdentifier < bModuleIdentifier) return -1;\n\t\t\tif (aModuleIdentifier > bModuleIdentifier) return 1;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module Module to check\n\t * @returns {boolean} returns true if module does exist in this chunk\n\t */\n\tcontainsModule(module) {\n\t\treturn this._modules.has(module);\n\t}\n\n\t/**\n\t * @returns {Module[]} an array of modules (do not modify)\n\t */\n\tgetModules() {\n\t\treturn this._modules.getFromCache(getArray);\n\t}\n\n\tgetModulesIdent() {\n\t\treturn this._modules.getFromUnorderedCache(getModulesIdent);\n\t}\n\n\t/**\n\t * @param {string=} reason reason why chunk is removed\n\t * @returns {void}\n\t */\n\tremove(reason) {\n\t\t// cleanup modules\n\t\t// Array.from is used here to create a clone, because removeChunk modifies this._modules\n\t\tfor (const module of Array.from(this._modules)) {\n\t\t\tmodule.removeChunk(this);\n\t\t}\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tchunkGroup.removeChunk(this);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {Module} module module to move\n\t * @param {Chunk} otherChunk other chunk to move it to\n\t * @returns {void}\n\t */\n\tmoveModule(module, otherChunk) {\n\t\tGraphHelpers.disconnectChunkAndModule(this, module);\n\t\tGraphHelpers.connectChunkAndModule(otherChunk, module);\n\t\tmodule.rewriteChunkInReasons(this, [otherChunk]);\n\t}\n\n\t/**\n\t *\n\t * @param {Chunk} otherChunk the chunk to integrate with\n\t * @param {string} reason reason why the module is being integrated\n\t * @returns {boolean} returns true or false if integration succeeds or fails\n\t */\n\tintegrate(otherChunk, reason) {\n\t\tif (!this.canBeIntegrated(otherChunk)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Pick a new name for the integrated chunk\n\t\tif (this.name && otherChunk.name) {\n\t\t\tif (this.hasEntryModule() === otherChunk.hasEntryModule()) {\n\t\t\t\t// When both chunks have entry modules or none have one, use\n\t\t\t\t// shortest name\n\t\t\t\tif (this.name.length !== otherChunk.name.length) {\n\t\t\t\t\tthis.name =\n\t\t\t\t\t\tthis.name.length < otherChunk.name.length\n\t\t\t\t\t\t\t? this.name\n\t\t\t\t\t\t\t: otherChunk.name;\n\t\t\t\t} else {\n\t\t\t\t\tthis.name = this.name < otherChunk.name ? this.name : otherChunk.name;\n\t\t\t\t}\n\t\t\t} else if (otherChunk.hasEntryModule()) {\n\t\t\t\t// Pick the name of the chunk with the entry module\n\t\t\t\tthis.name = otherChunk.name;\n\t\t\t}\n\t\t} else if (otherChunk.name) {\n\t\t\tthis.name = otherChunk.name;\n\t\t}\n\n\t\t// Array.from is used here to create a clone, because moveModule modifies otherChunk._modules\n\t\tfor (const module of Array.from(otherChunk._modules)) {\n\t\t\totherChunk.moveModule(module, this);\n\t\t}\n\t\totherChunk._modules.clear();\n\n\t\tif (otherChunk.entryModule) {\n\t\t\tthis.entryModule = otherChunk.entryModule;\n\t\t}\n\n\t\tfor (const chunkGroup of otherChunk._groups) {\n\t\t\tchunkGroup.replaceChunk(otherChunk, this);\n\t\t\tthis.addGroup(chunkGroup);\n\t\t}\n\t\totherChunk._groups.clear();\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Chunk} newChunk the new chunk that will be split out of the current chunk\n\t * @returns {void}\n\t */\n\tsplit(newChunk) {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tchunkGroup.insertChunk(newChunk, this);\n\t\t\tnewChunk.addGroup(chunkGroup);\n\t\t}\n\t}\n\n\tisEmpty() {\n\t\treturn this._modules.size === 0;\n\t}\n\n\tupdateHash(hash) {\n\t\thash.update(`${this.id} `);\n\t\thash.update(this.ids ? this.ids.join(\",\") : \"\");\n\t\thash.update(`${this.name || \"\"} `);\n\t\tfor (const m of this._modules) {\n\t\t\thash.update(m.hash);\n\t\t}\n\t}\n\n\tcanBeIntegrated(otherChunk) {\n\t\tif (this.preventIntegration || otherChunk.preventIntegration) {\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * @param {Chunk} a chunk\n\t\t * @param {Chunk} b chunk\n\t\t * @returns {boolean} true, if a is always available when b is reached\n\t\t */\n\t\tconst isAvailable = (a, b) => {\n\t\t\tconst queue = new Set(b.groupsIterable);\n\t\t\tfor (const chunkGroup of queue) {\n\t\t\t\tif (a.isInGroup(chunkGroup)) continue;\n\t\t\t\tif (chunkGroup.isInitial()) return false;\n\t\t\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\t\t\tqueue.add(parent);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\tconst selfHasRuntime = this.hasRuntime();\n\t\tconst otherChunkHasRuntime = otherChunk.hasRuntime();\n\n\t\tif (selfHasRuntime !== otherChunkHasRuntime) {\n\t\t\tif (selfHasRuntime) {\n\t\t\t\treturn isAvailable(this, otherChunk);\n\t\t\t} else if (otherChunkHasRuntime) {\n\t\t\t\treturn isAvailable(otherChunk, this);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (this.hasEntryModule() || otherChunk.hasEntryModule()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t *\n\t * @param {number} size the size\n\t * @param {Object} options the options passed in\n\t * @returns {number} the multiplier returned\n\t */\n\taddMultiplierAndOverhead(size, options) {\n\t\tconst overhead =\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n\t\tconst multiplicator = this.canBeInitial()\n\t\t\t? options.entryChunkMultiplicator || 10\n\t\t\t: 1;\n\n\t\treturn size * multiplicator + overhead;\n\t}\n\n\t/**\n\t * @returns {number} the size of all modules\n\t */\n\tmodulesSize() {\n\t\treturn this._modules.getFromUnorderedCache(getModulesSize);\n\t}\n\n\t/**\n\t * @param {Object} options the size display options\n\t * @returns {number} the chunk size\n\t */\n\tsize(options = {}) {\n\t\treturn this.addMultiplierAndOverhead(this.modulesSize(), options);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @param {TODO} options the options for this function\n\t * @returns {number | false} the size, or false if it can't be integrated\n\t */\n\tintegratedSize(otherChunk, options) {\n\t\t// Chunk if it's possible to integrate this chunk\n\t\tif (!this.canBeIntegrated(otherChunk)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet integratedModulesSize = this.modulesSize();\n\t\t// only count modules that do not exist in this chunk!\n\t\tfor (const otherModule of otherChunk._modules) {\n\t\t\tif (!this._modules.has(otherModule)) {\n\t\t\t\tintegratedModulesSize += otherModule.size();\n\t\t\t}\n\t\t}\n\n\t\treturn this.addMultiplierAndOverhead(integratedModulesSize, options);\n\t}\n\n\t/**\n\t * @param {function(Module, Module): -1|0|1=} sortByFn a predicate function used to sort modules\n\t * @returns {void}\n\t */\n\tsortModules(sortByFn) {\n\t\tthis._modules.sortWith(sortByFn || sortModuleById);\n\t}\n\n\tsortItems() {\n\t\tthis.sortModules();\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the async chunks\n\t */\n\tgetAllAsyncChunks() {\n\t\tconst queue = new Set();\n\t\tconst chunks = new Set();\n\n\t\tconst initialChunks = intersect(\n\t\t\tArray.from(this.groupsIterable, g => new Set(g.chunks))\n\t\t);\n\n\t\tfor (const chunkGroup of this.groupsIterable) {\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tif (!initialChunks.has(chunk)) {\n\t\t\t\t\tchunks.add(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @typedef {Object} ChunkMaps\n\t * @property {Record<string|number, string>} hash\n\t * @property {Record<string|number, Record<string, string>>} contentHash\n\t * @property {Record<string|number, string>} name\n\t */\n\n\t/**\n\t * @param {boolean} realHash should the full hash or the rendered hash be used\n\t * @returns {ChunkMaps} the chunk map information\n\t */\n\tgetChunkMaps(realHash) {\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkHashMap = Object.create(null);\n\t\t/** @type {Record<string|number, Record<string, string>>} */\n\t\tconst chunkContentHashMap = Object.create(null);\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkNameMap = Object.create(null);\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\tchunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n\t\t\tfor (const key of Object.keys(chunk.contentHash)) {\n\t\t\t\tif (!chunkContentHashMap[key]) {\n\t\t\t\t\tchunkContentHashMap[key] = Object.create(null);\n\t\t\t\t}\n\t\t\t\tchunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n\t\t\t}\n\t\t\tif (chunk.name) {\n\t\t\t\tchunkNameMap[chunk.id] = chunk.name;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\thash: chunkHashMap,\n\t\t\tcontentHash: chunkContentHashMap,\n\t\t\tname: chunkNameMap\n\t\t};\n\t}\n\n\t/**\n\t * @returns {Record<string, Set<TODO>[]>} a record object of names to lists of child ids(?)\n\t */\n\tgetChildIdsByOrders() {\n\t\tconst lists = new Map();\n\t\tfor (const group of this.groupsIterable) {\n\t\t\tif (group.chunks[group.chunks.length - 1] === this) {\n\t\t\t\tfor (const childGroup of group.childrenIterable) {\n\t\t\t\t\t// TODO webpack 5 remove this check for options\n\t\t\t\t\tif (typeof childGroup.options === \"object\") {\n\t\t\t\t\t\tfor (const key of Object.keys(childGroup.options)) {\n\t\t\t\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\t\t\t\tconst name = key.substr(0, key.length - \"Order\".length);\n\t\t\t\t\t\t\t\tlet list = lists.get(name);\n\t\t\t\t\t\t\t\tif (list === undefined) lists.set(name, (list = []));\n\t\t\t\t\t\t\t\tlist.push({\n\t\t\t\t\t\t\t\t\torder: childGroup.options[key],\n\t\t\t\t\t\t\t\t\tgroup: childGroup\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst result = Object.create(null);\n\t\tfor (const [name, list] of lists) {\n\t\t\tlist.sort((a, b) => {\n\t\t\t\tconst cmp = b.order - a.order;\n\t\t\t\tif (cmp !== 0) return cmp;\n\t\t\t\t// TODO webpack 5 remove this check of compareTo\n\t\t\t\tif (a.group.compareTo) {\n\t\t\t\t\treturn a.group.compareTo(b.group);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t\tresult[name] = Array.from(\n\t\t\t\tlist.reduce((set, item) => {\n\t\t\t\t\tfor (const chunk of item.group.chunks) {\n\t\t\t\t\t\tset.add(chunk.id);\n\t\t\t\t\t}\n\t\t\t\t\treturn set;\n\t\t\t\t}, new Set())\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetChildIdsByOrdersMap(includeDirectChildren) {\n\t\tconst chunkMaps = Object.create(null);\n\n\t\tconst addChildIdsByOrdersToMap = chunk => {\n\t\t\tconst data = chunk.getChildIdsByOrders();\n\t\t\tfor (const key of Object.keys(data)) {\n\t\t\t\tlet chunkMap = chunkMaps[key];\n\t\t\t\tif (chunkMap === undefined) {\n\t\t\t\t\tchunkMaps[key] = chunkMap = Object.create(null);\n\t\t\t\t}\n\t\t\t\tchunkMap[chunk.id] = data[key];\n\t\t\t}\n\t\t};\n\n\t\tif (includeDirectChildren) {\n\t\t\tconst chunks = new Set();\n\t\t\tfor (const chunkGroup of this.groupsIterable) {\n\t\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\t\tchunks.add(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const chunk of chunks) {\n\t\t\t\taddChildIdsByOrdersToMap(chunk);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\taddChildIdsByOrdersToMap(chunk);\n\t\t}\n\n\t\treturn chunkMaps;\n\t}\n\n\t/**\n\t * @typedef {Object} ChunkModuleMaps\n\t * @property {Record<string|number, (string|number)[]>} id\n\t * @property {Record<string|number, string>} hash\n\t */\n\n\t/**\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @returns {ChunkModuleMaps} module map information\n\t */\n\tgetChunkModuleMaps(filterFn) {\n\t\t/** @type {Record<string|number, (string|number)[]>} */\n\t\tconst chunkModuleIdMap = Object.create(null);\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkModuleHashMap = Object.create(null);\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\t/** @type {(string|number)[]} */\n\t\t\tlet array;\n\t\t\tfor (const module of chunk.modulesIterable) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tchunkModuleIdMap[chunk.id] = array;\n\t\t\t\t\t}\n\t\t\t\t\tarray.push(module.id);\n\t\t\t\t\tchunkModuleHashMap[module.id] = module.renderedHash;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (array !== undefined) {\n\t\t\t\tarray.sort();\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tid: chunkModuleIdMap,\n\t\t\thash: chunkModuleHashMap\n\t\t};\n\t}\n\n\t/**\n\t *\n\t * @param {function(Module): boolean} filterFn predicate function used to filter modules\n\t * @param {function(Chunk): boolean} filterChunkFn predicate function used to filter chunks\n\t * @returns {boolean} return true if module exists in graph\n\t */\n\thasModuleInGraph(filterFn, filterChunkFn) {\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tconst chunksProcessed = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tif (!chunksProcessed.has(chunk)) {\n\t\t\t\t\tchunksProcessed.add(chunk);\n\t\t\t\t\tif (!filterChunkFn || filterChunkFn(chunk)) {\n\t\t\t\t\t\tfor (const module of chunk.modulesIterable) {\n\t\t\t\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\ttoString() {\n\t\treturn `Chunk[${Array.from(this._modules).join()}]`;\n\t}\n}\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"forEachModule\", {\n\tconfigurable: false,\n\tvalue: util.deprecate(\n\t\t/**\n\t\t * @deprecated\n\t\t * @this {Chunk}\n\t\t * @typedef {function(any, any, Set<any>): void} ForEachModuleCallback\n\t\t * @param {ForEachModuleCallback} fn Callback function\n\t\t * @returns {void}\n\t\t */\n\t\tfunction(fn) {\n\t\t\tthis._modules.forEach(fn);\n\t\t},\n\t\t\"Chunk.forEachModule: Use for(const module of chunk.modulesIterable) instead\"\n\t)\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"mapModules\", {\n\tconfigurable: false,\n\tvalue: util.deprecate(\n\t\t/**\n\t\t * @deprecated\n\t\t * @this {Chunk}\n\t\t * @typedef {function(any, number): any} MapModulesCallback\n\t\t * @param {MapModulesCallback} fn Callback function\n\t\t * @returns {TODO[]} result of mapped modules\n\t\t */\n\t\tfunction(fn) {\n\t\t\treturn Array.from(this._modules, fn);\n\t\t},\n\t\t\"Chunk.mapModules: Use Array.from(chunk.modulesIterable, fn) instead\"\n\t)\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"chunks\", {\n\tconfigurable: false,\n\tget() {\n\t\tthrow new Error(\"Chunk.chunks: Use ChunkGroup.getChildren() instead\");\n\t},\n\tset() {\n\t\tthrow new Error(\"Chunk.chunks: Use ChunkGroup.add/removeChild() instead\");\n\t}\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"parents\", {\n\tconfigurable: false,\n\tget() {\n\t\tthrow new Error(\"Chunk.parents: Use ChunkGroup.getParents() instead\");\n\t},\n\tset() {\n\t\tthrow new Error(\"Chunk.parents: Use ChunkGroup.add/removeParent() instead\");\n\t}\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"blocks\", {\n\tconfigurable: false,\n\tget() {\n\t\tthrow new Error(\"Chunk.blocks: Use ChunkGroup.getBlocks() instead\");\n\t},\n\tset() {\n\t\tthrow new Error(\"Chunk.blocks: Use ChunkGroup.add/removeBlock() instead\");\n\t}\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"entrypoints\", {\n\tconfigurable: false,\n\tget() {\n\t\tthrow new Error(\n\t\t\t\"Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead\"\n\t\t);\n\t},\n\tset() {\n\t\tthrow new Error(\"Chunk.entrypoints: Use Chunks.addGroup instead\");\n\t}\n});\n\nmodule.exports = Chunk;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}