{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\nconst ParserHelpers = require(\"./ParserHelpers\");\nconst NullFactory = require(\"./NullFactory\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Parser\")} Parser */\n/** @typedef {null|undefined|RegExp|Function|string|number} CodeValuePrimitive */\n/** @typedef {CodeValuePrimitive|Record<string, CodeValuePrimitive>|RuntimeValue} CodeValue */\n\nclass RuntimeValue {\n  constructor(fn, fileDependencies) {\n    this.fn = fn;\n    this.fileDependencies = fileDependencies || [];\n  }\n  exec(parser) {\n    if (this.fileDependencies === true) {\n      parser.state.module.buildInfo.cacheable = false;\n    } else {\n      for (const fileDependency of this.fileDependencies) {\n        parser.state.module.buildInfo.fileDependencies.add(fileDependency);\n      }\n    }\n    return this.fn({\n      module: parser.state.module\n    });\n  }\n}\nconst stringifyObj = (obj, parser) => {\n  return \"Object({\" + Object.keys(obj).map(key => {\n    const code = obj[key];\n    return JSON.stringify(key) + \":\" + toCode(code, parser);\n  }).join(\",\") + \"})\";\n};\n\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {Parser} parser Parser\n * @returns {string} code converted to string that evaluates\n */\nconst toCode = (code, parser) => {\n  if (code === null) {\n    return \"null\";\n  }\n  if (code === undefined) {\n    return \"undefined\";\n  }\n  if (code instanceof RuntimeValue) {\n    return toCode(code.exec(parser), parser);\n  }\n  if (code instanceof RegExp && code.toString) {\n    return code.toString();\n  }\n  if (typeof code === \"function\" && code.toString) {\n    return \"(\" + code.toString() + \")\";\n  }\n  if (typeof code === \"object\") {\n    return stringifyObj(code, parser);\n  }\n  return code + \"\";\n};\nclass DefinePlugin {\n  /**\n   * Create a new define plugin\n   * @param {Record<string, CodeValue>} definitions A map of global object definitions\n   */\n  constructor(definitions) {\n    this.definitions = definitions;\n  }\n  static runtimeValue(fn, fileDependencies) {\n    return new RuntimeValue(fn, fileDependencies);\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler Webpack compiler\n   * @returns {void}\n   */\n  apply(compiler) {\n    const definitions = this.definitions;\n    compiler.hooks.compilation.tap(\"DefinePlugin\", (compilation, {\n      normalModuleFactory\n    }) => {\n      compilation.dependencyFactories.set(ConstDependency, new NullFactory());\n      compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n\n      /**\n       * Handler\n       * @param {Parser} parser Parser\n       * @returns {void}\n       */\n      const handler = parser => {\n        /**\n         * Walk definitions\n         * @param {Object} definitions Definitions map\n         * @param {string} prefix Prefix string\n         * @returns {void}\n         */\n        const walkDefinitions = (definitions, prefix) => {\n          Object.keys(definitions).forEach(key => {\n            const code = definitions[key];\n            if (code && typeof code === \"object\" && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) {\n              walkDefinitions(code, prefix + key + \".\");\n              applyObjectDefine(prefix + key, code);\n              return;\n            }\n            applyDefineKey(prefix, key);\n            applyDefine(prefix + key, code);\n          });\n        };\n\n        /**\n         * Apply define key\n         * @param {string} prefix Prefix\n         * @param {string} key Key\n         * @returns {void}\n         */\n        const applyDefineKey = (prefix, key) => {\n          const splittedKey = key.split(\".\");\n          splittedKey.slice(1).forEach((_, i) => {\n            const fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n            parser.hooks.canRename.for(fullKey).tap(\"DefinePlugin\", ParserHelpers.approve);\n          });\n        };\n\n        /**\n         * Apply Code\n         * @param {string} key Key\n         * @param {CodeValue} code Code\n         * @returns {void}\n         */\n        const applyDefine = (key, code) => {\n          const isTypeof = /^typeof\\s+/.test(key);\n          if (isTypeof) key = key.replace(/^typeof\\s+/, \"\");\n          let recurse = false;\n          let recurseTypeof = false;\n          if (!isTypeof) {\n            parser.hooks.canRename.for(key).tap(\"DefinePlugin\", ParserHelpers.approve);\n            parser.hooks.evaluateIdentifier.for(key).tap(\"DefinePlugin\", expr => {\n              /**\n               * this is needed in case there is a recursion in the DefinePlugin\n               * to prevent an endless recursion\n               * e.g.: new DefinePlugin({\n               * \"a\": \"b\",\n               * \"b\": \"a\"\n               * });\n               */\n              if (recurse) return;\n              recurse = true;\n              const res = parser.evaluate(toCode(code, parser));\n              recurse = false;\n              res.setRange(expr.range);\n              return res;\n            });\n            parser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n              const strCode = toCode(code, parser);\n              if (/__webpack_require__/.test(strCode)) {\n                return ParserHelpers.toConstantDependencyWithWebpackRequire(parser, strCode)(expr);\n              } else {\n                return ParserHelpers.toConstantDependency(parser, strCode)(expr);\n              }\n            });\n          }\n          parser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n            /**\n             * this is needed in case there is a recursion in the DefinePlugin\n             * to prevent an endless recursion\n             * e.g.: new DefinePlugin({\n             * \"typeof a\": \"typeof b\",\n             * \"typeof b\": \"typeof a\"\n             * });\n             */\n            if (recurseTypeof) return;\n            recurseTypeof = true;\n            const typeofCode = isTypeof ? toCode(code, parser) : \"typeof (\" + toCode(code, parser) + \")\";\n            const res = parser.evaluate(typeofCode);\n            recurseTypeof = false;\n            res.setRange(expr.range);\n            return res;\n          });\n          parser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n            const typeofCode = isTypeof ? toCode(code, parser) : \"typeof (\" + toCode(code, parser) + \")\";\n            const res = parser.evaluate(typeofCode);\n            if (!res.isString()) return;\n            return ParserHelpers.toConstantDependency(parser, JSON.stringify(res.string)).bind(parser)(expr);\n          });\n        };\n\n        /**\n         * Apply Object\n         * @param {string} key Key\n         * @param {Object} obj Object\n         * @returns {void}\n         */\n        const applyObjectDefine = (key, obj) => {\n          parser.hooks.canRename.for(key).tap(\"DefinePlugin\", ParserHelpers.approve);\n          parser.hooks.evaluateIdentifier.for(key).tap(\"DefinePlugin\", expr => new BasicEvaluatedExpression().setTruthy().setRange(expr.range));\n          parser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n            return ParserHelpers.evaluateToString(\"object\")(expr);\n          });\n          parser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n            const strCode = stringifyObj(obj, parser);\n            if (/__webpack_require__/.test(strCode)) {\n              return ParserHelpers.toConstantDependencyWithWebpackRequire(parser, strCode)(expr);\n            } else {\n              return ParserHelpers.toConstantDependency(parser, strCode)(expr);\n            }\n          });\n          parser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n            return ParserHelpers.toConstantDependency(parser, JSON.stringify(\"object\"))(expr);\n          });\n        };\n        walkDefinitions(definitions, \"\");\n      };\n      normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"DefinePlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"DefinePlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"DefinePlugin\", handler);\n    });\n  }\n}\nmodule.exports = DefinePlugin;","map":{"version":3,"names":["ConstDependency","require","BasicEvaluatedExpression","ParserHelpers","NullFactory","RuntimeValue","constructor","fn","fileDependencies","exec","parser","state","module","buildInfo","cacheable","fileDependency","add","stringifyObj","obj","Object","keys","map","key","code","JSON","stringify","toCode","join","undefined","RegExp","toString","DefinePlugin","definitions","runtimeValue","apply","compiler","hooks","compilation","tap","normalModuleFactory","dependencyFactories","set","dependencyTemplates","Template","handler","walkDefinitions","prefix","forEach","applyObjectDefine","applyDefineKey","applyDefine","splittedKey","split","slice","_","i","fullKey","canRename","for","approve","isTypeof","test","replace","recurse","recurseTypeof","evaluateIdentifier","expr","res","evaluate","setRange","range","expression","strCode","toConstantDependencyWithWebpackRequire","toConstantDependency","evaluateTypeof","typeofCode","typeof","isString","string","bind","setTruthy","evaluateToString","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/DefinePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\nconst ParserHelpers = require(\"./ParserHelpers\");\nconst NullFactory = require(\"./NullFactory\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Parser\")} Parser */\n/** @typedef {null|undefined|RegExp|Function|string|number} CodeValuePrimitive */\n/** @typedef {CodeValuePrimitive|Record<string, CodeValuePrimitive>|RuntimeValue} CodeValue */\n\nclass RuntimeValue {\n\tconstructor(fn, fileDependencies) {\n\t\tthis.fn = fn;\n\t\tthis.fileDependencies = fileDependencies || [];\n\t}\n\n\texec(parser) {\n\t\tif (this.fileDependencies === true) {\n\t\t\tparser.state.module.buildInfo.cacheable = false;\n\t\t} else {\n\t\t\tfor (const fileDependency of this.fileDependencies) {\n\t\t\t\tparser.state.module.buildInfo.fileDependencies.add(fileDependency);\n\t\t\t}\n\t\t}\n\n\t\treturn this.fn({ module: parser.state.module });\n\t}\n}\n\nconst stringifyObj = (obj, parser) => {\n\treturn (\n\t\t\"Object({\" +\n\t\tObject.keys(obj)\n\t\t\t.map(key => {\n\t\t\t\tconst code = obj[key];\n\t\t\t\treturn JSON.stringify(key) + \":\" + toCode(code, parser);\n\t\t\t})\n\t\t\t.join(\",\") +\n\t\t\"})\"\n\t);\n};\n\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {Parser} parser Parser\n * @returns {string} code converted to string that evaluates\n */\nconst toCode = (code, parser) => {\n\tif (code === null) {\n\t\treturn \"null\";\n\t}\n\tif (code === undefined) {\n\t\treturn \"undefined\";\n\t}\n\tif (code instanceof RuntimeValue) {\n\t\treturn toCode(code.exec(parser), parser);\n\t}\n\tif (code instanceof RegExp && code.toString) {\n\t\treturn code.toString();\n\t}\n\tif (typeof code === \"function\" && code.toString) {\n\t\treturn \"(\" + code.toString() + \")\";\n\t}\n\tif (typeof code === \"object\") {\n\t\treturn stringifyObj(code, parser);\n\t}\n\treturn code + \"\";\n};\n\nclass DefinePlugin {\n\t/**\n\t * Create a new define plugin\n\t * @param {Record<string, CodeValue>} definitions A map of global object definitions\n\t */\n\tconstructor(definitions) {\n\t\tthis.definitions = definitions;\n\t}\n\n\tstatic runtimeValue(fn, fileDependencies) {\n\t\treturn new RuntimeValue(fn, fileDependencies);\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler Webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst definitions = this.definitions;\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"DefinePlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyFactories.set(ConstDependency, new NullFactory());\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tConstDependency,\n\t\t\t\t\tnew ConstDependency.Template()\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * Handler\n\t\t\t\t * @param {Parser} parser Parser\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst handler = parser => {\n\t\t\t\t\t/**\n\t\t\t\t\t * Walk definitions\n\t\t\t\t\t * @param {Object} definitions Definitions map\n\t\t\t\t\t * @param {string} prefix Prefix string\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst walkDefinitions = (definitions, prefix) => {\n\t\t\t\t\t\tObject.keys(definitions).forEach(key => {\n\t\t\t\t\t\t\tconst code = definitions[key];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcode &&\n\t\t\t\t\t\t\t\ttypeof code === \"object\" &&\n\t\t\t\t\t\t\t\t!(code instanceof RuntimeValue) &&\n\t\t\t\t\t\t\t\t!(code instanceof RegExp)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\twalkDefinitions(code, prefix + key + \".\");\n\t\t\t\t\t\t\t\tapplyObjectDefine(prefix + key, code);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapplyDefineKey(prefix, key);\n\t\t\t\t\t\t\tapplyDefine(prefix + key, code);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply define key\n\t\t\t\t\t * @param {string} prefix Prefix\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefineKey = (prefix, key) => {\n\t\t\t\t\t\tconst splittedKey = key.split(\".\");\n\t\t\t\t\t\tsplittedKey.slice(1).forEach((_, i) => {\n\t\t\t\t\t\t\tconst fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n\t\t\t\t\t\t\tparser.hooks.canRename\n\t\t\t\t\t\t\t\t.for(fullKey)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", ParserHelpers.approve);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Code\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {CodeValue} code Code\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefine = (key, code) => {\n\t\t\t\t\t\tconst isTypeof = /^typeof\\s+/.test(key);\n\t\t\t\t\t\tif (isTypeof) key = key.replace(/^typeof\\s+/, \"\");\n\t\t\t\t\t\tlet recurse = false;\n\t\t\t\t\t\tlet recurseTypeof = false;\n\t\t\t\t\t\tif (!isTypeof) {\n\t\t\t\t\t\t\tparser.hooks.canRename\n\t\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", ParserHelpers.approve);\n\t\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t\t\t * \"a\": \"b\",\n\t\t\t\t\t\t\t\t\t * \"b\": \"a\"\n\t\t\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\tif (recurse) return;\n\t\t\t\t\t\t\t\t\trecurse = true;\n\t\t\t\t\t\t\t\t\tconst res = parser.evaluate(toCode(code, parser));\n\t\t\t\t\t\t\t\t\trecurse = false;\n\t\t\t\t\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t\tconst strCode = toCode(code, parser);\n\t\t\t\t\t\t\t\tif (/__webpack_require__/.test(strCode)) {\n\t\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependencyWithWebpackRequire(\n\t\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t * \"typeof a\": \"typeof b\",\n\t\t\t\t\t\t\t * \"typeof b\": \"typeof a\"\n\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (recurseTypeof) return;\n\t\t\t\t\t\t\trecurseTypeof = true;\n\t\t\t\t\t\t\tconst typeofCode = isTypeof\n\t\t\t\t\t\t\t\t? toCode(code, parser)\n\t\t\t\t\t\t\t\t: \"typeof (\" + toCode(code, parser) + \")\";\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\trecurseTypeof = false;\n\t\t\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\tconst typeofCode = isTypeof\n\t\t\t\t\t\t\t\t? toCode(code, parser)\n\t\t\t\t\t\t\t\t: \"typeof (\" + toCode(code, parser) + \")\";\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\tif (!res.isString()) return;\n\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tJSON.stringify(res.string)\n\t\t\t\t\t\t\t).bind(parser)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Object\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {Object} obj Object\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyObjectDefine = (key, obj) => {\n\t\t\t\t\t\tparser.hooks.canRename\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\"DefinePlugin\", ParserHelpers.approve);\n\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\"DefinePlugin\", expr =>\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression().setTruthy().setRange(expr.range)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tparser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\treturn ParserHelpers.evaluateToString(\"object\")(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\tconst strCode = stringifyObj(obj, parser);\n\n\t\t\t\t\t\t\tif (/__webpack_require__/.test(strCode)) {\n\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependencyWithWebpackRequire(\n\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tJSON.stringify(\"object\")\n\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\twalkDefinitions(definitions, \"\");\n\t\t\t\t};\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/dynamic\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/esm\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = DefinePlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}