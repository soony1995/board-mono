{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction globToRegExp(glob) {\n  // * [^\\\\\\/]*\n  // /**/ /.+/\n  // ^* \\./.+ (concord special)\n  // ? [^\\\\\\/]\n  // [!...] [^...]\n  // [^...] [^...]\n  // / [\\\\\\/]\n  // {...,...} (...|...)\n  // ?(...|...) (...|...)?\n  // +(...|...) (...|...)+\n  // *(...|...) (...|...)*\n  // @(...|...) (...|...)\n  if (/^\\(.+\\)$/.test(glob)) {\n    // allow to pass an RegExp in brackets\n    return new RegExp(glob.substr(1, glob.length - 2));\n  }\n  const tokens = tokenize(glob);\n  const process = createRoot();\n  const regExpStr = tokens.map(process).join(\"\");\n  return new RegExp(\"^\" + regExpStr + \"$\");\n}\nconst SIMPLE_TOKENS = {\n  \"@(\": \"one\",\n  \"?(\": \"zero-one\",\n  \"+(\": \"one-many\",\n  \"*(\": \"zero-many\",\n  \"|\": \"segment-sep\",\n  \"/**/\": \"any-path-segments\",\n  \"**\": \"any-path\",\n  \"*\": \"any-path-segment\",\n  \"?\": \"any-char\",\n  \"{\": \"or\",\n  \"/\": \"path-sep\",\n  \",\": \"comma\",\n  \")\": \"closing-segment\",\n  \"}\": \"closing-or\"\n};\nfunction tokenize(glob) {\n  return glob.split(/([@?+*]\\(|\\/\\*\\*\\/|\\*\\*|[?*]|\\[[!^]?(?:[^\\]\\\\]|\\\\.)+\\]|\\{|,|\\/|[|)}])/g).map(item => {\n    if (!item) return null;\n    const t = SIMPLE_TOKENS[item];\n    if (t) {\n      return {\n        type: t\n      };\n    }\n    if (item[0] === \"[\") {\n      if (item[1] === \"^\" || item[1] === \"!\") {\n        return {\n          type: \"inverted-char-set\",\n          value: item.substr(2, item.length - 3)\n        };\n      } else {\n        return {\n          type: \"char-set\",\n          value: item.substr(1, item.length - 2)\n        };\n      }\n    }\n    return {\n      type: \"string\",\n      value: item\n    };\n  }).filter(Boolean).concat({\n    type: \"end\"\n  });\n}\nfunction createRoot() {\n  const inOr = [];\n  const process = createSeqment();\n  let initial = true;\n  return function (token) {\n    switch (token.type) {\n      case \"or\":\n        inOr.push(initial);\n        return \"(\";\n      case \"comma\":\n        if (inOr.length) {\n          initial = inOr[inOr.length - 1];\n          return \"|\";\n        } else {\n          return process({\n            type: \"string\",\n            value: \",\"\n          }, initial);\n        }\n      case \"closing-or\":\n        if (inOr.length === 0) throw new Error(\"Unmatched '}'\");\n        inOr.pop();\n        return \")\";\n      case \"end\":\n        if (inOr.length) throw new Error(\"Unmatched '{'\");\n        return process(token, initial);\n      default:\n        {\n          const result = process(token, initial);\n          initial = false;\n          return result;\n        }\n    }\n  };\n}\nfunction createSeqment() {\n  const inSeqment = [];\n  const process = createSimple();\n  return function (token, initial) {\n    switch (token.type) {\n      case \"one\":\n      case \"one-many\":\n      case \"zero-many\":\n      case \"zero-one\":\n        inSeqment.push(token.type);\n        return \"(\";\n      case \"segment-sep\":\n        if (inSeqment.length) {\n          return \"|\";\n        } else {\n          return process({\n            type: \"string\",\n            value: \"|\"\n          }, initial);\n        }\n      case \"closing-segment\":\n        {\n          const segment = inSeqment.pop();\n          switch (segment) {\n            case \"one\":\n              return \")\";\n            case \"one-many\":\n              return \")+\";\n            case \"zero-many\":\n              return \")*\";\n            case \"zero-one\":\n              return \")?\";\n          }\n          throw new Error(\"Unexcepted segment \" + segment);\n        }\n      case \"end\":\n        if (inSeqment.length > 0) {\n          throw new Error(\"Unmatched segment, missing ')'\");\n        }\n        return process(token, initial);\n      default:\n        return process(token, initial);\n    }\n  };\n}\nfunction createSimple() {\n  return function (token, initial) {\n    switch (token.type) {\n      case \"path-sep\":\n        return \"[\\\\\\\\/]+\";\n      case \"any-path-segments\":\n        return \"[\\\\\\\\/]+(?:(.+)[\\\\\\\\/]+)?\";\n      case \"any-path\":\n        return \"(.*)\";\n      case \"any-path-segment\":\n        if (initial) {\n          return \"\\\\.[\\\\\\\\/]+(?:.*[\\\\\\\\/]+)?([^\\\\\\\\/]+)\";\n        } else {\n          return \"([^\\\\\\\\/]*)\";\n        }\n      case \"any-char\":\n        return \"[^\\\\\\\\/]\";\n      case \"inverted-char-set\":\n        return \"[^\" + token.value + \"]\";\n      case \"char-set\":\n        return \"[\" + token.value + \"]\";\n      case \"string\":\n        return token.value.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n      case \"end\":\n        return \"\";\n      default:\n        throw new Error(\"Unsupported token '\" + token.type + \"'\");\n    }\n  };\n}\nexports.globToRegExp = globToRegExp;","map":{"version":3,"names":["globToRegExp","glob","test","RegExp","substr","length","tokens","tokenize","process","createRoot","regExpStr","map","join","SIMPLE_TOKENS","split","item","t","type","value","filter","Boolean","concat","inOr","createSeqment","initial","token","push","Error","pop","result","inSeqment","createSimple","segment","replace","exports"],"sources":["/home/soon/bulletin-board/node_modules/enhanced-resolve/lib/globToRegExp.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction globToRegExp(glob) {\n\t// * [^\\\\\\/]*\n\t// /**/ /.+/\n\t// ^* \\./.+ (concord special)\n\t// ? [^\\\\\\/]\n\t// [!...] [^...]\n\t// [^...] [^...]\n\t// / [\\\\\\/]\n\t// {...,...} (...|...)\n\t// ?(...|...) (...|...)?\n\t// +(...|...) (...|...)+\n\t// *(...|...) (...|...)*\n\t// @(...|...) (...|...)\n\tif (/^\\(.+\\)$/.test(glob)) {\n\t\t// allow to pass an RegExp in brackets\n\t\treturn new RegExp(glob.substr(1, glob.length - 2));\n\t}\n\tconst tokens = tokenize(glob);\n\tconst process = createRoot();\n\tconst regExpStr = tokens.map(process).join(\"\");\n\treturn new RegExp(\"^\" + regExpStr + \"$\");\n}\n\nconst SIMPLE_TOKENS = {\n\t\"@(\": \"one\",\n\t\"?(\": \"zero-one\",\n\t\"+(\": \"one-many\",\n\t\"*(\": \"zero-many\",\n\t\"|\": \"segment-sep\",\n\t\"/**/\": \"any-path-segments\",\n\t\"**\": \"any-path\",\n\t\"*\": \"any-path-segment\",\n\t\"?\": \"any-char\",\n\t\"{\": \"or\",\n\t\"/\": \"path-sep\",\n\t\",\": \"comma\",\n\t\")\": \"closing-segment\",\n\t\"}\": \"closing-or\"\n};\n\nfunction tokenize(glob) {\n\treturn glob\n\t\t.split(\n\t\t\t/([@?+*]\\(|\\/\\*\\*\\/|\\*\\*|[?*]|\\[[!^]?(?:[^\\]\\\\]|\\\\.)+\\]|\\{|,|\\/|[|)}])/g\n\t\t)\n\t\t.map(item => {\n\t\t\tif (!item) return null;\n\t\t\tconst t = SIMPLE_TOKENS[item];\n\t\t\tif (t) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: t\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (item[0] === \"[\") {\n\t\t\t\tif (item[1] === \"^\" || item[1] === \"!\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"inverted-char-set\",\n\t\t\t\t\t\tvalue: item.substr(2, item.length - 3)\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"char-set\",\n\t\t\t\t\t\tvalue: item.substr(1, item.length - 2)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: \"string\",\n\t\t\t\tvalue: item\n\t\t\t};\n\t\t})\n\t\t.filter(Boolean)\n\t\t.concat({\n\t\t\ttype: \"end\"\n\t\t});\n}\n\nfunction createRoot() {\n\tconst inOr = [];\n\tconst process = createSeqment();\n\tlet initial = true;\n\treturn function(token) {\n\t\tswitch (token.type) {\n\t\t\tcase \"or\":\n\t\t\t\tinOr.push(initial);\n\t\t\t\treturn \"(\";\n\t\t\tcase \"comma\":\n\t\t\t\tif (inOr.length) {\n\t\t\t\t\tinitial = inOr[inOr.length - 1];\n\t\t\t\t\treturn \"|\";\n\t\t\t\t} else {\n\t\t\t\t\treturn process(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tvalue: \",\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tinitial\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\tcase \"closing-or\":\n\t\t\t\tif (inOr.length === 0) throw new Error(\"Unmatched '}'\");\n\t\t\t\tinOr.pop();\n\t\t\t\treturn \")\";\n\t\t\tcase \"end\":\n\t\t\t\tif (inOr.length) throw new Error(\"Unmatched '{'\");\n\t\t\t\treturn process(token, initial);\n\t\t\tdefault: {\n\t\t\t\tconst result = process(token, initial);\n\t\t\t\tinitial = false;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction createSeqment() {\n\tconst inSeqment = [];\n\tconst process = createSimple();\n\treturn function(token, initial) {\n\t\tswitch (token.type) {\n\t\t\tcase \"one\":\n\t\t\tcase \"one-many\":\n\t\t\tcase \"zero-many\":\n\t\t\tcase \"zero-one\":\n\t\t\t\tinSeqment.push(token.type);\n\t\t\t\treturn \"(\";\n\t\t\tcase \"segment-sep\":\n\t\t\t\tif (inSeqment.length) {\n\t\t\t\t\treturn \"|\";\n\t\t\t\t} else {\n\t\t\t\t\treturn process(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tvalue: \"|\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tinitial\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\tcase \"closing-segment\": {\n\t\t\t\tconst segment = inSeqment.pop();\n\t\t\t\tswitch (segment) {\n\t\t\t\t\tcase \"one\":\n\t\t\t\t\t\treturn \")\";\n\t\t\t\t\tcase \"one-many\":\n\t\t\t\t\t\treturn \")+\";\n\t\t\t\t\tcase \"zero-many\":\n\t\t\t\t\t\treturn \")*\";\n\t\t\t\t\tcase \"zero-one\":\n\t\t\t\t\t\treturn \")?\";\n\t\t\t\t}\n\t\t\t\tthrow new Error(\"Unexcepted segment \" + segment);\n\t\t\t}\n\t\t\tcase \"end\":\n\t\t\t\tif (inSeqment.length > 0) {\n\t\t\t\t\tthrow new Error(\"Unmatched segment, missing ')'\");\n\t\t\t\t}\n\t\t\t\treturn process(token, initial);\n\t\t\tdefault:\n\t\t\t\treturn process(token, initial);\n\t\t}\n\t};\n}\n\nfunction createSimple() {\n\treturn function(token, initial) {\n\t\tswitch (token.type) {\n\t\t\tcase \"path-sep\":\n\t\t\t\treturn \"[\\\\\\\\/]+\";\n\t\t\tcase \"any-path-segments\":\n\t\t\t\treturn \"[\\\\\\\\/]+(?:(.+)[\\\\\\\\/]+)?\";\n\t\t\tcase \"any-path\":\n\t\t\t\treturn \"(.*)\";\n\t\t\tcase \"any-path-segment\":\n\t\t\t\tif (initial) {\n\t\t\t\t\treturn \"\\\\.[\\\\\\\\/]+(?:.*[\\\\\\\\/]+)?([^\\\\\\\\/]+)\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"([^\\\\\\\\/]*)\";\n\t\t\t\t}\n\t\t\tcase \"any-char\":\n\t\t\t\treturn \"[^\\\\\\\\/]\";\n\t\t\tcase \"inverted-char-set\":\n\t\t\t\treturn \"[^\" + token.value + \"]\";\n\t\t\tcase \"char-set\":\n\t\t\t\treturn \"[\" + token.value + \"]\";\n\t\t\tcase \"string\":\n\t\t\t\treturn token.value.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n\t\t\tcase \"end\":\n\t\t\t\treturn \"\";\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unsupported token '\" + token.type + \"'\");\n\t\t}\n\t};\n}\n\nexports.globToRegExp = globToRegExp;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}