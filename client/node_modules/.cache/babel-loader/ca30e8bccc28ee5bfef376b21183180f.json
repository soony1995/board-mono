{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\nimport { codeFrameFromSource } from \"@webassemblyjs/helper-code-frame\";\nimport * as t from \"@webassemblyjs/ast\";\nimport { parse32I } from \"./number-literals\";\nimport { parseString } from \"./string-literals\";\nimport { tokens, keywords } from \"./tokenizer\";\nfunction hasPlugin(name) {\n  if (name !== \"wast\") throw new Error(\"unknow plugin\");\n  return true;\n}\nfunction isKeyword(token, id) {\n  return token.type === tokens.keyword && token.value === id;\n}\nfunction tokenToString(token) {\n  if (token.type === \"keyword\") {\n    return \"keyword (\".concat(token.value, \")\");\n  }\n  return token.type;\n}\nfunction identifierFromToken(token) {\n  var _token$loc = token.loc,\n    end = _token$loc.end,\n    start = _token$loc.start;\n  return t.withLoc(t.identifier(token.value), end, start);\n}\nexport function parse(tokensList, source) {\n  var current = 0;\n  var getUniqueName = t.getUniqueNameGenerator();\n  var state = {\n    registredExportedElements: []\n  }; // But this time we're going to use recursion instead of a `while` loop. So we\n  // define a `walk` function.\n\n  function walk() {\n    var token = tokensList[current];\n    function eatToken() {\n      token = tokensList[++current];\n    }\n    function getEndLoc() {\n      var currentToken = token;\n      if (typeof currentToken === \"undefined\") {\n        var lastToken = tokensList[tokensList.length - 1];\n        currentToken = lastToken;\n      }\n      return currentToken.loc.end;\n    }\n    function getStartLoc() {\n      return token.loc.start;\n    }\n    function eatTokenOfType(type) {\n      if (token.type !== type) {\n        throw new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"Assertion error: expected token of type \" + type + \", given \" + tokenToString(token));\n      }\n      eatToken();\n    }\n    function parseExportIndex(token) {\n      if (token.type === tokens.identifier) {\n        var index = identifierFromToken(token);\n        eatToken();\n        return index;\n      } else if (token.type === tokens.number) {\n        var _index = t.numberLiteralFromRaw(token.value);\n        eatToken();\n        return _index;\n      } else {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"unknown export index\" + \", given \" + tokenToString(token));\n        }();\n      }\n    }\n    function lookaheadAndCheck() {\n      var len = arguments.length;\n      for (var i = 0; i < len; i++) {\n        var tokenAhead = tokensList[current + i];\n        var expectedToken = i < 0 || arguments.length <= i ? undefined : arguments[i];\n        if (tokenAhead.type === \"keyword\") {\n          if (isKeyword(tokenAhead, expectedToken) === false) {\n            return false;\n          }\n        } else if (expectedToken !== tokenAhead.type) {\n          return false;\n        }\n      }\n      return true;\n    } // TODO(sven): there is probably a better way to do this\n    // can refactor it if it get out of hands\n\n    function maybeIgnoreComment() {\n      if (typeof token === \"undefined\") {\n        // Ignore\n        return;\n      }\n      while (token.type === tokens.comment) {\n        eatToken();\n        if (typeof token === \"undefined\") {\n          // Hit the end\n          break;\n        }\n      }\n    }\n    /**\n     * Parses a memory instruction\n     *\n     * WAST:\n     *\n     * memory:  ( memory <name>? <memory_sig> )\n     *          ( memory <name>? ( export <string> ) <...> )\n     *          ( memory <name>? ( import <string> <string> ) <memory_sig> )\n     *          ( memory <name>? ( export <string> )* ( data <string>* )\n     * memory_sig: <nat> <nat>?\n     *\n     */\n\n    function parseMemory() {\n      var id = t.identifier(getUniqueName(\"memory\"));\n      var limits = t.limit(0);\n      if (token.type === tokens.string || token.type === tokens.identifier) {\n        id = t.identifier(token.value);\n        eatToken();\n      } else {\n        id = t.withRaw(id, \"\"); // preserve anonymous\n      }\n      /**\n       * Maybe data\n       */\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.data)) {\n        eatToken(); // (\n\n        eatToken(); // data\n        // TODO(sven): do something with the data collected here\n\n        var stringInitializer = token.value;\n        eatTokenOfType(tokens.string); // Update limits accordingly\n\n        limits = t.limit(stringInitializer.length);\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * Maybe export\n       */\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n        eatToken(); // (\n\n        eatToken(); // export\n\n        if (token.type !== tokens.string) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Expected string in export\" + \", given \" + tokenToString(token));\n          }();\n        }\n        var _name = token.value;\n        eatToken();\n        state.registredExportedElements.push({\n          exportType: \"Memory\",\n          name: _name,\n          id: id\n        });\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * Memory signature\n       */\n\n      if (token.type === tokens.number) {\n        limits = t.limit(parse32I(token.value));\n        eatToken();\n        if (token.type === tokens.number) {\n          limits.max = parse32I(token.value);\n          eatToken();\n        }\n      }\n      return t.memory(limits, id);\n    }\n    /**\n     * Parses a data section\n     * https://webassembly.github.io/spec/core/text/modules.html#data-segments\n     *\n     * WAST:\n     *\n     * data:  ( data <index>? <offset> <string> )\n     */\n\n    function parseData() {\n      // optional memory index\n      var memidx = 0;\n      if (token.type === tokens.number) {\n        memidx = token.value;\n        eatTokenOfType(tokens.number); // .\n      }\n      eatTokenOfType(tokens.openParen);\n      var offset;\n      if (token.type === tokens.valtype) {\n        eatTokenOfType(tokens.valtype); // i32\n\n        eatTokenOfType(tokens.dot); // .\n\n        if (token.value !== \"const\") {\n          throw new Error(\"constant expression required\");\n        }\n        eatTokenOfType(tokens.name); // const\n\n        var numberLiteral = t.numberLiteralFromRaw(token.value, \"i32\");\n        offset = t.objectInstruction(\"const\", \"i32\", [numberLiteral]);\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      } else {\n        eatTokenOfType(tokens.name); // get_global\n\n        var _numberLiteral = t.numberLiteralFromRaw(token.value, \"i32\");\n        offset = t.instruction(\"get_global\", [_numberLiteral]);\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      }\n      var byteArray = parseString(token.value);\n      eatToken(); // \"string\"\n\n      return t.data(t.memIndexLiteral(memidx), offset, t.byteArray(byteArray));\n    }\n    /**\n     * Parses a table instruction\n     *\n     * WAST:\n     *\n     * table:   ( table <name>? <table_type> )\n     *          ( table <name>? ( export <string> ) <...> )\n     *          ( table <name>? ( import <string> <string> ) <table_type> )\n     *          ( table <name>? ( export <string> )* <elem_type> ( elem <var>* ) )\n     *\n     * table_type:  <nat> <nat>? <elem_type>\n     * elem_type: anyfunc\n     *\n     * elem:    ( elem <var>? (offset <instr>* ) <var>* )\n     *          ( elem <var>? <expr> <var>* )\n     */\n\n    function parseTable() {\n      var name = t.identifier(getUniqueName(\"table\"));\n      var limit = t.limit(0);\n      var elemIndices = [];\n      var elemType = \"anyfunc\";\n      if (token.type === tokens.string || token.type === tokens.identifier) {\n        name = identifierFromToken(token);\n        eatToken();\n      } else {\n        name = t.withRaw(name, \"\"); // preserve anonymous\n      }\n      while (token.type !== tokens.closeParen) {\n        /**\n         * Maybe export\n         */\n        if (lookaheadAndCheck(tokens.openParen, keywords.elem)) {\n          eatToken(); // (\n\n          eatToken(); // elem\n\n          while (token.type === tokens.identifier) {\n            elemIndices.push(t.identifier(token.value));\n            eatToken();\n          }\n          eatTokenOfType(tokens.closeParen);\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n          eatToken(); // (\n\n          eatToken(); // export\n\n          if (token.type !== tokens.string) {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Expected string in export\" + \", given \" + tokenToString(token));\n            }();\n          }\n          var exportName = token.value;\n          eatToken();\n          state.registredExportedElements.push({\n            exportType: \"Table\",\n            name: exportName,\n            id: name\n          });\n          eatTokenOfType(tokens.closeParen);\n        } else if (isKeyword(token, keywords.anyfunc)) {\n          // It's the default value, we can ignore it\n          eatToken(); // anyfunc\n        } else if (token.type === tokens.number) {\n          /**\n           * Table type\n           */\n          var min = parseInt(token.value);\n          eatToken();\n          if (token.type === tokens.number) {\n            var max = parseInt(token.value);\n            eatToken();\n            limit = t.limit(min, max);\n          } else {\n            limit = t.limit(min);\n          }\n          eatToken();\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n      if (elemIndices.length > 0) {\n        return t.table(elemType, limit, name, elemIndices);\n      } else {\n        return t.table(elemType, limit, name);\n      }\n    }\n    /**\n     * Parses an import statement\n     *\n     * WAST:\n     *\n     * import:  ( import <string> <string> <imkind> )\n     * imkind:  ( func <name>? <func_sig> )\n     *          ( global <name>? <global_sig> )\n     *          ( table <name>? <table_sig> )\n     *          ( memory <name>? <memory_sig> )\n     *\n     * global_sig: <type> | ( mut <type> )\n     */\n\n    function parseImport() {\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected a string, \" + token.type + \" given.\");\n      }\n      var moduleName = token.value;\n      eatToken();\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected a string, \" + token.type + \" given.\");\n      }\n      var name = token.value;\n      eatToken();\n      eatTokenOfType(tokens.openParen);\n      var descr;\n      if (isKeyword(token, keywords.func)) {\n        eatToken(); // keyword\n\n        var fnParams = [];\n        var fnResult = [];\n        var typeRef;\n        var fnName = t.identifier(getUniqueName(\"func\"));\n        if (token.type === tokens.identifier) {\n          fnName = identifierFromToken(token);\n          eatToken();\n        }\n        while (token.type === tokens.openParen) {\n          eatToken();\n          if (lookaheadAndCheck(keywords.type) === true) {\n            eatToken();\n            typeRef = parseTypeReference();\n          } else if (lookaheadAndCheck(keywords.param) === true) {\n            eatToken();\n            fnParams.push.apply(fnParams, _toConsumableArray(parseFuncParam()));\n          } else if (lookaheadAndCheck(keywords.result) === true) {\n            eatToken();\n            fnResult.push.apply(fnResult, _toConsumableArray(parseFuncResult()));\n          } else {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in import of type\" + \", given \" + tokenToString(token));\n            }();\n          }\n          eatTokenOfType(tokens.closeParen);\n        }\n        if (typeof fnName === \"undefined\") {\n          throw new Error(\"Imported function must have a name\");\n        }\n        descr = t.funcImportDescr(fnName, typeRef !== undefined ? typeRef : t.signature(fnParams, fnResult));\n      } else if (isKeyword(token, keywords.global)) {\n        eatToken(); // keyword\n\n        if (token.type === tokens.openParen) {\n          eatToken(); // (\n\n          eatTokenOfType(tokens.keyword); // mut keyword\n\n          var valtype = token.value;\n          eatToken();\n          descr = t.globalType(valtype, \"var\");\n          eatTokenOfType(tokens.closeParen);\n        } else {\n          var _valtype = token.value;\n          eatTokenOfType(tokens.valtype);\n          descr = t.globalType(_valtype, \"const\");\n        }\n      } else if (isKeyword(token, keywords.memory) === true) {\n        eatToken(); // Keyword\n\n        descr = parseMemory();\n      } else if (isKeyword(token, keywords.table) === true) {\n        eatToken(); // Keyword\n\n        descr = parseTable();\n      } else {\n        throw new Error(\"Unsupported import type: \" + tokenToString(token));\n      }\n      eatTokenOfType(tokens.closeParen);\n      return t.moduleImport(moduleName, name, descr);\n    }\n    /**\n     * Parses a block instruction\n     *\n     * WAST:\n     *\n     * expr: ( block <name>? <block_sig> <instr>* )\n     * instr: block <name>? <block_sig> <instr>* end <name>?\n     * block_sig : ( result <type>* )*\n     *\n     */\n\n    function parseBlock() {\n      var label = t.identifier(getUniqueName(\"block\"));\n      var blockResult = null;\n      var instr = [];\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n      while (token.type === tokens.openParen) {\n        eatToken();\n        if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatToken();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n          // Instruction\n          instr.push(parseFuncInstr());\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in block body of type\" + \", given \" + tokenToString(token));\n          }();\n        }\n        maybeIgnoreComment();\n        eatTokenOfType(tokens.closeParen);\n      }\n      return t.blockInstruction(label, instr, blockResult);\n    }\n    /**\n     * Parses a if instruction\n     *\n     * WAST:\n     *\n     * expr:\n     * ( if <name>? <block_sig> ( then <instr>* ) ( else <instr>* )? )\n     * ( if <name>? <block_sig> <expr>+ ( then <instr>* ) ( else <instr>* )? )\n     *\n     * instr:\n     * if <name>? <block_sig> <instr>* end <name>?\n     * if <name>? <block_sig> <instr>* else <name>? <instr>* end <name>?\n     *\n     * block_sig : ( result <type>* )*\n     *\n     */\n\n    function parseIf() {\n      var blockResult = null;\n      var label = t.identifier(getUniqueName(\"if\"));\n      var testInstrs = [];\n      var consequent = [];\n      var alternate = [];\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n      while (token.type === tokens.openParen) {\n        eatToken(); // (\n\n        /**\n         * Block signature\n         */\n\n        if (isKeyword(token, keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatTokenOfType(tokens.valtype);\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Then\n         */\n\n        if (isKeyword(token, keywords.then) === true) {\n          eatToken(); // then\n\n          while (token.type === tokens.openParen) {\n            eatToken(); // Instruction\n\n            if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n            ) {\n              consequent.push(parseFuncInstr());\n            } else {\n              throw function () {\n                return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in consequent body of type\" + \", given \" + tokenToString(token));\n              }();\n            }\n            eatTokenOfType(tokens.closeParen);\n          }\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Alternate\n         */\n\n        if (isKeyword(token, keywords.else)) {\n          eatToken(); // else\n\n          while (token.type === tokens.openParen) {\n            eatToken(); // Instruction\n\n            if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n            ) {\n              alternate.push(parseFuncInstr());\n            } else {\n              throw function () {\n                return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in alternate body of type\" + \", given \" + tokenToString(token));\n              }();\n            }\n            eatTokenOfType(tokens.closeParen);\n          }\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Test instruction\n         */\n\n        if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n          testInstrs.push(parseFuncInstr());\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in if body\" + \", given \" + tokenToString(token));\n        }();\n      }\n      return t.ifInstruction(label, testInstrs, blockResult, consequent, alternate);\n    }\n    /**\n     * Parses a loop instruction\n     *\n     * WAT:\n     *\n     * blockinstr :: 'loop' I:label rt:resulttype (in:instr*) 'end' id?\n     *\n     * WAST:\n     *\n     * instr     :: loop <name>? <block_sig> <instr>* end <name>?\n     * expr      :: ( loop <name>? <block_sig> <instr>* )\n     * block_sig :: ( result <type>* )*\n     *\n     */\n\n    function parseLoop() {\n      var label = t.identifier(getUniqueName(\"loop\"));\n      var blockResult;\n      var instr = [];\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n      while (token.type === tokens.openParen) {\n        eatToken();\n        if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatToken();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n          // Instruction\n          instr.push(parseFuncInstr());\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in loop body\" + \", given \" + tokenToString(token));\n          }();\n        }\n        eatTokenOfType(tokens.closeParen);\n      }\n      return t.loopInstruction(label, blockResult, instr);\n    }\n    function parseCallIndirect() {\n      var typeRef;\n      var params = [];\n      var results = [];\n      var instrs = [];\n      while (token.type !== tokens.closeParen) {\n        if (lookaheadAndCheck(tokens.openParen, keywords.type)) {\n          eatToken(); // (\n\n          eatToken(); // type\n\n          typeRef = parseTypeReference();\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.param)) {\n          eatToken(); // (\n\n          eatToken(); // param\n\n          /**\n           * Params can be empty:\n           * (params)`\n           */\n\n          if (token.type !== tokens.closeParen) {\n            params.push.apply(params, _toConsumableArray(parseFuncParam()));\n          }\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.result)) {\n          eatToken(); // (\n\n          eatToken(); // result\n\n          /**\n           * Results can be empty:\n           * (result)`\n           */\n\n          if (token.type !== tokens.closeParen) {\n            results.push.apply(results, _toConsumableArray(parseFuncResult()));\n          }\n        } else {\n          eatTokenOfType(tokens.openParen);\n          instrs.push(parseFuncInstr());\n        }\n        eatTokenOfType(tokens.closeParen);\n      }\n      return t.callIndirectInstruction(typeRef !== undefined ? typeRef : t.signature(params, results), instrs);\n    }\n    /**\n     * Parses an export instruction\n     *\n     * WAT:\n     *\n     * export:  ( export <string> <exkind> )\n     * exkind:  ( func <var> )\n     *          ( global <var> )\n     *          ( table <var> )\n     *          ( memory <var> )\n     * var:    <nat> | <name>\n     *\n     */\n\n    function parseExport() {\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected string after export, got: \" + token.type);\n      }\n      var name = token.value;\n      eatToken();\n      var moduleExportDescr = parseModuleExportDescr();\n      return t.moduleExport(name, moduleExportDescr);\n    }\n    function parseModuleExportDescr() {\n      var startLoc = getStartLoc();\n      var type = \"\";\n      var index;\n      eatTokenOfType(tokens.openParen);\n      while (token.type !== tokens.closeParen) {\n        if (isKeyword(token, keywords.func)) {\n          type = \"Func\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.table)) {\n          type = \"Table\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.global)) {\n          type = \"Global\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.memory)) {\n          type = \"Memory\";\n          eatToken();\n          index = parseExportIndex(token);\n        }\n        eatToken();\n      }\n      if (type === \"\") {\n        throw new Error(\"Unknown export type\");\n      }\n      if (index === undefined) {\n        throw new Error(\"Exported function must have a name\");\n      }\n      var node = t.moduleExportDescr(type, index);\n      var endLoc = getEndLoc();\n      eatTokenOfType(tokens.closeParen);\n      return t.withLoc(node, endLoc, startLoc);\n    }\n    function parseModule() {\n      var name = null;\n      var isBinary = false;\n      var isQuote = false;\n      var moduleFields = [];\n      if (token.type === tokens.identifier) {\n        name = token.value;\n        eatToken();\n      }\n      if (hasPlugin(\"wast\") && token.type === tokens.name && token.value === \"binary\") {\n        eatToken();\n        isBinary = true;\n      }\n      if (hasPlugin(\"wast\") && token.type === tokens.name && token.value === \"quote\") {\n        eatToken();\n        isQuote = true;\n      }\n      if (isBinary === true) {\n        var blob = [];\n        while (token.type === tokens.string) {\n          blob.push(token.value);\n          eatToken();\n          maybeIgnoreComment();\n        }\n        eatTokenOfType(tokens.closeParen);\n        return t.binaryModule(name, blob);\n      }\n      if (isQuote === true) {\n        var string = [];\n        while (token.type === tokens.string) {\n          string.push(token.value);\n          eatToken();\n        }\n        eatTokenOfType(tokens.closeParen);\n        return t.quoteModule(name, string);\n      }\n      while (token.type !== tokens.closeParen) {\n        moduleFields.push(walk());\n        if (state.registredExportedElements.length > 0) {\n          state.registredExportedElements.forEach(function (decl) {\n            moduleFields.push(t.moduleExport(decl.name, t.moduleExportDescr(decl.exportType, decl.id)));\n          });\n          state.registredExportedElements = [];\n        }\n        token = tokensList[current];\n      }\n      eatTokenOfType(tokens.closeParen);\n      return t.module(name, moduleFields);\n    }\n    /**\n     * Parses the arguments of an instruction\n     */\n\n    function parseFuncInstrArguments(signature) {\n      var args = [];\n      var namedArgs = {};\n      var signaturePtr = 0;\n      while (token.type === tokens.name || isKeyword(token, keywords.offset)) {\n        var key = token.value;\n        eatToken();\n        eatTokenOfType(tokens.equal);\n        var value = void 0;\n        if (token.type === tokens.number) {\n          value = t.numberLiteralFromRaw(token.value);\n        } else {\n          throw new Error(\"Unexpected type for argument: \" + token.type);\n        }\n        namedArgs[key] = value;\n        eatToken();\n      } // $FlowIgnore\n\n      var signatureLength = signature.vector ? Infinity : signature.length;\n      while (token.type !== tokens.closeParen && (\n      // $FlowIgnore\n      token.type === tokens.openParen || signaturePtr < signatureLength)) {\n        if (token.type === tokens.identifier) {\n          args.push(t.identifier(token.value));\n          eatToken();\n        } else if (token.type === tokens.valtype) {\n          // Handle locals\n          args.push(t.valtypeLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.string) {\n          args.push(t.stringLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.number) {\n          args.push(\n          // TODO(sven): refactor the type signature handling\n          // https://github.com/xtuc/webassemblyjs/pull/129 is a good start\n          t.numberLiteralFromRaw(token.value,\n          // $FlowIgnore\n          signature[signaturePtr] || \"f64\")); // $FlowIgnore\n\n          if (!signature.vector) {\n            ++signaturePtr;\n          }\n          eatToken();\n        } else if (token.type === tokens.openParen) {\n          /**\n           * Maybe some nested instructions\n           */\n          eatToken(); // Instruction\n\n          if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n          ) {\n            // $FlowIgnore\n            args.push(parseFuncInstr());\n          } else {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in nested instruction\" + \", given \" + tokenToString(token));\n            }();\n          }\n          if (token.type === tokens.closeParen) {\n            eatToken();\n          }\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in instruction argument\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n      return {\n        args: args,\n        namedArgs: namedArgs\n      };\n    }\n    /**\n     * Parses an instruction\n     *\n     * WAT:\n     *\n     * instr      :: plaininst\n     *               blockinstr\n     *\n     * blockinstr :: 'block' I:label rt:resulttype (in:instr*) 'end' id?\n     *               'loop' I:label rt:resulttype (in:instr*) 'end' id?\n     *               'if' I:label rt:resulttype (in:instr*) 'else' id? (in2:intr*) 'end' id?\n     *\n     * plaininst  :: 'unreachable'\n     *               'nop'\n     *               'br' l:labelidx\n     *               'br_if' l:labelidx\n     *               'br_table' l*:vec(labelidx) ln:labelidx\n     *               'return'\n     *               'call' x:funcidx\n     *               'call_indirect' x, I:typeuse\n     *\n     * WAST:\n     *\n     * instr:\n     *   <expr>\n     *   <op>\n     *   block <name>? <block_sig> <instr>* end <name>?\n     *   loop <name>? <block_sig> <instr>* end <name>?\n     *   if <name>? <block_sig> <instr>* end <name>?\n     *   if <name>? <block_sig> <instr>* else <name>? <instr>* end <name>?\n     *\n     * expr:\n     *   ( <op> )\n     *   ( <op> <expr>+ )\n     *   ( block <name>? <block_sig> <instr>* )\n     *   ( loop <name>? <block_sig> <instr>* )\n     *   ( if <name>? <block_sig> ( then <instr>* ) ( else <instr>* )? )\n     *   ( if <name>? <block_sig> <expr>+ ( then <instr>* ) ( else <instr>* )? )\n     *\n     * op:\n     *   unreachable\n     *   nop\n     *   br <var>\n     *   br_if <var>\n     *   br_table <var>+\n     *   return\n     *   call <var>\n     *   call_indirect <func_sig>\n     *   drop\n     *   select\n     *   get_local <var>\n     *   set_local <var>\n     *   tee_local <var>\n     *   get_global <var>\n     *   set_global <var>\n     *   <type>.load((8|16|32)_<sign>)? <offset>? <align>?\n     *   <type>.store(8|16|32)? <offset>? <align>?\n     *   current_memory\n     *   grow_memory\n     *   <type>.const <value>\n     *   <type>.<unop>\n     *   <type>.<binop>\n     *   <type>.<testop>\n     *   <type>.<relop>\n     *   <type>.<cvtop>/<type>\n     *\n     * func_type:   ( type <var> )? <param>* <result>*\n     */\n\n    function parseFuncInstr() {\n      var startLoc = getStartLoc();\n      maybeIgnoreComment();\n      /**\n       * A simple instruction\n       */\n\n      if (token.type === tokens.name || token.type === tokens.valtype) {\n        var _name2 = token.value;\n        var object;\n        eatToken();\n        if (token.type === tokens.dot) {\n          object = _name2;\n          eatToken();\n          if (token.type !== tokens.name) {\n            throw new TypeError(\"Unknown token: \" + token.type + \", name expected\");\n          }\n          _name2 = token.value;\n          eatToken();\n        }\n        if (token.type === tokens.closeParen) {\n          var _endLoc = token.loc.end;\n          if (typeof object === \"undefined\") {\n            return t.withLoc(t.instruction(_name2), _endLoc, startLoc);\n          } else {\n            return t.withLoc(t.objectInstruction(_name2, object, []), _endLoc, startLoc);\n          }\n        }\n        var signature = t.signatureForOpcode(object || \"\", _name2);\n        var _parseFuncInstrArgume = parseFuncInstrArguments(signature),\n          _args = _parseFuncInstrArgume.args,\n          _namedArgs = _parseFuncInstrArgume.namedArgs;\n        var endLoc = token.loc.end;\n        if (typeof object === \"undefined\") {\n          return t.withLoc(t.instruction(_name2, _args, _namedArgs), endLoc, startLoc);\n        } else {\n          return t.withLoc(t.objectInstruction(_name2, object, _args, _namedArgs), endLoc, startLoc);\n        }\n      } else if (isKeyword(token, keywords.loop)) {\n        /**\n         * Else a instruction with a keyword (loop or block)\n         */\n        eatToken(); // keyword\n\n        return parseLoop();\n      } else if (isKeyword(token, keywords.block)) {\n        eatToken(); // keyword\n\n        return parseBlock();\n      } else if (isKeyword(token, keywords.call_indirect)) {\n        eatToken(); // keyword\n\n        return parseCallIndirect();\n      } else if (isKeyword(token, keywords.call)) {\n        eatToken(); // keyword\n\n        var index;\n        if (token.type === tokens.identifier) {\n          index = identifierFromToken(token);\n          eatToken();\n        } else if (token.type === tokens.number) {\n          index = t.indexLiteral(token.value);\n          eatToken();\n        }\n        var instrArgs = []; // Nested instruction\n\n        while (token.type === tokens.openParen) {\n          eatToken();\n          instrArgs.push(parseFuncInstr());\n          eatTokenOfType(tokens.closeParen);\n        }\n        if (typeof index === \"undefined\") {\n          throw new Error(\"Missing argument in call instruciton\");\n        }\n        if (instrArgs.length > 0) {\n          return t.callInstruction(index, instrArgs);\n        } else {\n          return t.callInstruction(index);\n        }\n      } else if (isKeyword(token, keywords.if)) {\n        eatToken(); // Keyword\n\n        return parseIf();\n      } else if (isKeyword(token, keywords.module) && hasPlugin(\"wast\")) {\n        eatToken(); // In WAST you can have a module as an instruction's argument\n        // we will cast it into a instruction to not break the flow\n        // $FlowIgnore\n\n        var module = parseModule();\n        return module;\n      } else {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected instruction in function body\" + \", given \" + tokenToString(token));\n        }();\n      }\n    }\n    /*\n     * Parses a function\n     *\n     * WAT:\n     *\n     * functype :: ( 'func' t1:vec(param) t2:vec(result) )\n     * param    :: ( 'param' id? t:valtype )\n     * result   :: ( 'result' t:valtype )\n     *\n     * WAST:\n     *\n     * func     :: ( func <name>? <func_sig> <local>* <instr>* )\n     *             ( func <name>? ( export <string> ) <...> )\n     *             ( func <name>? ( import <string> <string> ) <func_sig> )\n     * func_sig :: ( type <var> )? <param>* <result>*\n     * param    :: ( param <type>* ) | ( param <name> <type> )\n     * result   :: ( result <type>* )\n     * local    :: ( local <type>* ) | ( local <name> <type> )\n     *\n     */\n\n    function parseFunc() {\n      var fnName = t.identifier(getUniqueName(\"func\"));\n      var typeRef;\n      var fnBody = [];\n      var fnParams = [];\n      var fnResult = []; // name\n\n      if (token.type === tokens.identifier) {\n        fnName = identifierFromToken(token);\n        eatToken();\n      } else {\n        fnName = t.withRaw(fnName, \"\"); // preserve anonymous\n      }\n      maybeIgnoreComment();\n      while (token.type === tokens.openParen || token.type === tokens.name || token.type === tokens.valtype) {\n        // Instructions without parens\n        if (token.type === tokens.name || token.type === tokens.valtype) {\n          fnBody.push(parseFuncInstr());\n          continue;\n        }\n        eatToken();\n        if (lookaheadAndCheck(keywords.param) === true) {\n          eatToken();\n          fnParams.push.apply(fnParams, _toConsumableArray(parseFuncParam()));\n        } else if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          fnResult.push.apply(fnResult, _toConsumableArray(parseFuncResult()));\n        } else if (lookaheadAndCheck(keywords.export) === true) {\n          eatToken();\n          parseFuncExport(fnName);\n        } else if (lookaheadAndCheck(keywords.type) === true) {\n          eatToken();\n          typeRef = parseTypeReference();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n          // Instruction\n          fnBody.push(parseFuncInstr());\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in func body\" + \", given \" + tokenToString(token));\n          }();\n        }\n        eatTokenOfType(tokens.closeParen);\n      }\n      return t.func(fnName, typeRef !== undefined ? typeRef : t.signature(fnParams, fnResult), fnBody);\n    }\n    /**\n     * Parses shorthand export in func\n     *\n     * export :: ( export <string> )\n     */\n\n    function parseFuncExport(funcId) {\n      if (token.type !== tokens.string) {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Function export expected a string\" + \", given \" + tokenToString(token));\n        }();\n      }\n      var name = token.value;\n      eatToken();\n      /**\n       * Func export shorthand, we trait it as a syntaxic sugar.\n       * A export ModuleField will be added later.\n       *\n       * We give the anonymous function a generated name and export it.\n       */\n\n      var id = t.identifier(funcId.value);\n      state.registredExportedElements.push({\n        exportType: \"Func\",\n        name: name,\n        id: id\n      });\n    }\n    /**\n     * Parses a type instruction\n     *\n     * WAST:\n     *\n     * typedef: ( type <name>? ( func <param>* <result>* ) )\n     */\n\n    function parseType() {\n      var id;\n      var params = [];\n      var result = [];\n      if (token.type === tokens.identifier) {\n        id = identifierFromToken(token);\n        eatToken();\n      }\n      if (lookaheadAndCheck(tokens.openParen, keywords.func)) {\n        eatToken(); // (\n\n        eatToken(); // func\n\n        if (token.type === tokens.closeParen) {\n          eatToken(); // function with an empty signature, we can abort here\n\n          return t.typeInstruction(id, t.signature([], []));\n        }\n        if (lookaheadAndCheck(tokens.openParen, keywords.param)) {\n          eatToken(); // (\n\n          eatToken(); // param\n\n          params = parseFuncParam();\n          eatTokenOfType(tokens.closeParen);\n        }\n        if (lookaheadAndCheck(tokens.openParen, keywords.result)) {\n          eatToken(); // (\n\n          eatToken(); // result\n\n          result = parseFuncResult();\n          eatTokenOfType(tokens.closeParen);\n        }\n        eatTokenOfType(tokens.closeParen);\n      }\n      return t.typeInstruction(id, t.signature(params, result));\n    }\n    /**\n     * Parses a function result\n     *\n     * WAST:\n     *\n     * result :: ( result <type>* )\n     */\n\n    function parseFuncResult() {\n      var results = [];\n      while (token.type !== tokens.closeParen) {\n        if (token.type !== tokens.valtype) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in func result\" + \", given \" + tokenToString(token));\n          }();\n        }\n        var valtype = token.value;\n        eatToken();\n        results.push(valtype);\n      }\n      return results;\n    }\n    /**\n     * Parses a type reference\n     *\n     */\n\n    function parseTypeReference() {\n      var ref;\n      if (token.type === tokens.identifier) {\n        ref = identifierFromToken(token);\n        eatToken();\n      } else if (token.type === tokens.number) {\n        ref = t.numberLiteralFromRaw(token.value);\n        eatToken();\n      }\n      return ref;\n    }\n    /**\n     * Parses a global instruction\n     *\n     * WAST:\n     *\n     * global:  ( global <name>? <global_sig> <instr>* )\n     *          ( global <name>? ( export <string> ) <...> )\n     *          ( global <name>? ( import <string> <string> ) <global_sig> )\n     *\n     * global_sig: <type> | ( mut <type> )\n     *\n     */\n\n    function parseGlobal() {\n      var name = t.identifier(getUniqueName(\"global\"));\n      var type; // Keep informations in case of a shorthand import\n\n      var importing = null;\n      maybeIgnoreComment();\n      if (token.type === tokens.identifier) {\n        name = identifierFromToken(token);\n        eatToken();\n      } else {\n        name = t.withRaw(name, \"\"); // preserve anonymous\n      }\n      /**\n       * maybe export\n       */\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n        eatToken(); // (\n\n        eatToken(); // export\n\n        var exportName = token.value;\n        eatTokenOfType(tokens.string);\n        state.registredExportedElements.push({\n          exportType: \"Global\",\n          name: exportName,\n          id: name\n        });\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * maybe import\n       */\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.import)) {\n        eatToken(); // (\n\n        eatToken(); // import\n\n        var moduleName = token.value;\n        eatTokenOfType(tokens.string);\n        var _name3 = token.value;\n        eatTokenOfType(tokens.string);\n        importing = {\n          module: moduleName,\n          name: _name3,\n          descr: undefined\n        };\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * global_sig\n       */\n\n      if (token.type === tokens.valtype) {\n        type = t.globalType(token.value, \"const\");\n        eatToken();\n      } else if (token.type === tokens.openParen) {\n        eatToken(); // (\n\n        if (isKeyword(token, keywords.mut) === false) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unsupported global type, expected mut\" + \", given \" + tokenToString(token));\n          }();\n        }\n        eatToken(); // mut\n\n        type = t.globalType(token.value, \"var\");\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      }\n      if (type === undefined) {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Could not determine global type\" + \", given \" + tokenToString(token));\n        }();\n      }\n      maybeIgnoreComment();\n      var init = [];\n      if (importing != null) {\n        importing.descr = type;\n        init.push(t.moduleImport(importing.module, importing.name, importing.descr));\n      }\n      /**\n       * instr*\n       */\n\n      while (token.type === tokens.openParen) {\n        eatToken();\n        init.push(parseFuncInstr());\n        eatTokenOfType(tokens.closeParen);\n      }\n      return t.global(type, init, name);\n    }\n    /**\n     * Parses a function param\n     *\n     * WAST:\n     *\n     * param    :: ( param <type>* ) | ( param <name> <type> )\n     */\n\n    function parseFuncParam() {\n      var params = [];\n      var id;\n      var valtype;\n      if (token.type === tokens.identifier) {\n        id = token.value;\n        eatToken();\n      }\n      if (token.type === tokens.valtype) {\n        valtype = token.value;\n        eatToken();\n        params.push({\n          id: id,\n          valtype: valtype\n        });\n        /**\n         * Shorthand notation for multiple anonymous parameters\n         * @see https://webassembly.github.io/spec/core/text/types.html#function-types\n         * @see https://github.com/xtuc/webassemblyjs/issues/6\n         */\n\n        if (id === undefined) {\n          while (token.type === tokens.valtype) {\n            valtype = token.value;\n            eatToken();\n            params.push({\n              id: undefined,\n              valtype: valtype\n            });\n          }\n        }\n      } else {// ignore\n      }\n      return params;\n    }\n    /**\n     * Parses an element segments instruction\n     *\n     * WAST:\n     *\n     * elem:    ( elem <var>? (offset <instr>* ) <var>* )\n     *          ( elem <var>? <expr> <var>* )\n     *\n     * var:    <nat> | <name>\n     */\n\n    function parseElem() {\n      var tableIndex = t.indexLiteral(0);\n      var offset = [];\n      var funcs = [];\n      if (token.type === tokens.identifier) {\n        tableIndex = identifierFromToken(token);\n        eatToken();\n      }\n      if (token.type === tokens.number) {\n        tableIndex = t.indexLiteral(token.value);\n        eatToken();\n      }\n      while (token.type !== tokens.closeParen) {\n        if (lookaheadAndCheck(tokens.openParen, keywords.offset)) {\n          eatToken(); // (\n\n          eatToken(); // offset\n\n          while (token.type !== tokens.closeParen) {\n            eatTokenOfType(tokens.openParen);\n            offset.push(parseFuncInstr());\n            eatTokenOfType(tokens.closeParen);\n          }\n          eatTokenOfType(tokens.closeParen);\n        } else if (token.type === tokens.identifier) {\n          funcs.push(t.identifier(token.value));\n          eatToken();\n        } else if (token.type === tokens.number) {\n          funcs.push(t.indexLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.openParen) {\n          eatToken(); // (\n\n          offset.push(parseFuncInstr());\n          eatTokenOfType(tokens.closeParen);\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unsupported token in elem\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n      return t.elem(tableIndex, offset, funcs);\n    }\n    /**\n     * Parses the start instruction in a module\n     *\n     * WAST:\n     *\n     * start:   ( start <var> )\n     * var:    <nat> | <name>\n     *\n     * WAT:\n     * start ::= ‘(’ ‘start’  x:funcidx ‘)’\n     */\n\n    function parseStart() {\n      if (token.type === tokens.identifier) {\n        var index = identifierFromToken(token);\n        eatToken();\n        return t.start(index);\n      }\n      if (token.type === tokens.number) {\n        var _index2 = t.indexLiteral(token.value);\n        eatToken();\n        return t.start(_index2);\n      }\n      throw new Error(\"Unknown start, token: \" + tokenToString(token));\n    }\n    if (token.type === tokens.openParen) {\n      eatToken();\n      var startLoc = getStartLoc();\n      if (isKeyword(token, keywords.export)) {\n        eatToken();\n        var node = parseExport();\n        var _endLoc2 = getEndLoc();\n        return t.withLoc(node, _endLoc2, startLoc);\n      }\n      if (isKeyword(token, keywords.loop)) {\n        eatToken();\n        var _node = parseLoop();\n        var _endLoc3 = getEndLoc();\n        return t.withLoc(_node, _endLoc3, startLoc);\n      }\n      if (isKeyword(token, keywords.func)) {\n        eatToken();\n        var _node2 = parseFunc();\n        var _endLoc4 = getEndLoc();\n        maybeIgnoreComment();\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node2, _endLoc4, startLoc);\n      }\n      if (isKeyword(token, keywords.module)) {\n        eatToken();\n        var _node3 = parseModule();\n        var _endLoc5 = getEndLoc();\n        return t.withLoc(_node3, _endLoc5, startLoc);\n      }\n      if (isKeyword(token, keywords.import)) {\n        eatToken();\n        var _node4 = parseImport();\n        var _endLoc6 = getEndLoc();\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node4, _endLoc6, startLoc);\n      }\n      if (isKeyword(token, keywords.block)) {\n        eatToken();\n        var _node5 = parseBlock();\n        var _endLoc7 = getEndLoc();\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node5, _endLoc7, startLoc);\n      }\n      if (isKeyword(token, keywords.memory)) {\n        eatToken();\n        var _node6 = parseMemory();\n        var _endLoc8 = getEndLoc();\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node6, _endLoc8, startLoc);\n      }\n      if (isKeyword(token, keywords.data)) {\n        eatToken();\n        var _node7 = parseData();\n        var _endLoc9 = getEndLoc();\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node7, _endLoc9, startLoc);\n      }\n      if (isKeyword(token, keywords.table)) {\n        eatToken();\n        var _node8 = parseTable();\n        var _endLoc10 = getEndLoc();\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node8, _endLoc10, startLoc);\n      }\n      if (isKeyword(token, keywords.global)) {\n        eatToken();\n        var _node9 = parseGlobal();\n        var _endLoc11 = getEndLoc();\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node9, _endLoc11, startLoc);\n      }\n      if (isKeyword(token, keywords.type)) {\n        eatToken();\n        var _node10 = parseType();\n        var _endLoc12 = getEndLoc();\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node10, _endLoc12, startLoc);\n      }\n      if (isKeyword(token, keywords.start)) {\n        eatToken();\n        var _node11 = parseStart();\n        var _endLoc13 = getEndLoc();\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node11, _endLoc13, startLoc);\n      }\n      if (isKeyword(token, keywords.elem)) {\n        eatToken();\n        var _node12 = parseElem();\n        var _endLoc14 = getEndLoc();\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node12, _endLoc14, startLoc);\n      }\n      var instruction = parseFuncInstr();\n      var endLoc = getEndLoc();\n      maybeIgnoreComment();\n      if (_typeof(instruction) === \"object\") {\n        if (typeof token !== \"undefined\") {\n          eatTokenOfType(tokens.closeParen);\n        }\n        return t.withLoc(instruction, endLoc, startLoc);\n      }\n    }\n    if (token.type === tokens.comment) {\n      var _startLoc = getStartLoc();\n      var builder = token.opts.type === \"leading\" ? t.leadingComment : t.blockComment;\n      var _node13 = builder(token.value);\n      eatToken(); // comment\n\n      var _endLoc15 = getEndLoc();\n      return t.withLoc(_node13, _endLoc15, _startLoc);\n    }\n    throw function () {\n      return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unknown token\" + \", given \" + tokenToString(token));\n    }();\n  }\n  var body = [];\n  while (current < tokensList.length) {\n    body.push(walk());\n  }\n  return t.program(body);\n}","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","codeFrameFromSource","t","parse32I","parseString","tokens","keywords","hasPlugin","name","Error","isKeyword","token","id","type","keyword","value","tokenToString","concat","identifierFromToken","_token$loc","loc","end","start","withLoc","identifier","parse","tokensList","source","current","getUniqueName","getUniqueNameGenerator","state","registredExportedElements","walk","eatToken","getEndLoc","currentToken","lastToken","getStartLoc","eatTokenOfType","parseExportIndex","index","number","_index","numberLiteralFromRaw","lookaheadAndCheck","len","arguments","tokenAhead","expectedToken","undefined","maybeIgnoreComment","comment","parseMemory","limits","limit","string","withRaw","openParen","data","stringInitializer","closeParen","export","_name","push","exportType","max","memory","parseData","memidx","offset","valtype","dot","numberLiteral","objectInstruction","_numberLiteral","instruction","byteArray","memIndexLiteral","parseTable","elemIndices","elemType","elem","exportName","anyfunc","min","parseInt","table","parseImport","moduleName","descr","func","fnParams","fnResult","typeRef","fnName","parseTypeReference","param","apply","parseFuncParam","result","parseFuncResult","funcImportDescr","signature","global","globalType","_valtype","moduleImport","parseBlock","label","blockResult","instr","parseFuncInstr","blockInstruction","parseIf","testInstrs","consequent","alternate","then","else","ifInstruction","parseLoop","loopInstruction","parseCallIndirect","params","results","instrs","callIndirectInstruction","parseExport","moduleExportDescr","parseModuleExportDescr","moduleExport","startLoc","node","endLoc","parseModule","isBinary","isQuote","moduleFields","blob","binaryModule","quoteModule","forEach","decl","module","parseFuncInstrArguments","args","namedArgs","signaturePtr","key","equal","signatureLength","vector","Infinity","valtypeLiteral","stringLiteral","_name2","object","TypeError","_endLoc","signatureForOpcode","_parseFuncInstrArgume","_args","_namedArgs","loop","block","call_indirect","call","indexLiteral","instrArgs","callInstruction","if","parseFunc","fnBody","parseFuncExport","funcId","parseType","typeInstruction","ref","parseGlobal","importing","import","_name3","mut","init","parseElem","tableIndex","funcs","parseStart","_index2","_endLoc2","_node","_endLoc3","_node2","_endLoc4","_node3","_endLoc5","_node4","_endLoc6","_node5","_endLoc7","_node6","_endLoc8","_node7","_endLoc9","_node8","_endLoc10","_node9","_endLoc11","_node10","_endLoc12","_node11","_endLoc13","_node12","_endLoc14","_startLoc","builder","opts","leadingComment","blockComment","_node13","_endLoc15","body","program"],"sources":["/home/soon/bulletin-board/node_modules/@webassemblyjs/wast-parser/esm/grammar.js"],"sourcesContent":["function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nimport { codeFrameFromSource } from \"@webassemblyjs/helper-code-frame\";\nimport * as t from \"@webassemblyjs/ast\";\nimport { parse32I } from \"./number-literals\";\nimport { parseString } from \"./string-literals\";\nimport { tokens, keywords } from \"./tokenizer\";\n\nfunction hasPlugin(name) {\n  if (name !== \"wast\") throw new Error(\"unknow plugin\");\n  return true;\n}\n\nfunction isKeyword(token, id) {\n  return token.type === tokens.keyword && token.value === id;\n}\n\nfunction tokenToString(token) {\n  if (token.type === \"keyword\") {\n    return \"keyword (\".concat(token.value, \")\");\n  }\n\n  return token.type;\n}\n\nfunction identifierFromToken(token) {\n  var _token$loc = token.loc,\n      end = _token$loc.end,\n      start = _token$loc.start;\n  return t.withLoc(t.identifier(token.value), end, start);\n}\n\nexport function parse(tokensList, source) {\n  var current = 0;\n  var getUniqueName = t.getUniqueNameGenerator();\n  var state = {\n    registredExportedElements: []\n  }; // But this time we're going to use recursion instead of a `while` loop. So we\n  // define a `walk` function.\n\n  function walk() {\n    var token = tokensList[current];\n\n    function eatToken() {\n      token = tokensList[++current];\n    }\n\n    function getEndLoc() {\n      var currentToken = token;\n\n      if (typeof currentToken === \"undefined\") {\n        var lastToken = tokensList[tokensList.length - 1];\n        currentToken = lastToken;\n      }\n\n      return currentToken.loc.end;\n    }\n\n    function getStartLoc() {\n      return token.loc.start;\n    }\n\n    function eatTokenOfType(type) {\n      if (token.type !== type) {\n        throw new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"Assertion error: expected token of type \" + type + \", given \" + tokenToString(token));\n      }\n\n      eatToken();\n    }\n\n    function parseExportIndex(token) {\n      if (token.type === tokens.identifier) {\n        var index = identifierFromToken(token);\n        eatToken();\n        return index;\n      } else if (token.type === tokens.number) {\n        var _index = t.numberLiteralFromRaw(token.value);\n\n        eatToken();\n        return _index;\n      } else {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"unknown export index\" + \", given \" + tokenToString(token));\n        }();\n      }\n    }\n\n    function lookaheadAndCheck() {\n      var len = arguments.length;\n\n      for (var i = 0; i < len; i++) {\n        var tokenAhead = tokensList[current + i];\n        var expectedToken = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\n        if (tokenAhead.type === \"keyword\") {\n          if (isKeyword(tokenAhead, expectedToken) === false) {\n            return false;\n          }\n        } else if (expectedToken !== tokenAhead.type) {\n          return false;\n        }\n      }\n\n      return true;\n    } // TODO(sven): there is probably a better way to do this\n    // can refactor it if it get out of hands\n\n\n    function maybeIgnoreComment() {\n      if (typeof token === \"undefined\") {\n        // Ignore\n        return;\n      }\n\n      while (token.type === tokens.comment) {\n        eatToken();\n\n        if (typeof token === \"undefined\") {\n          // Hit the end\n          break;\n        }\n      }\n    }\n    /**\n     * Parses a memory instruction\n     *\n     * WAST:\n     *\n     * memory:  ( memory <name>? <memory_sig> )\n     *          ( memory <name>? ( export <string> ) <...> )\n     *          ( memory <name>? ( import <string> <string> ) <memory_sig> )\n     *          ( memory <name>? ( export <string> )* ( data <string>* )\n     * memory_sig: <nat> <nat>?\n     *\n     */\n\n\n    function parseMemory() {\n      var id = t.identifier(getUniqueName(\"memory\"));\n      var limits = t.limit(0);\n\n      if (token.type === tokens.string || token.type === tokens.identifier) {\n        id = t.identifier(token.value);\n        eatToken();\n      } else {\n        id = t.withRaw(id, \"\"); // preserve anonymous\n      }\n      /**\n       * Maybe data\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.data)) {\n        eatToken(); // (\n\n        eatToken(); // data\n        // TODO(sven): do something with the data collected here\n\n        var stringInitializer = token.value;\n        eatTokenOfType(tokens.string); // Update limits accordingly\n\n        limits = t.limit(stringInitializer.length);\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * Maybe export\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n        eatToken(); // (\n\n        eatToken(); // export\n\n        if (token.type !== tokens.string) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Expected string in export\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        var _name = token.value;\n        eatToken();\n        state.registredExportedElements.push({\n          exportType: \"Memory\",\n          name: _name,\n          id: id\n        });\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * Memory signature\n       */\n\n\n      if (token.type === tokens.number) {\n        limits = t.limit(parse32I(token.value));\n        eatToken();\n\n        if (token.type === tokens.number) {\n          limits.max = parse32I(token.value);\n          eatToken();\n        }\n      }\n\n      return t.memory(limits, id);\n    }\n    /**\n     * Parses a data section\n     * https://webassembly.github.io/spec/core/text/modules.html#data-segments\n     *\n     * WAST:\n     *\n     * data:  ( data <index>? <offset> <string> )\n     */\n\n\n    function parseData() {\n      // optional memory index\n      var memidx = 0;\n\n      if (token.type === tokens.number) {\n        memidx = token.value;\n        eatTokenOfType(tokens.number); // .\n      }\n\n      eatTokenOfType(tokens.openParen);\n      var offset;\n\n      if (token.type === tokens.valtype) {\n        eatTokenOfType(tokens.valtype); // i32\n\n        eatTokenOfType(tokens.dot); // .\n\n        if (token.value !== \"const\") {\n          throw new Error(\"constant expression required\");\n        }\n\n        eatTokenOfType(tokens.name); // const\n\n        var numberLiteral = t.numberLiteralFromRaw(token.value, \"i32\");\n        offset = t.objectInstruction(\"const\", \"i32\", [numberLiteral]);\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      } else {\n        eatTokenOfType(tokens.name); // get_global\n\n        var _numberLiteral = t.numberLiteralFromRaw(token.value, \"i32\");\n\n        offset = t.instruction(\"get_global\", [_numberLiteral]);\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      var byteArray = parseString(token.value);\n      eatToken(); // \"string\"\n\n      return t.data(t.memIndexLiteral(memidx), offset, t.byteArray(byteArray));\n    }\n    /**\n     * Parses a table instruction\n     *\n     * WAST:\n     *\n     * table:   ( table <name>? <table_type> )\n     *          ( table <name>? ( export <string> ) <...> )\n     *          ( table <name>? ( import <string> <string> ) <table_type> )\n     *          ( table <name>? ( export <string> )* <elem_type> ( elem <var>* ) )\n     *\n     * table_type:  <nat> <nat>? <elem_type>\n     * elem_type: anyfunc\n     *\n     * elem:    ( elem <var>? (offset <instr>* ) <var>* )\n     *          ( elem <var>? <expr> <var>* )\n     */\n\n\n    function parseTable() {\n      var name = t.identifier(getUniqueName(\"table\"));\n      var limit = t.limit(0);\n      var elemIndices = [];\n      var elemType = \"anyfunc\";\n\n      if (token.type === tokens.string || token.type === tokens.identifier) {\n        name = identifierFromToken(token);\n        eatToken();\n      } else {\n        name = t.withRaw(name, \"\"); // preserve anonymous\n      }\n\n      while (token.type !== tokens.closeParen) {\n        /**\n         * Maybe export\n         */\n        if (lookaheadAndCheck(tokens.openParen, keywords.elem)) {\n          eatToken(); // (\n\n          eatToken(); // elem\n\n          while (token.type === tokens.identifier) {\n            elemIndices.push(t.identifier(token.value));\n            eatToken();\n          }\n\n          eatTokenOfType(tokens.closeParen);\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n          eatToken(); // (\n\n          eatToken(); // export\n\n          if (token.type !== tokens.string) {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Expected string in export\" + \", given \" + tokenToString(token));\n            }();\n          }\n\n          var exportName = token.value;\n          eatToken();\n          state.registredExportedElements.push({\n            exportType: \"Table\",\n            name: exportName,\n            id: name\n          });\n          eatTokenOfType(tokens.closeParen);\n        } else if (isKeyword(token, keywords.anyfunc)) {\n          // It's the default value, we can ignore it\n          eatToken(); // anyfunc\n        } else if (token.type === tokens.number) {\n          /**\n           * Table type\n           */\n          var min = parseInt(token.value);\n          eatToken();\n\n          if (token.type === tokens.number) {\n            var max = parseInt(token.value);\n            eatToken();\n            limit = t.limit(min, max);\n          } else {\n            limit = t.limit(min);\n          }\n\n          eatToken();\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n\n      if (elemIndices.length > 0) {\n        return t.table(elemType, limit, name, elemIndices);\n      } else {\n        return t.table(elemType, limit, name);\n      }\n    }\n    /**\n     * Parses an import statement\n     *\n     * WAST:\n     *\n     * import:  ( import <string> <string> <imkind> )\n     * imkind:  ( func <name>? <func_sig> )\n     *          ( global <name>? <global_sig> )\n     *          ( table <name>? <table_sig> )\n     *          ( memory <name>? <memory_sig> )\n     *\n     * global_sig: <type> | ( mut <type> )\n     */\n\n\n    function parseImport() {\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected a string, \" + token.type + \" given.\");\n      }\n\n      var moduleName = token.value;\n      eatToken();\n\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected a string, \" + token.type + \" given.\");\n      }\n\n      var name = token.value;\n      eatToken();\n      eatTokenOfType(tokens.openParen);\n      var descr;\n\n      if (isKeyword(token, keywords.func)) {\n        eatToken(); // keyword\n\n        var fnParams = [];\n        var fnResult = [];\n        var typeRef;\n        var fnName = t.identifier(getUniqueName(\"func\"));\n\n        if (token.type === tokens.identifier) {\n          fnName = identifierFromToken(token);\n          eatToken();\n        }\n\n        while (token.type === tokens.openParen) {\n          eatToken();\n\n          if (lookaheadAndCheck(keywords.type) === true) {\n            eatToken();\n            typeRef = parseTypeReference();\n          } else if (lookaheadAndCheck(keywords.param) === true) {\n            eatToken();\n            fnParams.push.apply(fnParams, _toConsumableArray(parseFuncParam()));\n          } else if (lookaheadAndCheck(keywords.result) === true) {\n            eatToken();\n            fnResult.push.apply(fnResult, _toConsumableArray(parseFuncResult()));\n          } else {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in import of type\" + \", given \" + tokenToString(token));\n            }();\n          }\n\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        if (typeof fnName === \"undefined\") {\n          throw new Error(\"Imported function must have a name\");\n        }\n\n        descr = t.funcImportDescr(fnName, typeRef !== undefined ? typeRef : t.signature(fnParams, fnResult));\n      } else if (isKeyword(token, keywords.global)) {\n        eatToken(); // keyword\n\n        if (token.type === tokens.openParen) {\n          eatToken(); // (\n\n          eatTokenOfType(tokens.keyword); // mut keyword\n\n          var valtype = token.value;\n          eatToken();\n          descr = t.globalType(valtype, \"var\");\n          eatTokenOfType(tokens.closeParen);\n        } else {\n          var _valtype = token.value;\n          eatTokenOfType(tokens.valtype);\n          descr = t.globalType(_valtype, \"const\");\n        }\n      } else if (isKeyword(token, keywords.memory) === true) {\n        eatToken(); // Keyword\n\n        descr = parseMemory();\n      } else if (isKeyword(token, keywords.table) === true) {\n        eatToken(); // Keyword\n\n        descr = parseTable();\n      } else {\n        throw new Error(\"Unsupported import type: \" + tokenToString(token));\n      }\n\n      eatTokenOfType(tokens.closeParen);\n      return t.moduleImport(moduleName, name, descr);\n    }\n    /**\n     * Parses a block instruction\n     *\n     * WAST:\n     *\n     * expr: ( block <name>? <block_sig> <instr>* )\n     * instr: block <name>? <block_sig> <instr>* end <name>?\n     * block_sig : ( result <type>* )*\n     *\n     */\n\n\n    function parseBlock() {\n      var label = t.identifier(getUniqueName(\"block\"));\n      var blockResult = null;\n      var instr = [];\n\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n\n      while (token.type === tokens.openParen) {\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatToken();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n            // Instruction\n            instr.push(parseFuncInstr());\n          } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in block body of type\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        maybeIgnoreComment();\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.blockInstruction(label, instr, blockResult);\n    }\n    /**\n     * Parses a if instruction\n     *\n     * WAST:\n     *\n     * expr:\n     * ( if <name>? <block_sig> ( then <instr>* ) ( else <instr>* )? )\n     * ( if <name>? <block_sig> <expr>+ ( then <instr>* ) ( else <instr>* )? )\n     *\n     * instr:\n     * if <name>? <block_sig> <instr>* end <name>?\n     * if <name>? <block_sig> <instr>* else <name>? <instr>* end <name>?\n     *\n     * block_sig : ( result <type>* )*\n     *\n     */\n\n\n    function parseIf() {\n      var blockResult = null;\n      var label = t.identifier(getUniqueName(\"if\"));\n      var testInstrs = [];\n      var consequent = [];\n      var alternate = [];\n\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n\n      while (token.type === tokens.openParen) {\n        eatToken(); // (\n\n        /**\n         * Block signature\n         */\n\n        if (isKeyword(token, keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatTokenOfType(tokens.valtype);\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Then\n         */\n\n\n        if (isKeyword(token, keywords.then) === true) {\n          eatToken(); // then\n\n          while (token.type === tokens.openParen) {\n            eatToken(); // Instruction\n\n            if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n            ) {\n                consequent.push(parseFuncInstr());\n              } else {\n              throw function () {\n                return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in consequent body of type\" + \", given \" + tokenToString(token));\n              }();\n            }\n\n            eatTokenOfType(tokens.closeParen);\n          }\n\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Alternate\n         */\n\n\n        if (isKeyword(token, keywords.else)) {\n          eatToken(); // else\n\n          while (token.type === tokens.openParen) {\n            eatToken(); // Instruction\n\n            if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n            ) {\n                alternate.push(parseFuncInstr());\n              } else {\n              throw function () {\n                return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in alternate body of type\" + \", given \" + tokenToString(token));\n              }();\n            }\n\n            eatTokenOfType(tokens.closeParen);\n          }\n\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Test instruction\n         */\n\n\n        if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n            testInstrs.push(parseFuncInstr());\n            eatTokenOfType(tokens.closeParen);\n            continue;\n          }\n\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in if body\" + \", given \" + tokenToString(token));\n        }();\n      }\n\n      return t.ifInstruction(label, testInstrs, blockResult, consequent, alternate);\n    }\n    /**\n     * Parses a loop instruction\n     *\n     * WAT:\n     *\n     * blockinstr :: 'loop' I:label rt:resulttype (in:instr*) 'end' id?\n     *\n     * WAST:\n     *\n     * instr     :: loop <name>? <block_sig> <instr>* end <name>?\n     * expr      :: ( loop <name>? <block_sig> <instr>* )\n     * block_sig :: ( result <type>* )*\n     *\n     */\n\n\n    function parseLoop() {\n      var label = t.identifier(getUniqueName(\"loop\"));\n      var blockResult;\n      var instr = [];\n\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n\n      while (token.type === tokens.openParen) {\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatToken();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n            // Instruction\n            instr.push(parseFuncInstr());\n          } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in loop body\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.loopInstruction(label, blockResult, instr);\n    }\n\n    function parseCallIndirect() {\n      var typeRef;\n      var params = [];\n      var results = [];\n      var instrs = [];\n\n      while (token.type !== tokens.closeParen) {\n        if (lookaheadAndCheck(tokens.openParen, keywords.type)) {\n          eatToken(); // (\n\n          eatToken(); // type\n\n          typeRef = parseTypeReference();\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.param)) {\n          eatToken(); // (\n\n          eatToken(); // param\n\n          /**\n           * Params can be empty:\n           * (params)`\n           */\n\n          if (token.type !== tokens.closeParen) {\n            params.push.apply(params, _toConsumableArray(parseFuncParam()));\n          }\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.result)) {\n          eatToken(); // (\n\n          eatToken(); // result\n\n          /**\n           * Results can be empty:\n           * (result)`\n           */\n\n          if (token.type !== tokens.closeParen) {\n            results.push.apply(results, _toConsumableArray(parseFuncResult()));\n          }\n        } else {\n          eatTokenOfType(tokens.openParen);\n          instrs.push(parseFuncInstr());\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.callIndirectInstruction(typeRef !== undefined ? typeRef : t.signature(params, results), instrs);\n    }\n    /**\n     * Parses an export instruction\n     *\n     * WAT:\n     *\n     * export:  ( export <string> <exkind> )\n     * exkind:  ( func <var> )\n     *          ( global <var> )\n     *          ( table <var> )\n     *          ( memory <var> )\n     * var:    <nat> | <name>\n     *\n     */\n\n\n    function parseExport() {\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected string after export, got: \" + token.type);\n      }\n\n      var name = token.value;\n      eatToken();\n      var moduleExportDescr = parseModuleExportDescr();\n      return t.moduleExport(name, moduleExportDescr);\n    }\n\n    function parseModuleExportDescr() {\n      var startLoc = getStartLoc();\n      var type = \"\";\n      var index;\n      eatTokenOfType(tokens.openParen);\n\n      while (token.type !== tokens.closeParen) {\n        if (isKeyword(token, keywords.func)) {\n          type = \"Func\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.table)) {\n          type = \"Table\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.global)) {\n          type = \"Global\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.memory)) {\n          type = \"Memory\";\n          eatToken();\n          index = parseExportIndex(token);\n        }\n\n        eatToken();\n      }\n\n      if (type === \"\") {\n        throw new Error(\"Unknown export type\");\n      }\n\n      if (index === undefined) {\n        throw new Error(\"Exported function must have a name\");\n      }\n\n      var node = t.moduleExportDescr(type, index);\n      var endLoc = getEndLoc();\n      eatTokenOfType(tokens.closeParen);\n      return t.withLoc(node, endLoc, startLoc);\n    }\n\n    function parseModule() {\n      var name = null;\n      var isBinary = false;\n      var isQuote = false;\n      var moduleFields = [];\n\n      if (token.type === tokens.identifier) {\n        name = token.value;\n        eatToken();\n      }\n\n      if (hasPlugin(\"wast\") && token.type === tokens.name && token.value === \"binary\") {\n        eatToken();\n        isBinary = true;\n      }\n\n      if (hasPlugin(\"wast\") && token.type === tokens.name && token.value === \"quote\") {\n        eatToken();\n        isQuote = true;\n      }\n\n      if (isBinary === true) {\n        var blob = [];\n\n        while (token.type === tokens.string) {\n          blob.push(token.value);\n          eatToken();\n          maybeIgnoreComment();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n        return t.binaryModule(name, blob);\n      }\n\n      if (isQuote === true) {\n        var string = [];\n\n        while (token.type === tokens.string) {\n          string.push(token.value);\n          eatToken();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n        return t.quoteModule(name, string);\n      }\n\n      while (token.type !== tokens.closeParen) {\n        moduleFields.push(walk());\n\n        if (state.registredExportedElements.length > 0) {\n          state.registredExportedElements.forEach(function (decl) {\n            moduleFields.push(t.moduleExport(decl.name, t.moduleExportDescr(decl.exportType, decl.id)));\n          });\n          state.registredExportedElements = [];\n        }\n\n        token = tokensList[current];\n      }\n\n      eatTokenOfType(tokens.closeParen);\n      return t.module(name, moduleFields);\n    }\n    /**\n     * Parses the arguments of an instruction\n     */\n\n\n    function parseFuncInstrArguments(signature) {\n      var args = [];\n      var namedArgs = {};\n      var signaturePtr = 0;\n\n      while (token.type === tokens.name || isKeyword(token, keywords.offset)) {\n        var key = token.value;\n        eatToken();\n        eatTokenOfType(tokens.equal);\n        var value = void 0;\n\n        if (token.type === tokens.number) {\n          value = t.numberLiteralFromRaw(token.value);\n        } else {\n          throw new Error(\"Unexpected type for argument: \" + token.type);\n        }\n\n        namedArgs[key] = value;\n        eatToken();\n      } // $FlowIgnore\n\n\n      var signatureLength = signature.vector ? Infinity : signature.length;\n\n      while (token.type !== tokens.closeParen && ( // $FlowIgnore\n      token.type === tokens.openParen || signaturePtr < signatureLength)) {\n        if (token.type === tokens.identifier) {\n          args.push(t.identifier(token.value));\n          eatToken();\n        } else if (token.type === tokens.valtype) {\n          // Handle locals\n          args.push(t.valtypeLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.string) {\n          args.push(t.stringLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.number) {\n          args.push( // TODO(sven): refactor the type signature handling\n          // https://github.com/xtuc/webassemblyjs/pull/129 is a good start\n          t.numberLiteralFromRaw(token.value, // $FlowIgnore\n          signature[signaturePtr] || \"f64\")); // $FlowIgnore\n\n          if (!signature.vector) {\n            ++signaturePtr;\n          }\n\n          eatToken();\n        } else if (token.type === tokens.openParen) {\n          /**\n           * Maybe some nested instructions\n           */\n          eatToken(); // Instruction\n\n          if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n          ) {\n              // $FlowIgnore\n              args.push(parseFuncInstr());\n            } else {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in nested instruction\" + \", given \" + tokenToString(token));\n            }();\n          }\n\n          if (token.type === tokens.closeParen) {\n            eatToken();\n          }\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in instruction argument\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n\n      return {\n        args: args,\n        namedArgs: namedArgs\n      };\n    }\n    /**\n     * Parses an instruction\n     *\n     * WAT:\n     *\n     * instr      :: plaininst\n     *               blockinstr\n     *\n     * blockinstr :: 'block' I:label rt:resulttype (in:instr*) 'end' id?\n     *               'loop' I:label rt:resulttype (in:instr*) 'end' id?\n     *               'if' I:label rt:resulttype (in:instr*) 'else' id? (in2:intr*) 'end' id?\n     *\n     * plaininst  :: 'unreachable'\n     *               'nop'\n     *               'br' l:labelidx\n     *               'br_if' l:labelidx\n     *               'br_table' l*:vec(labelidx) ln:labelidx\n     *               'return'\n     *               'call' x:funcidx\n     *               'call_indirect' x, I:typeuse\n     *\n     * WAST:\n     *\n     * instr:\n     *   <expr>\n     *   <op>\n     *   block <name>? <block_sig> <instr>* end <name>?\n     *   loop <name>? <block_sig> <instr>* end <name>?\n     *   if <name>? <block_sig> <instr>* end <name>?\n     *   if <name>? <block_sig> <instr>* else <name>? <instr>* end <name>?\n     *\n     * expr:\n     *   ( <op> )\n     *   ( <op> <expr>+ )\n     *   ( block <name>? <block_sig> <instr>* )\n     *   ( loop <name>? <block_sig> <instr>* )\n     *   ( if <name>? <block_sig> ( then <instr>* ) ( else <instr>* )? )\n     *   ( if <name>? <block_sig> <expr>+ ( then <instr>* ) ( else <instr>* )? )\n     *\n     * op:\n     *   unreachable\n     *   nop\n     *   br <var>\n     *   br_if <var>\n     *   br_table <var>+\n     *   return\n     *   call <var>\n     *   call_indirect <func_sig>\n     *   drop\n     *   select\n     *   get_local <var>\n     *   set_local <var>\n     *   tee_local <var>\n     *   get_global <var>\n     *   set_global <var>\n     *   <type>.load((8|16|32)_<sign>)? <offset>? <align>?\n     *   <type>.store(8|16|32)? <offset>? <align>?\n     *   current_memory\n     *   grow_memory\n     *   <type>.const <value>\n     *   <type>.<unop>\n     *   <type>.<binop>\n     *   <type>.<testop>\n     *   <type>.<relop>\n     *   <type>.<cvtop>/<type>\n     *\n     * func_type:   ( type <var> )? <param>* <result>*\n     */\n\n\n    function parseFuncInstr() {\n      var startLoc = getStartLoc();\n      maybeIgnoreComment();\n      /**\n       * A simple instruction\n       */\n\n      if (token.type === tokens.name || token.type === tokens.valtype) {\n        var _name2 = token.value;\n        var object;\n        eatToken();\n\n        if (token.type === tokens.dot) {\n          object = _name2;\n          eatToken();\n\n          if (token.type !== tokens.name) {\n            throw new TypeError(\"Unknown token: \" + token.type + \", name expected\");\n          }\n\n          _name2 = token.value;\n          eatToken();\n        }\n\n        if (token.type === tokens.closeParen) {\n          var _endLoc = token.loc.end;\n\n          if (typeof object === \"undefined\") {\n            return t.withLoc(t.instruction(_name2), _endLoc, startLoc);\n          } else {\n            return t.withLoc(t.objectInstruction(_name2, object, []), _endLoc, startLoc);\n          }\n        }\n\n        var signature = t.signatureForOpcode(object || \"\", _name2);\n\n        var _parseFuncInstrArgume = parseFuncInstrArguments(signature),\n            _args = _parseFuncInstrArgume.args,\n            _namedArgs = _parseFuncInstrArgume.namedArgs;\n\n        var endLoc = token.loc.end;\n\n        if (typeof object === \"undefined\") {\n          return t.withLoc(t.instruction(_name2, _args, _namedArgs), endLoc, startLoc);\n        } else {\n          return t.withLoc(t.objectInstruction(_name2, object, _args, _namedArgs), endLoc, startLoc);\n        }\n      } else if (isKeyword(token, keywords.loop)) {\n        /**\n         * Else a instruction with a keyword (loop or block)\n         */\n        eatToken(); // keyword\n\n        return parseLoop();\n      } else if (isKeyword(token, keywords.block)) {\n        eatToken(); // keyword\n\n        return parseBlock();\n      } else if (isKeyword(token, keywords.call_indirect)) {\n        eatToken(); // keyword\n\n        return parseCallIndirect();\n      } else if (isKeyword(token, keywords.call)) {\n        eatToken(); // keyword\n\n        var index;\n\n        if (token.type === tokens.identifier) {\n          index = identifierFromToken(token);\n          eatToken();\n        } else if (token.type === tokens.number) {\n          index = t.indexLiteral(token.value);\n          eatToken();\n        }\n\n        var instrArgs = []; // Nested instruction\n\n        while (token.type === tokens.openParen) {\n          eatToken();\n          instrArgs.push(parseFuncInstr());\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        if (typeof index === \"undefined\") {\n          throw new Error(\"Missing argument in call instruciton\");\n        }\n\n        if (instrArgs.length > 0) {\n          return t.callInstruction(index, instrArgs);\n        } else {\n          return t.callInstruction(index);\n        }\n      } else if (isKeyword(token, keywords.if)) {\n        eatToken(); // Keyword\n\n        return parseIf();\n      } else if (isKeyword(token, keywords.module) && hasPlugin(\"wast\")) {\n        eatToken(); // In WAST you can have a module as an instruction's argument\n        // we will cast it into a instruction to not break the flow\n        // $FlowIgnore\n\n        var module = parseModule();\n        return module;\n      } else {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected instruction in function body\" + \", given \" + tokenToString(token));\n        }();\n      }\n    }\n    /*\n     * Parses a function\n     *\n     * WAT:\n     *\n     * functype :: ( 'func' t1:vec(param) t2:vec(result) )\n     * param    :: ( 'param' id? t:valtype )\n     * result   :: ( 'result' t:valtype )\n     *\n     * WAST:\n     *\n     * func     :: ( func <name>? <func_sig> <local>* <instr>* )\n     *             ( func <name>? ( export <string> ) <...> )\n     *             ( func <name>? ( import <string> <string> ) <func_sig> )\n     * func_sig :: ( type <var> )? <param>* <result>*\n     * param    :: ( param <type>* ) | ( param <name> <type> )\n     * result   :: ( result <type>* )\n     * local    :: ( local <type>* ) | ( local <name> <type> )\n     *\n     */\n\n\n    function parseFunc() {\n      var fnName = t.identifier(getUniqueName(\"func\"));\n      var typeRef;\n      var fnBody = [];\n      var fnParams = [];\n      var fnResult = []; // name\n\n      if (token.type === tokens.identifier) {\n        fnName = identifierFromToken(token);\n        eatToken();\n      } else {\n        fnName = t.withRaw(fnName, \"\"); // preserve anonymous\n      }\n\n      maybeIgnoreComment();\n\n      while (token.type === tokens.openParen || token.type === tokens.name || token.type === tokens.valtype) {\n        // Instructions without parens\n        if (token.type === tokens.name || token.type === tokens.valtype) {\n          fnBody.push(parseFuncInstr());\n          continue;\n        }\n\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.param) === true) {\n          eatToken();\n          fnParams.push.apply(fnParams, _toConsumableArray(parseFuncParam()));\n        } else if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          fnResult.push.apply(fnResult, _toConsumableArray(parseFuncResult()));\n        } else if (lookaheadAndCheck(keywords.export) === true) {\n          eatToken();\n          parseFuncExport(fnName);\n        } else if (lookaheadAndCheck(keywords.type) === true) {\n          eatToken();\n          typeRef = parseTypeReference();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n            // Instruction\n            fnBody.push(parseFuncInstr());\n          } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in func body\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.func(fnName, typeRef !== undefined ? typeRef : t.signature(fnParams, fnResult), fnBody);\n    }\n    /**\n     * Parses shorthand export in func\n     *\n     * export :: ( export <string> )\n     */\n\n\n    function parseFuncExport(funcId) {\n      if (token.type !== tokens.string) {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Function export expected a string\" + \", given \" + tokenToString(token));\n        }();\n      }\n\n      var name = token.value;\n      eatToken();\n      /**\n       * Func export shorthand, we trait it as a syntaxic sugar.\n       * A export ModuleField will be added later.\n       *\n       * We give the anonymous function a generated name and export it.\n       */\n\n      var id = t.identifier(funcId.value);\n      state.registredExportedElements.push({\n        exportType: \"Func\",\n        name: name,\n        id: id\n      });\n    }\n    /**\n     * Parses a type instruction\n     *\n     * WAST:\n     *\n     * typedef: ( type <name>? ( func <param>* <result>* ) )\n     */\n\n\n    function parseType() {\n      var id;\n      var params = [];\n      var result = [];\n\n      if (token.type === tokens.identifier) {\n        id = identifierFromToken(token);\n        eatToken();\n      }\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.func)) {\n        eatToken(); // (\n\n        eatToken(); // func\n\n        if (token.type === tokens.closeParen) {\n          eatToken(); // function with an empty signature, we can abort here\n\n          return t.typeInstruction(id, t.signature([], []));\n        }\n\n        if (lookaheadAndCheck(tokens.openParen, keywords.param)) {\n          eatToken(); // (\n\n          eatToken(); // param\n\n          params = parseFuncParam();\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        if (lookaheadAndCheck(tokens.openParen, keywords.result)) {\n          eatToken(); // (\n\n          eatToken(); // result\n\n          result = parseFuncResult();\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.typeInstruction(id, t.signature(params, result));\n    }\n    /**\n     * Parses a function result\n     *\n     * WAST:\n     *\n     * result :: ( result <type>* )\n     */\n\n\n    function parseFuncResult() {\n      var results = [];\n\n      while (token.type !== tokens.closeParen) {\n        if (token.type !== tokens.valtype) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in func result\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        var valtype = token.value;\n        eatToken();\n        results.push(valtype);\n      }\n\n      return results;\n    }\n    /**\n     * Parses a type reference\n     *\n     */\n\n\n    function parseTypeReference() {\n      var ref;\n\n      if (token.type === tokens.identifier) {\n        ref = identifierFromToken(token);\n        eatToken();\n      } else if (token.type === tokens.number) {\n        ref = t.numberLiteralFromRaw(token.value);\n        eatToken();\n      }\n\n      return ref;\n    }\n    /**\n     * Parses a global instruction\n     *\n     * WAST:\n     *\n     * global:  ( global <name>? <global_sig> <instr>* )\n     *          ( global <name>? ( export <string> ) <...> )\n     *          ( global <name>? ( import <string> <string> ) <global_sig> )\n     *\n     * global_sig: <type> | ( mut <type> )\n     *\n     */\n\n\n    function parseGlobal() {\n      var name = t.identifier(getUniqueName(\"global\"));\n      var type; // Keep informations in case of a shorthand import\n\n      var importing = null;\n      maybeIgnoreComment();\n\n      if (token.type === tokens.identifier) {\n        name = identifierFromToken(token);\n        eatToken();\n      } else {\n        name = t.withRaw(name, \"\"); // preserve anonymous\n      }\n      /**\n       * maybe export\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n        eatToken(); // (\n\n        eatToken(); // export\n\n        var exportName = token.value;\n        eatTokenOfType(tokens.string);\n        state.registredExportedElements.push({\n          exportType: \"Global\",\n          name: exportName,\n          id: name\n        });\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * maybe import\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.import)) {\n        eatToken(); // (\n\n        eatToken(); // import\n\n        var moduleName = token.value;\n        eatTokenOfType(tokens.string);\n        var _name3 = token.value;\n        eatTokenOfType(tokens.string);\n        importing = {\n          module: moduleName,\n          name: _name3,\n          descr: undefined\n        };\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * global_sig\n       */\n\n\n      if (token.type === tokens.valtype) {\n        type = t.globalType(token.value, \"const\");\n        eatToken();\n      } else if (token.type === tokens.openParen) {\n        eatToken(); // (\n\n        if (isKeyword(token, keywords.mut) === false) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unsupported global type, expected mut\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        eatToken(); // mut\n\n        type = t.globalType(token.value, \"var\");\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      if (type === undefined) {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Could not determine global type\" + \", given \" + tokenToString(token));\n        }();\n      }\n\n      maybeIgnoreComment();\n      var init = [];\n\n      if (importing != null) {\n        importing.descr = type;\n        init.push(t.moduleImport(importing.module, importing.name, importing.descr));\n      }\n      /**\n       * instr*\n       */\n\n\n      while (token.type === tokens.openParen) {\n        eatToken();\n        init.push(parseFuncInstr());\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.global(type, init, name);\n    }\n    /**\n     * Parses a function param\n     *\n     * WAST:\n     *\n     * param    :: ( param <type>* ) | ( param <name> <type> )\n     */\n\n\n    function parseFuncParam() {\n      var params = [];\n      var id;\n      var valtype;\n\n      if (token.type === tokens.identifier) {\n        id = token.value;\n        eatToken();\n      }\n\n      if (token.type === tokens.valtype) {\n        valtype = token.value;\n        eatToken();\n        params.push({\n          id: id,\n          valtype: valtype\n        });\n        /**\n         * Shorthand notation for multiple anonymous parameters\n         * @see https://webassembly.github.io/spec/core/text/types.html#function-types\n         * @see https://github.com/xtuc/webassemblyjs/issues/6\n         */\n\n        if (id === undefined) {\n          while (token.type === tokens.valtype) {\n            valtype = token.value;\n            eatToken();\n            params.push({\n              id: undefined,\n              valtype: valtype\n            });\n          }\n        }\n      } else {// ignore\n      }\n\n      return params;\n    }\n    /**\n     * Parses an element segments instruction\n     *\n     * WAST:\n     *\n     * elem:    ( elem <var>? (offset <instr>* ) <var>* )\n     *          ( elem <var>? <expr> <var>* )\n     *\n     * var:    <nat> | <name>\n     */\n\n\n    function parseElem() {\n      var tableIndex = t.indexLiteral(0);\n      var offset = [];\n      var funcs = [];\n\n      if (token.type === tokens.identifier) {\n        tableIndex = identifierFromToken(token);\n        eatToken();\n      }\n\n      if (token.type === tokens.number) {\n        tableIndex = t.indexLiteral(token.value);\n        eatToken();\n      }\n\n      while (token.type !== tokens.closeParen) {\n        if (lookaheadAndCheck(tokens.openParen, keywords.offset)) {\n          eatToken(); // (\n\n          eatToken(); // offset\n\n          while (token.type !== tokens.closeParen) {\n            eatTokenOfType(tokens.openParen);\n            offset.push(parseFuncInstr());\n            eatTokenOfType(tokens.closeParen);\n          }\n\n          eatTokenOfType(tokens.closeParen);\n        } else if (token.type === tokens.identifier) {\n          funcs.push(t.identifier(token.value));\n          eatToken();\n        } else if (token.type === tokens.number) {\n          funcs.push(t.indexLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.openParen) {\n          eatToken(); // (\n\n          offset.push(parseFuncInstr());\n          eatTokenOfType(tokens.closeParen);\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unsupported token in elem\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n\n      return t.elem(tableIndex, offset, funcs);\n    }\n    /**\n     * Parses the start instruction in a module\n     *\n     * WAST:\n     *\n     * start:   ( start <var> )\n     * var:    <nat> | <name>\n     *\n     * WAT:\n     * start ::= ‘(’ ‘start’  x:funcidx ‘)’\n     */\n\n\n    function parseStart() {\n      if (token.type === tokens.identifier) {\n        var index = identifierFromToken(token);\n        eatToken();\n        return t.start(index);\n      }\n\n      if (token.type === tokens.number) {\n        var _index2 = t.indexLiteral(token.value);\n\n        eatToken();\n        return t.start(_index2);\n      }\n\n      throw new Error(\"Unknown start, token: \" + tokenToString(token));\n    }\n\n    if (token.type === tokens.openParen) {\n      eatToken();\n      var startLoc = getStartLoc();\n\n      if (isKeyword(token, keywords.export)) {\n        eatToken();\n        var node = parseExport();\n\n        var _endLoc2 = getEndLoc();\n\n        return t.withLoc(node, _endLoc2, startLoc);\n      }\n\n      if (isKeyword(token, keywords.loop)) {\n        eatToken();\n\n        var _node = parseLoop();\n\n        var _endLoc3 = getEndLoc();\n\n        return t.withLoc(_node, _endLoc3, startLoc);\n      }\n\n      if (isKeyword(token, keywords.func)) {\n        eatToken();\n\n        var _node2 = parseFunc();\n\n        var _endLoc4 = getEndLoc();\n\n        maybeIgnoreComment();\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node2, _endLoc4, startLoc);\n      }\n\n      if (isKeyword(token, keywords.module)) {\n        eatToken();\n\n        var _node3 = parseModule();\n\n        var _endLoc5 = getEndLoc();\n\n        return t.withLoc(_node3, _endLoc5, startLoc);\n      }\n\n      if (isKeyword(token, keywords.import)) {\n        eatToken();\n\n        var _node4 = parseImport();\n\n        var _endLoc6 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node4, _endLoc6, startLoc);\n      }\n\n      if (isKeyword(token, keywords.block)) {\n        eatToken();\n\n        var _node5 = parseBlock();\n\n        var _endLoc7 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node5, _endLoc7, startLoc);\n      }\n\n      if (isKeyword(token, keywords.memory)) {\n        eatToken();\n\n        var _node6 = parseMemory();\n\n        var _endLoc8 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node6, _endLoc8, startLoc);\n      }\n\n      if (isKeyword(token, keywords.data)) {\n        eatToken();\n\n        var _node7 = parseData();\n\n        var _endLoc9 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node7, _endLoc9, startLoc);\n      }\n\n      if (isKeyword(token, keywords.table)) {\n        eatToken();\n\n        var _node8 = parseTable();\n\n        var _endLoc10 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node8, _endLoc10, startLoc);\n      }\n\n      if (isKeyword(token, keywords.global)) {\n        eatToken();\n\n        var _node9 = parseGlobal();\n\n        var _endLoc11 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node9, _endLoc11, startLoc);\n      }\n\n      if (isKeyword(token, keywords.type)) {\n        eatToken();\n\n        var _node10 = parseType();\n\n        var _endLoc12 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node10, _endLoc12, startLoc);\n      }\n\n      if (isKeyword(token, keywords.start)) {\n        eatToken();\n\n        var _node11 = parseStart();\n\n        var _endLoc13 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node11, _endLoc13, startLoc);\n      }\n\n      if (isKeyword(token, keywords.elem)) {\n        eatToken();\n\n        var _node12 = parseElem();\n\n        var _endLoc14 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node12, _endLoc14, startLoc);\n      }\n\n      var instruction = parseFuncInstr();\n      var endLoc = getEndLoc();\n      maybeIgnoreComment();\n\n      if (_typeof(instruction) === \"object\") {\n        if (typeof token !== \"undefined\") {\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        return t.withLoc(instruction, endLoc, startLoc);\n      }\n    }\n\n    if (token.type === tokens.comment) {\n      var _startLoc = getStartLoc();\n\n      var builder = token.opts.type === \"leading\" ? t.leadingComment : t.blockComment;\n\n      var _node13 = builder(token.value);\n\n      eatToken(); // comment\n\n      var _endLoc15 = getEndLoc();\n\n      return t.withLoc(_node13, _endLoc15, _startLoc);\n    }\n\n    throw function () {\n      return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unknown token\" + \", given \" + tokenToString(token));\n    }();\n  }\n\n  var body = [];\n\n  while (current < tokensList.length) {\n    body.push(walk());\n  }\n\n  return t.program(body);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}