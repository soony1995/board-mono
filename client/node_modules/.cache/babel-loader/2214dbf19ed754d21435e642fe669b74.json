{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n/*\n<rules>: <rule>\n<rules>: [<rule>]\n<rule>: {\n\tresource: {\n\t\ttest: <condition>,\n\t\tinclude: <condition>,\n\t\texclude: <condition>,\n\t},\n\tresource: <condition>, -> resource.test\n\ttest: <condition>, -> resource.test\n\tinclude: <condition>, -> resource.include\n\texclude: <condition>, -> resource.exclude\n\tresourceQuery: <condition>,\n\tcompiler: <condition>,\n\tissuer: <condition>,\n\tuse: \"loader\", -> use[0].loader\n\tloader: <>, -> use[0].loader\n\tloaders: <>, -> use\n\toptions: {}, -> use[0].options,\n\tquery: {}, -> options\n\tparser: {},\n\tuse: [\n\t\t\"loader\" -> use[x].loader\n\t],\n\tuse: [\n\t\t{\n\t\t\tloader: \"loader\",\n\t\t\toptions: {}\n\t\t}\n\t],\n\trules: [\n\t\t<rule>\n\t],\n\toneOf: [\n\t\t<rule>\n\t]\n}\n\n<condition>: /regExp/\n<condition>: function(arg) {}\n<condition>: \"starting\"\n<condition>: [<condition>] // or\n<condition>: { and: [<condition>] }\n<condition>: { or: [<condition>] }\n<condition>: { not: [<condition>] }\n<condition>: { test: <condition>, include: <condition>, exclude: <condition> }\n\n\nnormalized:\n\n{\n\tresource: function(),\n\tresourceQuery: function(),\n\tcompiler: function(),\n\tissuer: function(),\n\tuse: [\n\t\t{\n\t\t\tloader: string,\n\t\t\toptions: string,\n\t\t\t<any>: <any>\n\t\t}\n\t],\n\trules: [<rule>],\n\toneOf: [<rule>],\n\t<any>: <any>,\n}\n\n*/\n\n\"use strict\";\n\nconst notMatcher = matcher => {\n  return str => {\n    return !matcher(str);\n  };\n};\nconst orMatcher = items => {\n  return str => {\n    for (let i = 0; i < items.length; i++) {\n      if (items[i](str)) return true;\n    }\n    return false;\n  };\n};\nconst andMatcher = items => {\n  return str => {\n    for (let i = 0; i < items.length; i++) {\n      if (!items[i](str)) return false;\n    }\n    return true;\n  };\n};\nmodule.exports = class RuleSet {\n  constructor(rules) {\n    this.references = Object.create(null);\n    this.rules = RuleSet.normalizeRules(rules, this.references, \"ref-\");\n  }\n  static normalizeRules(rules, refs, ident) {\n    if (Array.isArray(rules)) {\n      return rules.map((rule, idx) => {\n        return RuleSet.normalizeRule(rule, refs, `${ident}-${idx}`);\n      });\n    } else if (rules) {\n      return [RuleSet.normalizeRule(rules, refs, ident)];\n    } else {\n      return [];\n    }\n  }\n  static normalizeRule(rule, refs, ident) {\n    if (typeof rule === \"string\") {\n      return {\n        use: [{\n          loader: rule\n        }]\n      };\n    }\n    if (!rule) {\n      throw new Error(\"Unexcepted null when object was expected as rule\");\n    }\n    if (typeof rule !== \"object\") {\n      throw new Error(\"Unexcepted \" + typeof rule + \" when object was expected as rule (\" + rule + \")\");\n    }\n    const newRule = {};\n    let useSource;\n    let resourceSource;\n    let condition;\n    const checkUseSource = newSource => {\n      if (useSource && useSource !== newSource) {\n        throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"Rule can only have one result source (provided \" + newSource + \" and \" + useSource + \")\")));\n      }\n      useSource = newSource;\n    };\n    const checkResourceSource = newSource => {\n      if (resourceSource && resourceSource !== newSource) {\n        throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"Rule can only have one resource source (provided \" + newSource + \" and \" + resourceSource + \")\")));\n      }\n      resourceSource = newSource;\n    };\n    if (rule.test || rule.include || rule.exclude) {\n      checkResourceSource(\"test + include + exclude\");\n      condition = {\n        test: rule.test,\n        include: rule.include,\n        exclude: rule.exclude\n      };\n      try {\n        newRule.resource = RuleSet.normalizeCondition(condition);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(condition, error));\n      }\n    }\n    if (rule.resource) {\n      checkResourceSource(\"resource\");\n      try {\n        newRule.resource = RuleSet.normalizeCondition(rule.resource);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.resource, error));\n      }\n    }\n    if (rule.realResource) {\n      try {\n        newRule.realResource = RuleSet.normalizeCondition(rule.realResource);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.realResource, error));\n      }\n    }\n    if (rule.resourceQuery) {\n      try {\n        newRule.resourceQuery = RuleSet.normalizeCondition(rule.resourceQuery);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.resourceQuery, error));\n      }\n    }\n    if (rule.compiler) {\n      try {\n        newRule.compiler = RuleSet.normalizeCondition(rule.compiler);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.compiler, error));\n      }\n    }\n    if (rule.issuer) {\n      try {\n        newRule.issuer = RuleSet.normalizeCondition(rule.issuer);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.issuer, error));\n      }\n    }\n    if (rule.loader && rule.loaders) {\n      throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"Provided loader and loaders for rule (use only one of them)\")));\n    }\n    const loader = rule.loaders || rule.loader;\n    if (typeof loader === \"string\" && !rule.options && !rule.query) {\n      checkUseSource(\"loader\");\n      newRule.use = RuleSet.normalizeUse(loader.split(\"!\"), ident);\n    } else if (typeof loader === \"string\" && (rule.options || rule.query)) {\n      checkUseSource(\"loader + options/query\");\n      newRule.use = RuleSet.normalizeUse({\n        loader: loader,\n        options: rule.options,\n        query: rule.query\n      }, ident);\n    } else if (loader && (rule.options || rule.query)) {\n      throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"options/query cannot be used with loaders (use options for each array item)\")));\n    } else if (loader) {\n      checkUseSource(\"loaders\");\n      newRule.use = RuleSet.normalizeUse(loader, ident);\n    } else if (rule.options || rule.query) {\n      throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"options/query provided without loader (use loader + options)\")));\n    }\n    if (rule.use) {\n      checkUseSource(\"use\");\n      newRule.use = RuleSet.normalizeUse(rule.use, ident);\n    }\n    if (rule.rules) {\n      newRule.rules = RuleSet.normalizeRules(rule.rules, refs, `${ident}-rules`);\n    }\n    if (rule.oneOf) {\n      newRule.oneOf = RuleSet.normalizeRules(rule.oneOf, refs, `${ident}-oneOf`);\n    }\n    const keys = Object.keys(rule).filter(key => {\n      return ![\"resource\", \"resourceQuery\", \"compiler\", \"test\", \"include\", \"exclude\", \"issuer\", \"loader\", \"options\", \"query\", \"loaders\", \"use\", \"rules\", \"oneOf\"].includes(key);\n    });\n    for (const key of keys) {\n      newRule[key] = rule[key];\n    }\n    if (Array.isArray(newRule.use)) {\n      for (const item of newRule.use) {\n        if (item.ident) {\n          refs[item.ident] = item.options;\n        }\n      }\n    }\n    return newRule;\n  }\n  static buildErrorMessage(condition, error) {\n    const conditionAsText = JSON.stringify(condition, (key, value) => {\n      return value === undefined ? \"undefined\" : value;\n    }, 2);\n    return error.message + \" in \" + conditionAsText;\n  }\n  static normalizeUse(use, ident) {\n    if (typeof use === \"function\") {\n      return data => RuleSet.normalizeUse(use(data), ident);\n    }\n    if (Array.isArray(use)) {\n      return use.map((item, idx) => RuleSet.normalizeUse(item, `${ident}-${idx}`)).reduce((arr, items) => arr.concat(items), []);\n    }\n    return [RuleSet.normalizeUseItem(use, ident)];\n  }\n  static normalizeUseItemString(useItemString) {\n    const idx = useItemString.indexOf(\"?\");\n    if (idx >= 0) {\n      return {\n        loader: useItemString.substr(0, idx),\n        options: useItemString.substr(idx + 1)\n      };\n    }\n    return {\n      loader: useItemString,\n      options: undefined\n    };\n  }\n  static normalizeUseItem(item, ident) {\n    if (typeof item === \"string\") {\n      return RuleSet.normalizeUseItemString(item);\n    }\n    const newItem = {};\n    if (item.options && item.query) {\n      throw new Error(\"Provided options and query in use\");\n    }\n    if (!item.loader) {\n      throw new Error(\"No loader specified\");\n    }\n    newItem.options = item.options || item.query;\n    if (typeof newItem.options === \"object\" && newItem.options) {\n      if (newItem.options.ident) {\n        newItem.ident = newItem.options.ident;\n      } else {\n        newItem.ident = ident;\n      }\n    }\n    const keys = Object.keys(item).filter(function (key) {\n      return ![\"options\", \"query\"].includes(key);\n    });\n    for (const key of keys) {\n      newItem[key] = item[key];\n    }\n    return newItem;\n  }\n  static normalizeCondition(condition) {\n    if (!condition) throw new Error(\"Expected condition but got falsy value\");\n    if (typeof condition === \"string\") {\n      return str => str.indexOf(condition) === 0;\n    }\n    if (typeof condition === \"function\") {\n      return condition;\n    }\n    if (condition instanceof RegExp) {\n      return condition.test.bind(condition);\n    }\n    if (Array.isArray(condition)) {\n      const items = condition.map(c => RuleSet.normalizeCondition(c));\n      return orMatcher(items);\n    }\n    if (typeof condition !== \"object\") {\n      throw Error(\"Unexcepted \" + typeof condition + \" when condition was expected (\" + condition + \")\");\n    }\n    const matchers = [];\n    Object.keys(condition).forEach(key => {\n      const value = condition[key];\n      switch (key) {\n        case \"or\":\n        case \"include\":\n        case \"test\":\n          if (value) matchers.push(RuleSet.normalizeCondition(value));\n          break;\n        case \"and\":\n          if (value) {\n            const items = value.map(c => RuleSet.normalizeCondition(c));\n            matchers.push(andMatcher(items));\n          }\n          break;\n        case \"not\":\n        case \"exclude\":\n          if (value) {\n            const matcher = RuleSet.normalizeCondition(value);\n            matchers.push(notMatcher(matcher));\n          }\n          break;\n        default:\n          throw new Error(\"Unexcepted property \" + key + \" in condition\");\n      }\n    });\n    if (matchers.length === 0) {\n      throw new Error(\"Excepted condition but got \" + condition);\n    }\n    if (matchers.length === 1) {\n      return matchers[0];\n    }\n    return andMatcher(matchers);\n  }\n  exec(data) {\n    const result = [];\n    this._run(data, {\n      rules: this.rules\n    }, result);\n    return result;\n  }\n  _run(data, rule, result) {\n    // test conditions\n    if (rule.resource && !data.resource) return false;\n    if (rule.realResource && !data.realResource) return false;\n    if (rule.resourceQuery && !data.resourceQuery) return false;\n    if (rule.compiler && !data.compiler) return false;\n    if (rule.issuer && !data.issuer) return false;\n    if (rule.resource && !rule.resource(data.resource)) return false;\n    if (rule.realResource && !rule.realResource(data.realResource)) return false;\n    if (data.issuer && rule.issuer && !rule.issuer(data.issuer)) return false;\n    if (data.resourceQuery && rule.resourceQuery && !rule.resourceQuery(data.resourceQuery)) {\n      return false;\n    }\n    if (data.compiler && rule.compiler && !rule.compiler(data.compiler)) {\n      return false;\n    }\n\n    // apply\n    const keys = Object.keys(rule).filter(key => {\n      return ![\"resource\", \"realResource\", \"resourceQuery\", \"compiler\", \"issuer\", \"rules\", \"oneOf\", \"use\", \"enforce\"].includes(key);\n    });\n    for (const key of keys) {\n      result.push({\n        type: key,\n        value: rule[key]\n      });\n    }\n    if (rule.use) {\n      const process = use => {\n        if (typeof use === \"function\") {\n          process(use(data));\n        } else if (Array.isArray(use)) {\n          use.forEach(process);\n        } else {\n          result.push({\n            type: \"use\",\n            value: use,\n            enforce: rule.enforce\n          });\n        }\n      };\n      process(rule.use);\n    }\n    if (rule.rules) {\n      for (let i = 0; i < rule.rules.length; i++) {\n        this._run(data, rule.rules[i], result);\n      }\n    }\n    if (rule.oneOf) {\n      for (let i = 0; i < rule.oneOf.length; i++) {\n        if (this._run(data, rule.oneOf[i], result)) break;\n      }\n    }\n    return true;\n  }\n  findOptionsByIdent(ident) {\n    const options = this.references[ident];\n    if (!options) {\n      throw new Error(\"Can't find options with ident '\" + ident + \"'\");\n    }\n    return options;\n  }\n};","map":{"version":3,"names":["notMatcher","matcher","str","orMatcher","items","i","length","andMatcher","module","exports","RuleSet","constructor","rules","references","Object","create","normalizeRules","refs","ident","Array","isArray","map","rule","idx","normalizeRule","use","loader","Error","newRule","useSource","resourceSource","condition","checkUseSource","newSource","buildErrorMessage","checkResourceSource","test","include","exclude","resource","normalizeCondition","error","realResource","resourceQuery","compiler","issuer","loaders","options","query","normalizeUse","split","oneOf","keys","filter","key","includes","item","conditionAsText","JSON","stringify","value","undefined","message","data","reduce","arr","concat","normalizeUseItem","normalizeUseItemString","useItemString","indexOf","substr","newItem","RegExp","bind","c","matchers","forEach","push","exec","result","_run","type","process","enforce","findOptionsByIdent"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/RuleSet.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n/*\n<rules>: <rule>\n<rules>: [<rule>]\n<rule>: {\n\tresource: {\n\t\ttest: <condition>,\n\t\tinclude: <condition>,\n\t\texclude: <condition>,\n\t},\n\tresource: <condition>, -> resource.test\n\ttest: <condition>, -> resource.test\n\tinclude: <condition>, -> resource.include\n\texclude: <condition>, -> resource.exclude\n\tresourceQuery: <condition>,\n\tcompiler: <condition>,\n\tissuer: <condition>,\n\tuse: \"loader\", -> use[0].loader\n\tloader: <>, -> use[0].loader\n\tloaders: <>, -> use\n\toptions: {}, -> use[0].options,\n\tquery: {}, -> options\n\tparser: {},\n\tuse: [\n\t\t\"loader\" -> use[x].loader\n\t],\n\tuse: [\n\t\t{\n\t\t\tloader: \"loader\",\n\t\t\toptions: {}\n\t\t}\n\t],\n\trules: [\n\t\t<rule>\n\t],\n\toneOf: [\n\t\t<rule>\n\t]\n}\n\n<condition>: /regExp/\n<condition>: function(arg) {}\n<condition>: \"starting\"\n<condition>: [<condition>] // or\n<condition>: { and: [<condition>] }\n<condition>: { or: [<condition>] }\n<condition>: { not: [<condition>] }\n<condition>: { test: <condition>, include: <condition>, exclude: <condition> }\n\n\nnormalized:\n\n{\n\tresource: function(),\n\tresourceQuery: function(),\n\tcompiler: function(),\n\tissuer: function(),\n\tuse: [\n\t\t{\n\t\t\tloader: string,\n\t\t\toptions: string,\n\t\t\t<any>: <any>\n\t\t}\n\t],\n\trules: [<rule>],\n\toneOf: [<rule>],\n\t<any>: <any>,\n}\n\n*/\n\n\"use strict\";\n\nconst notMatcher = matcher => {\n\treturn str => {\n\t\treturn !matcher(str);\n\t};\n};\n\nconst orMatcher = items => {\n\treturn str => {\n\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\tif (items[i](str)) return true;\n\t\t}\n\t\treturn false;\n\t};\n};\n\nconst andMatcher = items => {\n\treturn str => {\n\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\tif (!items[i](str)) return false;\n\t\t}\n\t\treturn true;\n\t};\n};\n\nmodule.exports = class RuleSet {\n\tconstructor(rules) {\n\t\tthis.references = Object.create(null);\n\t\tthis.rules = RuleSet.normalizeRules(rules, this.references, \"ref-\");\n\t}\n\n\tstatic normalizeRules(rules, refs, ident) {\n\t\tif (Array.isArray(rules)) {\n\t\t\treturn rules.map((rule, idx) => {\n\t\t\t\treturn RuleSet.normalizeRule(rule, refs, `${ident}-${idx}`);\n\t\t\t});\n\t\t} else if (rules) {\n\t\t\treturn [RuleSet.normalizeRule(rules, refs, ident)];\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tstatic normalizeRule(rule, refs, ident) {\n\t\tif (typeof rule === \"string\") {\n\t\t\treturn {\n\t\t\t\tuse: [\n\t\t\t\t\t{\n\t\t\t\t\t\tloader: rule\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t};\n\t\t}\n\t\tif (!rule) {\n\t\t\tthrow new Error(\"Unexcepted null when object was expected as rule\");\n\t\t}\n\t\tif (typeof rule !== \"object\") {\n\t\t\tthrow new Error(\n\t\t\t\t\"Unexcepted \" +\n\t\t\t\t\ttypeof rule +\n\t\t\t\t\t\" when object was expected as rule (\" +\n\t\t\t\t\trule +\n\t\t\t\t\t\")\"\n\t\t\t);\n\t\t}\n\n\t\tconst newRule = {};\n\t\tlet useSource;\n\t\tlet resourceSource;\n\t\tlet condition;\n\n\t\tconst checkUseSource = newSource => {\n\t\t\tif (useSource && useSource !== newSource) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tRuleSet.buildErrorMessage(\n\t\t\t\t\t\trule,\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\"Rule can only have one result source (provided \" +\n\t\t\t\t\t\t\t\tnewSource +\n\t\t\t\t\t\t\t\t\" and \" +\n\t\t\t\t\t\t\t\tuseSource +\n\t\t\t\t\t\t\t\t\")\"\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tuseSource = newSource;\n\t\t};\n\n\t\tconst checkResourceSource = newSource => {\n\t\t\tif (resourceSource && resourceSource !== newSource) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tRuleSet.buildErrorMessage(\n\t\t\t\t\t\trule,\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\"Rule can only have one resource source (provided \" +\n\t\t\t\t\t\t\t\tnewSource +\n\t\t\t\t\t\t\t\t\" and \" +\n\t\t\t\t\t\t\t\tresourceSource +\n\t\t\t\t\t\t\t\t\")\"\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tresourceSource = newSource;\n\t\t};\n\n\t\tif (rule.test || rule.include || rule.exclude) {\n\t\t\tcheckResourceSource(\"test + include + exclude\");\n\t\t\tcondition = {\n\t\t\t\ttest: rule.test,\n\t\t\t\tinclude: rule.include,\n\t\t\t\texclude: rule.exclude\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tnewRule.resource = RuleSet.normalizeCondition(condition);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(condition, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.resource) {\n\t\t\tcheckResourceSource(\"resource\");\n\t\t\ttry {\n\t\t\t\tnewRule.resource = RuleSet.normalizeCondition(rule.resource);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(rule.resource, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.realResource) {\n\t\t\ttry {\n\t\t\t\tnewRule.realResource = RuleSet.normalizeCondition(rule.realResource);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(rule.realResource, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.resourceQuery) {\n\t\t\ttry {\n\t\t\t\tnewRule.resourceQuery = RuleSet.normalizeCondition(rule.resourceQuery);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(rule.resourceQuery, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.compiler) {\n\t\t\ttry {\n\t\t\t\tnewRule.compiler = RuleSet.normalizeCondition(rule.compiler);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(rule.compiler, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.issuer) {\n\t\t\ttry {\n\t\t\t\tnewRule.issuer = RuleSet.normalizeCondition(rule.issuer);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(rule.issuer, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.loader && rule.loaders) {\n\t\t\tthrow new Error(\n\t\t\t\tRuleSet.buildErrorMessage(\n\t\t\t\t\trule,\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\"Provided loader and loaders for rule (use only one of them)\"\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tconst loader = rule.loaders || rule.loader;\n\t\tif (typeof loader === \"string\" && !rule.options && !rule.query) {\n\t\t\tcheckUseSource(\"loader\");\n\t\t\tnewRule.use = RuleSet.normalizeUse(loader.split(\"!\"), ident);\n\t\t} else if (typeof loader === \"string\" && (rule.options || rule.query)) {\n\t\t\tcheckUseSource(\"loader + options/query\");\n\t\t\tnewRule.use = RuleSet.normalizeUse(\n\t\t\t\t{\n\t\t\t\t\tloader: loader,\n\t\t\t\t\toptions: rule.options,\n\t\t\t\t\tquery: rule.query\n\t\t\t\t},\n\t\t\t\tident\n\t\t\t);\n\t\t} else if (loader && (rule.options || rule.query)) {\n\t\t\tthrow new Error(\n\t\t\t\tRuleSet.buildErrorMessage(\n\t\t\t\t\trule,\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\"options/query cannot be used with loaders (use options for each array item)\"\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t} else if (loader) {\n\t\t\tcheckUseSource(\"loaders\");\n\t\t\tnewRule.use = RuleSet.normalizeUse(loader, ident);\n\t\t} else if (rule.options || rule.query) {\n\t\t\tthrow new Error(\n\t\t\t\tRuleSet.buildErrorMessage(\n\t\t\t\t\trule,\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\"options/query provided without loader (use loader + options)\"\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif (rule.use) {\n\t\t\tcheckUseSource(\"use\");\n\t\t\tnewRule.use = RuleSet.normalizeUse(rule.use, ident);\n\t\t}\n\n\t\tif (rule.rules) {\n\t\t\tnewRule.rules = RuleSet.normalizeRules(\n\t\t\t\trule.rules,\n\t\t\t\trefs,\n\t\t\t\t`${ident}-rules`\n\t\t\t);\n\t\t}\n\n\t\tif (rule.oneOf) {\n\t\t\tnewRule.oneOf = RuleSet.normalizeRules(\n\t\t\t\trule.oneOf,\n\t\t\t\trefs,\n\t\t\t\t`${ident}-oneOf`\n\t\t\t);\n\t\t}\n\n\t\tconst keys = Object.keys(rule).filter(key => {\n\t\t\treturn ![\n\t\t\t\t\"resource\",\n\t\t\t\t\"resourceQuery\",\n\t\t\t\t\"compiler\",\n\t\t\t\t\"test\",\n\t\t\t\t\"include\",\n\t\t\t\t\"exclude\",\n\t\t\t\t\"issuer\",\n\t\t\t\t\"loader\",\n\t\t\t\t\"options\",\n\t\t\t\t\"query\",\n\t\t\t\t\"loaders\",\n\t\t\t\t\"use\",\n\t\t\t\t\"rules\",\n\t\t\t\t\"oneOf\"\n\t\t\t].includes(key);\n\t\t});\n\t\tfor (const key of keys) {\n\t\t\tnewRule[key] = rule[key];\n\t\t}\n\n\t\tif (Array.isArray(newRule.use)) {\n\t\t\tfor (const item of newRule.use) {\n\t\t\t\tif (item.ident) {\n\t\t\t\t\trefs[item.ident] = item.options;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn newRule;\n\t}\n\n\tstatic buildErrorMessage(condition, error) {\n\t\tconst conditionAsText = JSON.stringify(\n\t\t\tcondition,\n\t\t\t(key, value) => {\n\t\t\t\treturn value === undefined ? \"undefined\" : value;\n\t\t\t},\n\t\t\t2\n\t\t);\n\t\treturn error.message + \" in \" + conditionAsText;\n\t}\n\n\tstatic normalizeUse(use, ident) {\n\t\tif (typeof use === \"function\") {\n\t\t\treturn data => RuleSet.normalizeUse(use(data), ident);\n\t\t}\n\t\tif (Array.isArray(use)) {\n\t\t\treturn use\n\t\t\t\t.map((item, idx) => RuleSet.normalizeUse(item, `${ident}-${idx}`))\n\t\t\t\t.reduce((arr, items) => arr.concat(items), []);\n\t\t}\n\t\treturn [RuleSet.normalizeUseItem(use, ident)];\n\t}\n\n\tstatic normalizeUseItemString(useItemString) {\n\t\tconst idx = useItemString.indexOf(\"?\");\n\t\tif (idx >= 0) {\n\t\t\treturn {\n\t\t\t\tloader: useItemString.substr(0, idx),\n\t\t\t\toptions: useItemString.substr(idx + 1)\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tloader: useItemString,\n\t\t\toptions: undefined\n\t\t};\n\t}\n\n\tstatic normalizeUseItem(item, ident) {\n\t\tif (typeof item === \"string\") {\n\t\t\treturn RuleSet.normalizeUseItemString(item);\n\t\t}\n\n\t\tconst newItem = {};\n\n\t\tif (item.options && item.query) {\n\t\t\tthrow new Error(\"Provided options and query in use\");\n\t\t}\n\n\t\tif (!item.loader) {\n\t\t\tthrow new Error(\"No loader specified\");\n\t\t}\n\n\t\tnewItem.options = item.options || item.query;\n\n\t\tif (typeof newItem.options === \"object\" && newItem.options) {\n\t\t\tif (newItem.options.ident) {\n\t\t\t\tnewItem.ident = newItem.options.ident;\n\t\t\t} else {\n\t\t\t\tnewItem.ident = ident;\n\t\t\t}\n\t\t}\n\n\t\tconst keys = Object.keys(item).filter(function(key) {\n\t\t\treturn ![\"options\", \"query\"].includes(key);\n\t\t});\n\n\t\tfor (const key of keys) {\n\t\t\tnewItem[key] = item[key];\n\t\t}\n\n\t\treturn newItem;\n\t}\n\n\tstatic normalizeCondition(condition) {\n\t\tif (!condition) throw new Error(\"Expected condition but got falsy value\");\n\t\tif (typeof condition === \"string\") {\n\t\t\treturn str => str.indexOf(condition) === 0;\n\t\t}\n\t\tif (typeof condition === \"function\") {\n\t\t\treturn condition;\n\t\t}\n\t\tif (condition instanceof RegExp) {\n\t\t\treturn condition.test.bind(condition);\n\t\t}\n\t\tif (Array.isArray(condition)) {\n\t\t\tconst items = condition.map(c => RuleSet.normalizeCondition(c));\n\t\t\treturn orMatcher(items);\n\t\t}\n\t\tif (typeof condition !== \"object\") {\n\t\t\tthrow Error(\n\t\t\t\t\"Unexcepted \" +\n\t\t\t\t\ttypeof condition +\n\t\t\t\t\t\" when condition was expected (\" +\n\t\t\t\t\tcondition +\n\t\t\t\t\t\")\"\n\t\t\t);\n\t\t}\n\n\t\tconst matchers = [];\n\t\tObject.keys(condition).forEach(key => {\n\t\t\tconst value = condition[key];\n\t\t\tswitch (key) {\n\t\t\t\tcase \"or\":\n\t\t\t\tcase \"include\":\n\t\t\t\tcase \"test\":\n\t\t\t\t\tif (value) matchers.push(RuleSet.normalizeCondition(value));\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"and\":\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tconst items = value.map(c => RuleSet.normalizeCondition(c));\n\t\t\t\t\t\tmatchers.push(andMatcher(items));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"not\":\n\t\t\t\tcase \"exclude\":\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tconst matcher = RuleSet.normalizeCondition(value);\n\t\t\t\t\t\tmatchers.push(notMatcher(matcher));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"Unexcepted property \" + key + \" in condition\");\n\t\t\t}\n\t\t});\n\t\tif (matchers.length === 0) {\n\t\t\tthrow new Error(\"Excepted condition but got \" + condition);\n\t\t}\n\t\tif (matchers.length === 1) {\n\t\t\treturn matchers[0];\n\t\t}\n\t\treturn andMatcher(matchers);\n\t}\n\n\texec(data) {\n\t\tconst result = [];\n\t\tthis._run(\n\t\t\tdata,\n\t\t\t{\n\t\t\t\trules: this.rules\n\t\t\t},\n\t\t\tresult\n\t\t);\n\t\treturn result;\n\t}\n\n\t_run(data, rule, result) {\n\t\t// test conditions\n\t\tif (rule.resource && !data.resource) return false;\n\t\tif (rule.realResource && !data.realResource) return false;\n\t\tif (rule.resourceQuery && !data.resourceQuery) return false;\n\t\tif (rule.compiler && !data.compiler) return false;\n\t\tif (rule.issuer && !data.issuer) return false;\n\t\tif (rule.resource && !rule.resource(data.resource)) return false;\n\t\tif (rule.realResource && !rule.realResource(data.realResource))\n\t\t\treturn false;\n\t\tif (data.issuer && rule.issuer && !rule.issuer(data.issuer)) return false;\n\t\tif (\n\t\t\tdata.resourceQuery &&\n\t\t\trule.resourceQuery &&\n\t\t\t!rule.resourceQuery(data.resourceQuery)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tif (data.compiler && rule.compiler && !rule.compiler(data.compiler)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// apply\n\t\tconst keys = Object.keys(rule).filter(key => {\n\t\t\treturn ![\n\t\t\t\t\"resource\",\n\t\t\t\t\"realResource\",\n\t\t\t\t\"resourceQuery\",\n\t\t\t\t\"compiler\",\n\t\t\t\t\"issuer\",\n\t\t\t\t\"rules\",\n\t\t\t\t\"oneOf\",\n\t\t\t\t\"use\",\n\t\t\t\t\"enforce\"\n\t\t\t].includes(key);\n\t\t});\n\t\tfor (const key of keys) {\n\t\t\tresult.push({\n\t\t\t\ttype: key,\n\t\t\t\tvalue: rule[key]\n\t\t\t});\n\t\t}\n\n\t\tif (rule.use) {\n\t\t\tconst process = use => {\n\t\t\t\tif (typeof use === \"function\") {\n\t\t\t\t\tprocess(use(data));\n\t\t\t\t} else if (Array.isArray(use)) {\n\t\t\t\t\tuse.forEach(process);\n\t\t\t\t} else {\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\ttype: \"use\",\n\t\t\t\t\t\tvalue: use,\n\t\t\t\t\t\tenforce: rule.enforce\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t\tprocess(rule.use);\n\t\t}\n\n\t\tif (rule.rules) {\n\t\t\tfor (let i = 0; i < rule.rules.length; i++) {\n\t\t\t\tthis._run(data, rule.rules[i], result);\n\t\t\t}\n\t\t}\n\n\t\tif (rule.oneOf) {\n\t\t\tfor (let i = 0; i < rule.oneOf.length; i++) {\n\t\t\t\tif (this._run(data, rule.oneOf[i], result)) break;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfindOptionsByIdent(ident) {\n\t\tconst options = this.references[ident];\n\t\tif (!options) {\n\t\t\tthrow new Error(\"Can't find options with ident '\" + ident + \"'\");\n\t\t}\n\t\treturn options;\n\t}\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}