{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\n// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\nconst acorn = require(\"acorn\");\nconst {\n  Tapable,\n  SyncBailHook,\n  HookMap\n} = require(\"tapable\");\nconst util = require(\"util\");\nconst vm = require(\"vm\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\nconst StackedSetMap = require(\"./util/StackedSetMap\");\nconst acornParser = acorn.Parser;\nconst joinRanges = (startRange, endRange) => {\n  if (!endRange) return startRange;\n  if (!startRange) return endRange;\n  return [startRange[0], endRange[1]];\n};\nconst defaultParserOptions = {\n  ranges: true,\n  locations: true,\n  ecmaVersion: 11,\n  sourceType: \"module\",\n  onComment: null\n};\n\n// regexp to match at least one \"magic comment\"\nconst webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\nconst EMPTY_COMMENT_OPTIONS = {\n  options: null,\n  errors: null\n};\nclass Parser extends Tapable {\n  constructor(options, sourceType = \"auto\") {\n    super();\n    this.hooks = {\n      evaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n      evaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n      evaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n      evaluateDefinedIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n      evaluateCallExpressionMember: new HookMap(() => new SyncBailHook([\"expression\", \"param\"])),\n      statement: new SyncBailHook([\"statement\"]),\n      statementIf: new SyncBailHook([\"statement\"]),\n      label: new HookMap(() => new SyncBailHook([\"statement\"])),\n      import: new SyncBailHook([\"statement\", \"source\"]),\n      importSpecifier: new SyncBailHook([\"statement\", \"source\", \"exportName\", \"identifierName\"]),\n      export: new SyncBailHook([\"statement\"]),\n      exportImport: new SyncBailHook([\"statement\", \"source\"]),\n      exportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportSpecifier: new SyncBailHook([\"statement\", \"identifierName\", \"exportName\", \"index\"]),\n      exportImportSpecifier: new SyncBailHook([\"statement\", \"source\", \"identifierName\", \"exportName\", \"index\"]),\n      varDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      varDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      varDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      varDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      canRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n      rename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n      assigned: new HookMap(() => new SyncBailHook([\"expression\"])),\n      assign: new HookMap(() => new SyncBailHook([\"expression\"])),\n      typeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n      importCall: new SyncBailHook([\"expression\"]),\n      call: new HookMap(() => new SyncBailHook([\"expression\"])),\n      callAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n      new: new HookMap(() => new SyncBailHook([\"expression\"])),\n      expression: new HookMap(() => new SyncBailHook([\"expression\"])),\n      expressionAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n      expressionConditionalOperator: new SyncBailHook([\"expression\"]),\n      expressionLogicalOperator: new SyncBailHook([\"expression\"]),\n      program: new SyncBailHook([\"ast\", \"comments\"])\n    };\n    const HOOK_MAP_COMPAT_CONFIG = {\n      evaluateTypeof: /^evaluate typeof (.+)$/,\n      evaluateIdentifier: /^evaluate Identifier (.+)$/,\n      evaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,\n      evaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,\n      evaluate: /^evaluate (.+)$/,\n      label: /^label (.+)$/,\n      varDeclarationLet: /^var-let (.+)$/,\n      varDeclarationConst: /^var-const (.+)$/,\n      varDeclarationVar: /^var-var (.+)$/,\n      varDeclaration: /^var (.+)$/,\n      canRename: /^can-rename (.+)$/,\n      rename: /^rename (.+)$/,\n      typeof: /^typeof (.+)$/,\n      assigned: /^assigned (.+)$/,\n      assign: /^assign (.+)$/,\n      callAnyMember: /^call (.+)\\.\\*$/,\n      call: /^call (.+)$/,\n      new: /^new (.+)$/,\n      expressionConditionalOperator: /^expression \\?:$/,\n      expressionAnyMember: /^expression (.+)\\.\\*$/,\n      expression: /^expression (.+)$/\n    };\n    this._pluginCompat.tap(\"Parser\", options => {\n      for (const name of Object.keys(HOOK_MAP_COMPAT_CONFIG)) {\n        const regexp = HOOK_MAP_COMPAT_CONFIG[name];\n        const match = regexp.exec(options.name);\n        if (match) {\n          if (match[1]) {\n            this.hooks[name].tap(match[1], options.fn.name || \"unnamed compat plugin\", options.fn.bind(this));\n          } else {\n            this.hooks[name].tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(this));\n          }\n          return true;\n        }\n      }\n    });\n    this.options = options;\n    this.sourceType = sourceType;\n    this.scope = undefined;\n    this.state = undefined;\n    this.comments = undefined;\n    this.initializeEvaluating();\n  }\n  initializeEvaluating() {\n    this.hooks.evaluate.for(\"Literal\").tap(\"Parser\", expr => {\n      switch (typeof expr.value) {\n        case \"number\":\n          return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);\n        case \"string\":\n          return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);\n        case \"boolean\":\n          return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);\n      }\n      if (expr.value === null) {\n        return new BasicEvaluatedExpression().setNull().setRange(expr.range);\n      }\n      if (expr.value instanceof RegExp) {\n        return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);\n      }\n    });\n    this.hooks.evaluate.for(\"LogicalExpression\").tap(\"Parser\", expr => {\n      let left;\n      let leftAsBool;\n      let right;\n      if (expr.operator === \"&&\") {\n        left = this.evaluateExpression(expr.left);\n        leftAsBool = left && left.asBool();\n        if (leftAsBool === false) return left.setRange(expr.range);\n        if (leftAsBool !== true) return;\n        right = this.evaluateExpression(expr.right);\n        return right.setRange(expr.range);\n      } else if (expr.operator === \"||\") {\n        left = this.evaluateExpression(expr.left);\n        leftAsBool = left && left.asBool();\n        if (leftAsBool === true) return left.setRange(expr.range);\n        if (leftAsBool !== false) return;\n        right = this.evaluateExpression(expr.right);\n        return right.setRange(expr.range);\n      }\n    });\n    this.hooks.evaluate.for(\"BinaryExpression\").tap(\"Parser\", expr => {\n      let left;\n      let right;\n      let res;\n      if (expr.operator === \"+\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        res = new BasicEvaluatedExpression();\n        if (left.isString()) {\n          if (right.isString()) {\n            res.setString(left.string + right.string);\n          } else if (right.isNumber()) {\n            res.setString(left.string + right.number);\n          } else if (right.isWrapped() && right.prefix && right.prefix.isString()) {\n            // \"left\" + (\"prefix\" + inner + \"postfix\")\n            // => (\"leftprefix\" + inner + \"postfix\")\n            res.setWrapped(new BasicEvaluatedExpression().setString(left.string + right.prefix.string).setRange(joinRanges(left.range, right.prefix.range)), right.postfix, right.wrappedInnerExpressions);\n          } else if (right.isWrapped()) {\n            // \"left\" + ([null] + inner + \"postfix\")\n            // => (\"left\" + inner + \"postfix\")\n            res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n          } else {\n            // \"left\" + expr\n            // => (\"left\" + expr + \"\")\n            res.setWrapped(left, null, [right]);\n          }\n        } else if (left.isNumber()) {\n          if (right.isString()) {\n            res.setString(left.number + right.string);\n          } else if (right.isNumber()) {\n            res.setNumber(left.number + right.number);\n          } else {\n            return;\n          }\n        } else if (left.isWrapped()) {\n          if (left.postfix && left.postfix.isString() && right.isString()) {\n            // (\"prefix\" + inner + \"postfix\") + \"right\"\n            // => (\"prefix\" + inner + \"postfixright\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.string).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n          } else if (left.postfix && left.postfix.isString() && right.isNumber()) {\n            // (\"prefix\" + inner + \"postfix\") + 123\n            // => (\"prefix\" + inner + \"postfix123\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.number).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n          } else if (right.isString()) {\n            // (\"prefix\" + inner + [null]) + \"right\"\n            // => (\"prefix\" + inner + \"right\")\n            res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n          } else if (right.isNumber()) {\n            // (\"prefix\" + inner + [null]) + 123\n            // => (\"prefix\" + inner + \"123\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(right.number + \"\").setRange(right.range), left.wrappedInnerExpressions);\n          } else if (right.isWrapped()) {\n            // (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n            // (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n            res.setWrapped(left.prefix, right.postfix, left.wrappedInnerExpressions && right.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix] : []).concat(right.prefix ? [right.prefix] : []).concat(right.wrappedInnerExpressions));\n          } else {\n            // (\"prefix\" + inner + postfix) + expr\n            // => (\"prefix\" + inner + postfix + expr + [null])\n            res.setWrapped(left.prefix, null, left.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix, right] : [right]));\n          }\n        } else {\n          if (right.isString()) {\n            // left + \"right\"\n            // => ([null] + left + \"right\")\n            res.setWrapped(null, right, [left]);\n          } else if (right.isWrapped()) {\n            // left + (prefix + inner + \"postfix\")\n            // => ([null] + left + prefix + inner + \"postfix\")\n            res.setWrapped(null, right.postfix, right.wrappedInnerExpressions && (right.prefix ? [left, right.prefix] : [left]).concat(right.wrappedInnerExpressions));\n          } else {\n            return;\n          }\n        }\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"-\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number - right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"*\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number * right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"/\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number / right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"**\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(Math.pow(left.number, right.number));\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"==\" || expr.operator === \"===\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        res = new BasicEvaluatedExpression();\n        res.setRange(expr.range);\n        if (left.isString() && right.isString()) {\n          return res.setBoolean(left.string === right.string);\n        } else if (left.isNumber() && right.isNumber()) {\n          return res.setBoolean(left.number === right.number);\n        } else if (left.isBoolean() && right.isBoolean()) {\n          return res.setBoolean(left.bool === right.bool);\n        }\n      } else if (expr.operator === \"!=\" || expr.operator === \"!==\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        res = new BasicEvaluatedExpression();\n        res.setRange(expr.range);\n        if (left.isString() && right.isString()) {\n          return res.setBoolean(left.string !== right.string);\n        } else if (left.isNumber() && right.isNumber()) {\n          return res.setBoolean(left.number !== right.number);\n        } else if (left.isBoolean() && right.isBoolean()) {\n          return res.setBoolean(left.bool !== right.bool);\n        }\n      } else if (expr.operator === \"&\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number & right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"|\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number | right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"^\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number ^ right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \">>>\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number >>> right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \">>\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number >> right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"<<\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number << right.number);\n        res.setRange(expr.range);\n        return res;\n      }\n    });\n    this.hooks.evaluate.for(\"UnaryExpression\").tap(\"Parser\", expr => {\n      if (expr.operator === \"typeof\") {\n        let res;\n        let name;\n        if (expr.argument.type === \"Identifier\") {\n          name = this.scope.renames.get(expr.argument.name) || expr.argument.name;\n          if (!this.scope.definitions.has(name)) {\n            const hook = this.hooks.evaluateTypeof.get(name);\n            if (hook !== undefined) {\n              res = hook.call(expr);\n              if (res !== undefined) return res;\n            }\n          }\n        }\n        if (expr.argument.type === \"MemberExpression\") {\n          const exprName = this.getNameForExpression(expr.argument);\n          if (exprName && exprName.free) {\n            const hook = this.hooks.evaluateTypeof.get(exprName.name);\n            if (hook !== undefined) {\n              res = hook.call(expr);\n              if (res !== undefined) return res;\n            }\n          }\n        }\n        if (expr.argument.type === \"FunctionExpression\") {\n          return new BasicEvaluatedExpression().setString(\"function\").setRange(expr.range);\n        }\n        const arg = this.evaluateExpression(expr.argument);\n        if (arg.isString() || arg.isWrapped()) {\n          return new BasicEvaluatedExpression().setString(\"string\").setRange(expr.range);\n        }\n        if (arg.isNumber()) {\n          return new BasicEvaluatedExpression().setString(\"number\").setRange(expr.range);\n        }\n        if (arg.isBoolean()) {\n          return new BasicEvaluatedExpression().setString(\"boolean\").setRange(expr.range);\n        }\n        if (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {\n          return new BasicEvaluatedExpression().setString(\"object\").setRange(expr.range);\n        }\n      } else if (expr.operator === \"!\") {\n        const argument = this.evaluateExpression(expr.argument);\n        if (!argument) return;\n        if (argument.isBoolean()) {\n          return new BasicEvaluatedExpression().setBoolean(!argument.bool).setRange(expr.range);\n        }\n        if (argument.isTruthy()) {\n          return new BasicEvaluatedExpression().setBoolean(false).setRange(expr.range);\n        }\n        if (argument.isFalsy()) {\n          return new BasicEvaluatedExpression().setBoolean(true).setRange(expr.range);\n        }\n        if (argument.isString()) {\n          return new BasicEvaluatedExpression().setBoolean(!argument.string).setRange(expr.range);\n        }\n        if (argument.isNumber()) {\n          return new BasicEvaluatedExpression().setBoolean(!argument.number).setRange(expr.range);\n        }\n      } else if (expr.operator === \"~\") {\n        const argument = this.evaluateExpression(expr.argument);\n        if (!argument) return;\n        if (!argument.isNumber()) return;\n        const res = new BasicEvaluatedExpression();\n        res.setNumber(~argument.number);\n        res.setRange(expr.range);\n        return res;\n      }\n    });\n    this.hooks.evaluateTypeof.for(\"undefined\").tap(\"Parser\", expr => {\n      return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n    });\n    this.hooks.evaluate.for(\"Identifier\").tap(\"Parser\", expr => {\n      const name = this.scope.renames.get(expr.name) || expr.name;\n      if (!this.scope.definitions.has(expr.name)) {\n        const hook = this.hooks.evaluateIdentifier.get(name);\n        if (hook !== undefined) {\n          const result = hook.call(expr);\n          if (result) return result;\n        }\n        return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n      } else {\n        const hook = this.hooks.evaluateDefinedIdentifier.get(name);\n        if (hook !== undefined) {\n          return hook.call(expr);\n        }\n      }\n    });\n    this.hooks.evaluate.for(\"ThisExpression\").tap(\"Parser\", expr => {\n      const name = this.scope.renames.get(\"this\");\n      if (name) {\n        const hook = this.hooks.evaluateIdentifier.get(name);\n        if (hook !== undefined) {\n          const result = hook.call(expr);\n          if (result) return result;\n        }\n        return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n      }\n    });\n    this.hooks.evaluate.for(\"MemberExpression\").tap(\"Parser\", expression => {\n      let exprName = this.getNameForExpression(expression);\n      if (exprName) {\n        if (exprName.free) {\n          const hook = this.hooks.evaluateIdentifier.get(exprName.name);\n          if (hook !== undefined) {\n            const result = hook.call(expression);\n            if (result) return result;\n          }\n          return new BasicEvaluatedExpression().setIdentifier(exprName.name).setRange(expression.range);\n        } else {\n          const hook = this.hooks.evaluateDefinedIdentifier.get(exprName.name);\n          if (hook !== undefined) {\n            return hook.call(expression);\n          }\n        }\n      }\n    });\n    this.hooks.evaluate.for(\"CallExpression\").tap(\"Parser\", expr => {\n      if (expr.callee.type !== \"MemberExpression\") return;\n      if (expr.callee.property.type !== (expr.callee.computed ? \"Literal\" : \"Identifier\")) return;\n      const param = this.evaluateExpression(expr.callee.object);\n      if (!param) return;\n      const property = expr.callee.property.name || expr.callee.property.value;\n      const hook = this.hooks.evaluateCallExpressionMember.get(property);\n      if (hook !== undefined) {\n        return hook.call(expr, param);\n      }\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"replace\").tap(\"Parser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length !== 2) return;\n      let arg1 = this.evaluateExpression(expr.arguments[0]);\n      let arg2 = this.evaluateExpression(expr.arguments[1]);\n      if (!arg1.isString() && !arg1.isRegExp()) return;\n      arg1 = arg1.regExp || arg1.string;\n      if (!arg2.isString()) return;\n      arg2 = arg2.string;\n      return new BasicEvaluatedExpression().setString(param.string.replace(arg1, arg2)).setRange(expr.range);\n    });\n    [\"substr\", \"substring\"].forEach(fn => {\n      this.hooks.evaluateCallExpressionMember.for(fn).tap(\"Parser\", (expr, param) => {\n        if (!param.isString()) return;\n        let arg1;\n        let result,\n          str = param.string;\n        switch (expr.arguments.length) {\n          case 1:\n            arg1 = this.evaluateExpression(expr.arguments[0]);\n            if (!arg1.isNumber()) return;\n            result = str[fn](arg1.number);\n            break;\n          case 2:\n            {\n              arg1 = this.evaluateExpression(expr.arguments[0]);\n              const arg2 = this.evaluateExpression(expr.arguments[1]);\n              if (!arg1.isNumber()) return;\n              if (!arg2.isNumber()) return;\n              result = str[fn](arg1.number, arg2.number);\n              break;\n            }\n          default:\n            return;\n        }\n        return new BasicEvaluatedExpression().setString(result).setRange(expr.range);\n      });\n    });\n\n    /**\n     * @param {string} kind \"cooked\" | \"raw\"\n     * @param {TODO} templateLiteralExpr TemplateLiteral expr\n     * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n     */\n    const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n      const quasis = [];\n      const parts = [];\n      for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n        const quasiExpr = templateLiteralExpr.quasis[i];\n        const quasi = quasiExpr.value[kind];\n        if (i > 0) {\n          const prevExpr = parts[parts.length - 1];\n          const expr = this.evaluateExpression(templateLiteralExpr.expressions[i - 1]);\n          const exprAsString = expr.asString();\n          if (typeof exprAsString === \"string\") {\n            // We can merge quasi + expr + quasi when expr\n            // is a const string\n\n            prevExpr.setString(prevExpr.string + exprAsString + quasi);\n            prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);\n            // We unset the expression as it doesn't match to a single expression\n            prevExpr.setExpression(undefined);\n            continue;\n          }\n          parts.push(expr);\n        }\n        const part = new BasicEvaluatedExpression().setString(quasi).setRange(quasiExpr.range).setExpression(quasiExpr);\n        quasis.push(part);\n        parts.push(part);\n      }\n      return {\n        quasis,\n        parts\n      };\n    };\n    this.hooks.evaluate.for(\"TemplateLiteral\").tap(\"Parser\", node => {\n      const {\n        quasis,\n        parts\n      } = getSimplifiedTemplateResult(\"cooked\", node);\n      if (parts.length === 1) {\n        return parts[0].setRange(node.range);\n      }\n      return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"cooked\").setRange(node.range);\n    });\n    this.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"Parser\", node => {\n      if (this.evaluateExpression(node.tag).identifier !== \"String.raw\") return;\n      const {\n        quasis,\n        parts\n      } = getSimplifiedTemplateResult(\"raw\", node.quasi);\n      if (parts.length === 1) {\n        return parts[0].setRange(node.range);\n      }\n      return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"raw\").setRange(node.range);\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"concat\").tap(\"Parser\", (expr, param) => {\n      if (!param.isString() && !param.isWrapped()) return;\n      let stringSuffix = null;\n      let hasUnknownParams = false;\n      for (let i = expr.arguments.length - 1; i >= 0; i--) {\n        const argExpr = this.evaluateExpression(expr.arguments[i]);\n        if (!argExpr.isString() && !argExpr.isNumber()) {\n          hasUnknownParams = true;\n          break;\n        }\n        const value = argExpr.isString() ? argExpr.string : \"\" + argExpr.number;\n        const newString = value + (stringSuffix ? stringSuffix.string : \"\");\n        const newRange = [argExpr.range[0], (stringSuffix || argExpr).range[1]];\n        stringSuffix = new BasicEvaluatedExpression().setString(newString).setRange(newRange);\n      }\n      if (hasUnknownParams) {\n        const prefix = param.isString() ? param : param.prefix;\n        return new BasicEvaluatedExpression().setWrapped(prefix, stringSuffix).setRange(expr.range);\n      } else if (param.isWrapped()) {\n        const postfix = stringSuffix || param.postfix;\n        return new BasicEvaluatedExpression().setWrapped(param.prefix, postfix).setRange(expr.range);\n      } else {\n        const newString = param.string + (stringSuffix ? stringSuffix.string : \"\");\n        return new BasicEvaluatedExpression().setString(newString).setRange(expr.range);\n      }\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"split\").tap(\"Parser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length !== 1) return;\n      let result;\n      const arg = this.evaluateExpression(expr.arguments[0]);\n      if (arg.isString()) {\n        result = param.string.split(arg.string);\n      } else if (arg.isRegExp()) {\n        result = param.string.split(arg.regExp);\n      } else {\n        return;\n      }\n      return new BasicEvaluatedExpression().setArray(result).setRange(expr.range);\n    });\n    this.hooks.evaluate.for(\"ConditionalExpression\").tap(\"Parser\", expr => {\n      const condition = this.evaluateExpression(expr.test);\n      const conditionValue = condition.asBool();\n      let res;\n      if (conditionValue === undefined) {\n        const consequent = this.evaluateExpression(expr.consequent);\n        const alternate = this.evaluateExpression(expr.alternate);\n        if (!consequent || !alternate) return;\n        res = new BasicEvaluatedExpression();\n        if (consequent.isConditional()) {\n          res.setOptions(consequent.options);\n        } else {\n          res.setOptions([consequent]);\n        }\n        if (alternate.isConditional()) {\n          res.addOptions(alternate.options);\n        } else {\n          res.addOptions([alternate]);\n        }\n      } else {\n        res = this.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);\n      }\n      res.setRange(expr.range);\n      return res;\n    });\n    this.hooks.evaluate.for(\"ArrayExpression\").tap(\"Parser\", expr => {\n      const items = expr.elements.map(element => {\n        return element !== null && this.evaluateExpression(element);\n      });\n      if (!items.every(Boolean)) return;\n      return new BasicEvaluatedExpression().setItems(items).setRange(expr.range);\n    });\n  }\n  getRenameIdentifier(expr) {\n    const result = this.evaluateExpression(expr);\n    if (result && result.isIdentifier()) {\n      return result.identifier;\n    }\n  }\n  walkClass(classy) {\n    if (classy.superClass) this.walkExpression(classy.superClass);\n    if (classy.body && classy.body.type === \"ClassBody\") {\n      const wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      for (const methodDefinition of classy.body.body) {\n        if (methodDefinition.type === \"MethodDefinition\") {\n          this.walkMethodDefinition(methodDefinition);\n        }\n      }\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }\n  walkMethodDefinition(methodDefinition) {\n    if (methodDefinition.computed && methodDefinition.key) {\n      this.walkExpression(methodDefinition.key);\n    }\n    if (methodDefinition.value) {\n      this.walkExpression(methodDefinition.value);\n    }\n  }\n\n  // Prewalking iterates the scope for variable declarations\n  prewalkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.prewalkStatement(statement);\n    }\n  }\n\n  // Block-Prewalking iterates the scope for block variable declarations\n  blockPrewalkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.blockPrewalkStatement(statement);\n    }\n  }\n\n  // Walking iterates the statements and expressions and processes them\n  walkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.walkStatement(statement);\n    }\n  }\n  prewalkStatement(statement) {\n    switch (statement.type) {\n      case \"BlockStatement\":\n        this.prewalkBlockStatement(statement);\n        break;\n      case \"DoWhileStatement\":\n        this.prewalkDoWhileStatement(statement);\n        break;\n      case \"ExportAllDeclaration\":\n        this.prewalkExportAllDeclaration(statement);\n        break;\n      case \"ExportDefaultDeclaration\":\n        this.prewalkExportDefaultDeclaration(statement);\n        break;\n      case \"ExportNamedDeclaration\":\n        this.prewalkExportNamedDeclaration(statement);\n        break;\n      case \"ForInStatement\":\n        this.prewalkForInStatement(statement);\n        break;\n      case \"ForOfStatement\":\n        this.prewalkForOfStatement(statement);\n        break;\n      case \"ForStatement\":\n        this.prewalkForStatement(statement);\n        break;\n      case \"FunctionDeclaration\":\n        this.prewalkFunctionDeclaration(statement);\n        break;\n      case \"IfStatement\":\n        this.prewalkIfStatement(statement);\n        break;\n      case \"ImportDeclaration\":\n        this.prewalkImportDeclaration(statement);\n        break;\n      case \"LabeledStatement\":\n        this.prewalkLabeledStatement(statement);\n        break;\n      case \"SwitchStatement\":\n        this.prewalkSwitchStatement(statement);\n        break;\n      case \"TryStatement\":\n        this.prewalkTryStatement(statement);\n        break;\n      case \"VariableDeclaration\":\n        this.prewalkVariableDeclaration(statement);\n        break;\n      case \"WhileStatement\":\n        this.prewalkWhileStatement(statement);\n        break;\n      case \"WithStatement\":\n        this.prewalkWithStatement(statement);\n        break;\n    }\n  }\n  blockPrewalkStatement(statement) {\n    switch (statement.type) {\n      case \"VariableDeclaration\":\n        this.blockPrewalkVariableDeclaration(statement);\n        break;\n      case \"ExportDefaultDeclaration\":\n        this.blockPrewalkExportDefaultDeclaration(statement);\n        break;\n      case \"ExportNamedDeclaration\":\n        this.blockPrewalkExportNamedDeclaration(statement);\n        break;\n      case \"ClassDeclaration\":\n        this.blockPrewalkClassDeclaration(statement);\n        break;\n    }\n  }\n  walkStatement(statement) {\n    if (this.hooks.statement.call(statement) !== undefined) return;\n    switch (statement.type) {\n      case \"BlockStatement\":\n        this.walkBlockStatement(statement);\n        break;\n      case \"ClassDeclaration\":\n        this.walkClassDeclaration(statement);\n        break;\n      case \"DoWhileStatement\":\n        this.walkDoWhileStatement(statement);\n        break;\n      case \"ExportDefaultDeclaration\":\n        this.walkExportDefaultDeclaration(statement);\n        break;\n      case \"ExportNamedDeclaration\":\n        this.walkExportNamedDeclaration(statement);\n        break;\n      case \"ExpressionStatement\":\n        this.walkExpressionStatement(statement);\n        break;\n      case \"ForInStatement\":\n        this.walkForInStatement(statement);\n        break;\n      case \"ForOfStatement\":\n        this.walkForOfStatement(statement);\n        break;\n      case \"ForStatement\":\n        this.walkForStatement(statement);\n        break;\n      case \"FunctionDeclaration\":\n        this.walkFunctionDeclaration(statement);\n        break;\n      case \"IfStatement\":\n        this.walkIfStatement(statement);\n        break;\n      case \"LabeledStatement\":\n        this.walkLabeledStatement(statement);\n        break;\n      case \"ReturnStatement\":\n        this.walkReturnStatement(statement);\n        break;\n      case \"SwitchStatement\":\n        this.walkSwitchStatement(statement);\n        break;\n      case \"ThrowStatement\":\n        this.walkThrowStatement(statement);\n        break;\n      case \"TryStatement\":\n        this.walkTryStatement(statement);\n        break;\n      case \"VariableDeclaration\":\n        this.walkVariableDeclaration(statement);\n        break;\n      case \"WhileStatement\":\n        this.walkWhileStatement(statement);\n        break;\n      case \"WithStatement\":\n        this.walkWithStatement(statement);\n        break;\n    }\n  }\n\n  // Real Statements\n  prewalkBlockStatement(statement) {\n    this.prewalkStatements(statement.body);\n  }\n  walkBlockStatement(statement) {\n    this.inBlockScope(() => {\n      const body = statement.body;\n      this.blockPrewalkStatements(body);\n      this.walkStatements(body);\n    });\n  }\n  walkExpressionStatement(statement) {\n    this.walkExpression(statement.expression);\n  }\n  prewalkIfStatement(statement) {\n    this.prewalkStatement(statement.consequent);\n    if (statement.alternate) {\n      this.prewalkStatement(statement.alternate);\n    }\n  }\n  walkIfStatement(statement) {\n    const result = this.hooks.statementIf.call(statement);\n    if (result === undefined) {\n      this.walkExpression(statement.test);\n      this.walkStatement(statement.consequent);\n      if (statement.alternate) {\n        this.walkStatement(statement.alternate);\n      }\n    } else {\n      if (result) {\n        this.walkStatement(statement.consequent);\n      } else if (statement.alternate) {\n        this.walkStatement(statement.alternate);\n      }\n    }\n  }\n  prewalkLabeledStatement(statement) {\n    this.prewalkStatement(statement.body);\n  }\n  walkLabeledStatement(statement) {\n    const hook = this.hooks.label.get(statement.label.name);\n    if (hook !== undefined) {\n      const result = hook.call(statement);\n      if (result === true) return;\n    }\n    this.walkStatement(statement.body);\n  }\n  prewalkWithStatement(statement) {\n    this.prewalkStatement(statement.body);\n  }\n  walkWithStatement(statement) {\n    this.walkExpression(statement.object);\n    this.walkStatement(statement.body);\n  }\n  prewalkSwitchStatement(statement) {\n    this.prewalkSwitchCases(statement.cases);\n  }\n  walkSwitchStatement(statement) {\n    this.walkExpression(statement.discriminant);\n    this.walkSwitchCases(statement.cases);\n  }\n  walkTerminatingStatement(statement) {\n    if (statement.argument) this.walkExpression(statement.argument);\n  }\n  walkReturnStatement(statement) {\n    this.walkTerminatingStatement(statement);\n  }\n  walkThrowStatement(statement) {\n    this.walkTerminatingStatement(statement);\n  }\n  prewalkTryStatement(statement) {\n    this.prewalkStatement(statement.block);\n  }\n  walkTryStatement(statement) {\n    if (this.scope.inTry) {\n      this.walkStatement(statement.block);\n    } else {\n      this.scope.inTry = true;\n      this.walkStatement(statement.block);\n      this.scope.inTry = false;\n    }\n    if (statement.handler) this.walkCatchClause(statement.handler);\n    if (statement.finalizer) this.walkStatement(statement.finalizer);\n  }\n  prewalkWhileStatement(statement) {\n    this.prewalkStatement(statement.body);\n  }\n  walkWhileStatement(statement) {\n    this.walkExpression(statement.test);\n    this.walkStatement(statement.body);\n  }\n  prewalkDoWhileStatement(statement) {\n    this.prewalkStatement(statement.body);\n  }\n  walkDoWhileStatement(statement) {\n    this.walkStatement(statement.body);\n    this.walkExpression(statement.test);\n  }\n  prewalkForStatement(statement) {\n    if (statement.init) {\n      if (statement.init.type === \"VariableDeclaration\") {\n        this.prewalkStatement(statement.init);\n      }\n    }\n    this.prewalkStatement(statement.body);\n  }\n  walkForStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.init) {\n        if (statement.init.type === \"VariableDeclaration\") {\n          this.blockPrewalkVariableDeclaration(statement.init);\n          this.walkStatement(statement.init);\n        } else {\n          this.walkExpression(statement.init);\n        }\n      }\n      if (statement.test) {\n        this.walkExpression(statement.test);\n      }\n      if (statement.update) {\n        this.walkExpression(statement.update);\n      }\n      const body = statement.body;\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        this.blockPrewalkStatements(body.body);\n        this.walkStatements(body.body);\n      } else {\n        this.walkStatement(body);\n      }\n    });\n  }\n  prewalkForInStatement(statement) {\n    if (statement.left.type === \"VariableDeclaration\") {\n      this.prewalkVariableDeclaration(statement.left);\n    }\n    this.prewalkStatement(statement.body);\n  }\n  walkForInStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.blockPrewalkVariableDeclaration(statement.left);\n        this.walkVariableDeclaration(statement.left);\n      } else {\n        this.walkPattern(statement.left);\n      }\n      this.walkExpression(statement.right);\n      const body = statement.body;\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        this.blockPrewalkStatements(body.body);\n        this.walkStatements(body.body);\n      } else {\n        this.walkStatement(body);\n      }\n    });\n  }\n  prewalkForOfStatement(statement) {\n    if (statement.left.type === \"VariableDeclaration\") {\n      this.prewalkVariableDeclaration(statement.left);\n    }\n    this.prewalkStatement(statement.body);\n  }\n  walkForOfStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.blockPrewalkVariableDeclaration(statement.left);\n        this.walkVariableDeclaration(statement.left);\n      } else {\n        this.walkPattern(statement.left);\n      }\n      this.walkExpression(statement.right);\n      const body = statement.body;\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        this.blockPrewalkStatements(body.body);\n        this.walkStatements(body.body);\n      } else {\n        this.walkStatement(body);\n      }\n    });\n  }\n\n  // Declarations\n  prewalkFunctionDeclaration(statement) {\n    if (statement.id) {\n      this.scope.renames.set(statement.id.name, null);\n      this.scope.definitions.add(statement.id.name);\n    }\n  }\n  walkFunctionDeclaration(statement) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    this.inFunctionScope(true, statement.params, () => {\n      for (const param of statement.params) {\n        this.walkPattern(param);\n      }\n      if (statement.body.type === \"BlockStatement\") {\n        this.detectMode(statement.body.body);\n        this.prewalkStatement(statement.body);\n        this.walkStatement(statement.body);\n      } else {\n        this.walkExpression(statement.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n  prewalkImportDeclaration(statement) {\n    const source = statement.source.value;\n    this.hooks.import.call(statement, source);\n    for (const specifier of statement.specifiers) {\n      const name = specifier.local.name;\n      this.scope.renames.set(name, null);\n      this.scope.definitions.add(name);\n      switch (specifier.type) {\n        case \"ImportDefaultSpecifier\":\n          this.hooks.importSpecifier.call(statement, source, \"default\", name);\n          break;\n        case \"ImportSpecifier\":\n          this.hooks.importSpecifier.call(statement, source, specifier.imported.name, name);\n          break;\n        case \"ImportNamespaceSpecifier\":\n          this.hooks.importSpecifier.call(statement, source, null, name);\n          break;\n      }\n    }\n  }\n  enterDeclaration(declaration, onIdent) {\n    switch (declaration.type) {\n      case \"VariableDeclaration\":\n        for (const declarator of declaration.declarations) {\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                this.enterPattern(declarator.id, onIdent);\n                break;\n              }\n          }\n        }\n        break;\n      case \"FunctionDeclaration\":\n        this.enterPattern(declaration.id, onIdent);\n        break;\n      case \"ClassDeclaration\":\n        this.enterPattern(declaration.id, onIdent);\n        break;\n    }\n  }\n  blockPrewalkExportNamedDeclaration(statement) {\n    if (statement.declaration) {\n      this.blockPrewalkStatement(statement.declaration);\n    }\n  }\n  prewalkExportNamedDeclaration(statement) {\n    let source;\n    if (statement.source) {\n      source = statement.source.value;\n      this.hooks.exportImport.call(statement, source);\n    } else {\n      this.hooks.export.call(statement);\n    }\n    if (statement.declaration) {\n      if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n        this.prewalkStatement(statement.declaration);\n        let index = 0;\n        this.enterDeclaration(statement.declaration, def => {\n          this.hooks.exportSpecifier.call(statement, def, def, index++);\n        });\n      }\n    }\n    if (statement.specifiers) {\n      for (let specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {\n        const specifier = statement.specifiers[specifierIndex];\n        switch (specifier.type) {\n          case \"ExportSpecifier\":\n            {\n              const name = specifier.exported.name;\n              if (source) {\n                this.hooks.exportImportSpecifier.call(statement, source, specifier.local.name, name, specifierIndex);\n              } else {\n                this.hooks.exportSpecifier.call(statement, specifier.local.name, name, specifierIndex);\n              }\n              break;\n            }\n        }\n      }\n    }\n  }\n  walkExportNamedDeclaration(statement) {\n    if (statement.declaration) {\n      this.walkStatement(statement.declaration);\n    }\n  }\n  blockPrewalkExportDefaultDeclaration(statement) {\n    if (statement.declaration.type === \"ClassDeclaration\") {\n      this.blockPrewalkClassDeclaration(statement.declaration);\n    }\n  }\n  prewalkExportDefaultDeclaration(statement) {\n    this.prewalkStatement(statement.declaration);\n    if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n      this.hooks.exportSpecifier.call(statement, statement.declaration.id.name, \"default\");\n    }\n  }\n  walkExportDefaultDeclaration(statement) {\n    this.hooks.export.call(statement);\n    if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n      if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n        this.walkStatement(statement.declaration);\n      }\n    } else {\n      // Acorn parses `export default function() {}` as `FunctionDeclaration` and\n      // `export default class {}` as `ClassDeclaration`, both with `id = null`.\n      // These nodes must be treated as expressions.\n      if (statement.declaration.type === \"FunctionDeclaration\") {\n        this.walkFunctionDeclaration(statement.declaration);\n      } else if (statement.declaration.type === \"ClassDeclaration\") {\n        this.walkClassDeclaration(statement.declaration);\n      } else {\n        this.walkExpression(statement.declaration);\n      }\n      if (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n        this.hooks.exportSpecifier.call(statement, statement.declaration, \"default\");\n      }\n    }\n  }\n  prewalkExportAllDeclaration(statement) {\n    const source = statement.source.value;\n    this.hooks.exportImport.call(statement, source);\n    this.hooks.exportImportSpecifier.call(statement, source, null, null, 0);\n  }\n  prewalkVariableDeclaration(statement) {\n    if (statement.kind !== \"var\") return;\n    this._prewalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n  }\n  blockPrewalkVariableDeclaration(statement) {\n    if (statement.kind === \"var\") return;\n    const hookMap = statement.kind === \"const\" ? this.hooks.varDeclarationConst : this.hooks.varDeclarationLet;\n    this._prewalkVariableDeclaration(statement, hookMap);\n  }\n  _prewalkVariableDeclaration(statement, hookMap) {\n    for (const declarator of statement.declarations) {\n      switch (declarator.type) {\n        case \"VariableDeclarator\":\n          {\n            this.enterPattern(declarator.id, (name, decl) => {\n              let hook = hookMap.get(name);\n              if (hook === undefined || !hook.call(decl)) {\n                hook = this.hooks.varDeclaration.get(name);\n                if (hook === undefined || !hook.call(decl)) {\n                  this.scope.renames.set(name, null);\n                  this.scope.definitions.add(name);\n                }\n              }\n            });\n            break;\n          }\n      }\n    }\n  }\n  walkVariableDeclaration(statement) {\n    for (const declarator of statement.declarations) {\n      switch (declarator.type) {\n        case \"VariableDeclarator\":\n          {\n            const renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);\n            if (renameIdentifier && declarator.id.type === \"Identifier\") {\n              const hook = this.hooks.canRename.get(renameIdentifier);\n              if (hook !== undefined && hook.call(declarator.init)) {\n                // renaming with \"var a = b;\"\n                const hook = this.hooks.rename.get(renameIdentifier);\n                if (hook === undefined || !hook.call(declarator.init)) {\n                  this.scope.renames.set(declarator.id.name, this.scope.renames.get(renameIdentifier) || renameIdentifier);\n                  this.scope.definitions.delete(declarator.id.name);\n                }\n                break;\n              }\n            }\n            this.walkPattern(declarator.id);\n            if (declarator.init) this.walkExpression(declarator.init);\n            break;\n          }\n      }\n    }\n  }\n  blockPrewalkClassDeclaration(statement) {\n    if (statement.id) {\n      this.scope.renames.set(statement.id.name, null);\n      this.scope.definitions.add(statement.id.name);\n    }\n  }\n  walkClassDeclaration(statement) {\n    this.walkClass(statement);\n  }\n  prewalkSwitchCases(switchCases) {\n    for (let index = 0, len = switchCases.length; index < len; index++) {\n      const switchCase = switchCases[index];\n      this.prewalkStatements(switchCase.consequent);\n    }\n  }\n  walkSwitchCases(switchCases) {\n    for (let index = 0, len = switchCases.length; index < len; index++) {\n      const switchCase = switchCases[index];\n      if (switchCase.test) {\n        this.walkExpression(switchCase.test);\n      }\n      this.walkStatements(switchCase.consequent);\n    }\n  }\n  walkCatchClause(catchClause) {\n    this.inBlockScope(() => {\n      // Error binding is optional in catch clause since ECMAScript 2019\n      if (catchClause.param !== null) {\n        this.enterPattern(catchClause.param, ident => {\n          this.scope.renames.set(ident, null);\n          this.scope.definitions.add(ident);\n        });\n        this.walkPattern(catchClause.param);\n      }\n      this.prewalkStatement(catchClause.body);\n      this.walkStatement(catchClause.body);\n    });\n  }\n  walkPattern(pattern) {\n    switch (pattern.type) {\n      case \"ArrayPattern\":\n        this.walkArrayPattern(pattern);\n        break;\n      case \"AssignmentPattern\":\n        this.walkAssignmentPattern(pattern);\n        break;\n      case \"MemberExpression\":\n        this.walkMemberExpression(pattern);\n        break;\n      case \"ObjectPattern\":\n        this.walkObjectPattern(pattern);\n        break;\n      case \"RestElement\":\n        this.walkRestElement(pattern);\n        break;\n    }\n  }\n  walkAssignmentPattern(pattern) {\n    this.walkExpression(pattern.right);\n    this.walkPattern(pattern.left);\n  }\n  walkObjectPattern(pattern) {\n    for (let i = 0, len = pattern.properties.length; i < len; i++) {\n      const prop = pattern.properties[i];\n      if (prop) {\n        if (prop.computed) this.walkExpression(prop.key);\n        if (prop.value) this.walkPattern(prop.value);\n      }\n    }\n  }\n  walkArrayPattern(pattern) {\n    for (let i = 0, len = pattern.elements.length; i < len; i++) {\n      const element = pattern.elements[i];\n      if (element) this.walkPattern(element);\n    }\n  }\n  walkRestElement(pattern) {\n    this.walkPattern(pattern.argument);\n  }\n  walkExpressions(expressions) {\n    for (const expression of expressions) {\n      if (expression) {\n        this.walkExpression(expression);\n      }\n    }\n  }\n  walkExpression(expression) {\n    switch (expression.type) {\n      case \"ArrayExpression\":\n        this.walkArrayExpression(expression);\n        break;\n      case \"ArrowFunctionExpression\":\n        this.walkArrowFunctionExpression(expression);\n        break;\n      case \"AssignmentExpression\":\n        this.walkAssignmentExpression(expression);\n        break;\n      case \"AwaitExpression\":\n        this.walkAwaitExpression(expression);\n        break;\n      case \"BinaryExpression\":\n        this.walkBinaryExpression(expression);\n        break;\n      case \"CallExpression\":\n        this.walkCallExpression(expression);\n        break;\n      case \"ClassExpression\":\n        this.walkClassExpression(expression);\n        break;\n      case \"ConditionalExpression\":\n        this.walkConditionalExpression(expression);\n        break;\n      case \"FunctionExpression\":\n        this.walkFunctionExpression(expression);\n        break;\n      case \"Identifier\":\n        this.walkIdentifier(expression);\n        break;\n      case \"LogicalExpression\":\n        this.walkLogicalExpression(expression);\n        break;\n      case \"MemberExpression\":\n        this.walkMemberExpression(expression);\n        break;\n      case \"NewExpression\":\n        this.walkNewExpression(expression);\n        break;\n      case \"ObjectExpression\":\n        this.walkObjectExpression(expression);\n        break;\n      case \"SequenceExpression\":\n        this.walkSequenceExpression(expression);\n        break;\n      case \"SpreadElement\":\n        this.walkSpreadElement(expression);\n        break;\n      case \"TaggedTemplateExpression\":\n        this.walkTaggedTemplateExpression(expression);\n        break;\n      case \"TemplateLiteral\":\n        this.walkTemplateLiteral(expression);\n        break;\n      case \"ThisExpression\":\n        this.walkThisExpression(expression);\n        break;\n      case \"UnaryExpression\":\n        this.walkUnaryExpression(expression);\n        break;\n      case \"UpdateExpression\":\n        this.walkUpdateExpression(expression);\n        break;\n      case \"YieldExpression\":\n        this.walkYieldExpression(expression);\n        break;\n    }\n  }\n  walkAwaitExpression(expression) {\n    this.walkExpression(expression.argument);\n  }\n  walkArrayExpression(expression) {\n    if (expression.elements) {\n      this.walkExpressions(expression.elements);\n    }\n  }\n  walkSpreadElement(expression) {\n    if (expression.argument) {\n      this.walkExpression(expression.argument);\n    }\n  }\n  walkObjectExpression(expression) {\n    for (let propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {\n      const prop = expression.properties[propIndex];\n      if (prop.type === \"SpreadElement\") {\n        this.walkExpression(prop.argument);\n        continue;\n      }\n      if (prop.computed) {\n        this.walkExpression(prop.key);\n      }\n      if (prop.shorthand) {\n        this.scope.inShorthand = true;\n      }\n      this.walkExpression(prop.value);\n      if (prop.shorthand) {\n        this.scope.inShorthand = false;\n      }\n    }\n  }\n  walkFunctionExpression(expression) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    const scopeParams = expression.params;\n\n    // Add function name in scope for recursive calls\n    if (expression.id) {\n      scopeParams.push(expression.id.name);\n    }\n    this.inFunctionScope(true, scopeParams, () => {\n      for (const param of expression.params) {\n        this.walkPattern(param);\n      }\n      if (expression.body.type === \"BlockStatement\") {\n        this.detectMode(expression.body.body);\n        this.prewalkStatement(expression.body);\n        this.walkStatement(expression.body);\n      } else {\n        this.walkExpression(expression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n  walkArrowFunctionExpression(expression) {\n    this.inFunctionScope(false, expression.params, () => {\n      for (const param of expression.params) {\n        this.walkPattern(param);\n      }\n      if (expression.body.type === \"BlockStatement\") {\n        this.detectMode(expression.body.body);\n        this.prewalkStatement(expression.body);\n        this.walkStatement(expression.body);\n      } else {\n        this.walkExpression(expression.body);\n      }\n    });\n  }\n  walkSequenceExpression(expression) {\n    if (expression.expressions) this.walkExpressions(expression.expressions);\n  }\n  walkUpdateExpression(expression) {\n    this.walkExpression(expression.argument);\n  }\n  walkUnaryExpression(expression) {\n    if (expression.operator === \"typeof\") {\n      const exprName = this.getNameForExpression(expression.argument);\n      if (exprName && exprName.free) {\n        const hook = this.hooks.typeof.get(exprName.name);\n        if (hook !== undefined) {\n          const result = hook.call(expression);\n          if (result === true) return;\n        }\n      }\n    }\n    this.walkExpression(expression.argument);\n  }\n  walkLeftRightExpression(expression) {\n    this.walkExpression(expression.left);\n    this.walkExpression(expression.right);\n  }\n  walkBinaryExpression(expression) {\n    this.walkLeftRightExpression(expression);\n  }\n  walkLogicalExpression(expression) {\n    const result = this.hooks.expressionLogicalOperator.call(expression);\n    if (result === undefined) {\n      this.walkLeftRightExpression(expression);\n    } else {\n      if (result) {\n        this.walkExpression(expression.right);\n      }\n    }\n  }\n  walkAssignmentExpression(expression) {\n    const renameIdentifier = this.getRenameIdentifier(expression.right);\n    if (expression.left.type === \"Identifier\" && renameIdentifier) {\n      const hook = this.hooks.canRename.get(renameIdentifier);\n      if (hook !== undefined && hook.call(expression.right)) {\n        // renaming \"a = b;\"\n        const hook = this.hooks.rename.get(renameIdentifier);\n        if (hook === undefined || !hook.call(expression.right)) {\n          this.scope.renames.set(expression.left.name, renameIdentifier);\n          this.scope.definitions.delete(expression.left.name);\n        }\n        return;\n      }\n    }\n    if (expression.left.type === \"Identifier\") {\n      const assignedHook = this.hooks.assigned.get(expression.left.name);\n      if (assignedHook === undefined || !assignedHook.call(expression)) {\n        this.walkExpression(expression.right);\n      }\n      this.scope.renames.set(expression.left.name, null);\n      const assignHook = this.hooks.assign.get(expression.left.name);\n      if (assignHook === undefined || !assignHook.call(expression)) {\n        this.walkExpression(expression.left);\n      }\n      return;\n    }\n    this.walkExpression(expression.right);\n    this.walkPattern(expression.left);\n    this.enterPattern(expression.left, (name, decl) => {\n      this.scope.renames.set(name, null);\n    });\n  }\n  walkConditionalExpression(expression) {\n    const result = this.hooks.expressionConditionalOperator.call(expression);\n    if (result === undefined) {\n      this.walkExpression(expression.test);\n      this.walkExpression(expression.consequent);\n      if (expression.alternate) {\n        this.walkExpression(expression.alternate);\n      }\n    } else {\n      if (result) {\n        this.walkExpression(expression.consequent);\n      } else if (expression.alternate) {\n        this.walkExpression(expression.alternate);\n      }\n    }\n  }\n  walkNewExpression(expression) {\n    const callee = this.evaluateExpression(expression.callee);\n    if (callee.isIdentifier()) {\n      const hook = this.hooks.new.get(callee.identifier);\n      if (hook !== undefined) {\n        const result = hook.call(expression);\n        if (result === true) {\n          return;\n        }\n      }\n    }\n    this.walkExpression(expression.callee);\n    if (expression.arguments) {\n      this.walkExpressions(expression.arguments);\n    }\n  }\n  walkYieldExpression(expression) {\n    if (expression.argument) {\n      this.walkExpression(expression.argument);\n    }\n  }\n  walkTemplateLiteral(expression) {\n    if (expression.expressions) {\n      this.walkExpressions(expression.expressions);\n    }\n  }\n  walkTaggedTemplateExpression(expression) {\n    if (expression.tag) {\n      this.walkExpression(expression.tag);\n    }\n    if (expression.quasi && expression.quasi.expressions) {\n      this.walkExpressions(expression.quasi.expressions);\n    }\n  }\n  walkClassExpression(expression) {\n    this.walkClass(expression);\n  }\n  _walkIIFE(functionExpression, options, currentThis) {\n    const renameArgOrThis = argOrThis => {\n      const renameIdentifier = this.getRenameIdentifier(argOrThis);\n      if (renameIdentifier) {\n        const hook = this.hooks.canRename.get(renameIdentifier);\n        if (hook !== undefined && hook.call(argOrThis)) {\n          const hook = this.hooks.rename.get(renameIdentifier);\n          if (hook === undefined || !hook.call(argOrThis)) {\n            return renameIdentifier;\n          }\n        }\n      }\n      this.walkExpression(argOrThis);\n    };\n    const params = functionExpression.params;\n    const renameThis = currentThis ? renameArgOrThis(currentThis) : null;\n    const args = options.map(renameArgOrThis);\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    const scopeParams = params.filter((identifier, idx) => !args[idx]);\n\n    // Add function name in scope for recursive calls\n    if (functionExpression.id) {\n      scopeParams.push(functionExpression.id.name);\n    }\n    this.inFunctionScope(true, scopeParams, () => {\n      if (renameThis) {\n        this.scope.renames.set(\"this\", renameThis);\n      }\n      for (let i = 0; i < args.length; i++) {\n        const param = args[i];\n        if (!param) continue;\n        if (!params[i] || params[i].type !== \"Identifier\") continue;\n        this.scope.renames.set(params[i].name, param);\n      }\n      if (functionExpression.body.type === \"BlockStatement\") {\n        this.detectMode(functionExpression.body.body);\n        this.prewalkStatement(functionExpression.body);\n        this.walkStatement(functionExpression.body);\n      } else {\n        this.walkExpression(functionExpression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n  walkCallExpression(expression) {\n    if (expression.callee.type === \"MemberExpression\" && expression.callee.object.type === \"FunctionExpression\" && !expression.callee.computed && (expression.callee.property.name === \"call\" || expression.callee.property.name === \"bind\") && expression.arguments.length > 0) {\n      // (function() { }.call/bind(?, ))\n      this._walkIIFE(expression.callee.object, expression.arguments.slice(1), expression.arguments[0]);\n    } else if (expression.callee.type === \"FunctionExpression\") {\n      // (function() { }())\n      this._walkIIFE(expression.callee, expression.arguments, null);\n    } else if (expression.callee.type === \"Import\") {\n      let result = this.hooks.importCall.call(expression);\n      if (result === true) return;\n      if (expression.arguments) this.walkExpressions(expression.arguments);\n    } else {\n      const callee = this.evaluateExpression(expression.callee);\n      if (callee.isIdentifier()) {\n        const callHook = this.hooks.call.get(callee.identifier);\n        if (callHook !== undefined) {\n          let result = callHook.call(expression);\n          if (result === true) return;\n        }\n        let identifier = callee.identifier.replace(/\\.[^.]+$/, \"\");\n        if (identifier !== callee.identifier) {\n          const callAnyHook = this.hooks.callAnyMember.get(identifier);\n          if (callAnyHook !== undefined) {\n            let result = callAnyHook.call(expression);\n            if (result === true) return;\n          }\n        }\n      }\n      if (expression.callee) this.walkExpression(expression.callee);\n      if (expression.arguments) this.walkExpressions(expression.arguments);\n    }\n  }\n  walkMemberExpression(expression) {\n    const exprName = this.getNameForExpression(expression);\n    if (exprName && exprName.free) {\n      const expressionHook = this.hooks.expression.get(exprName.name);\n      if (expressionHook !== undefined) {\n        const result = expressionHook.call(expression);\n        if (result === true) return;\n      }\n      const expressionAnyMemberHook = this.hooks.expressionAnyMember.get(exprName.nameGeneral);\n      if (expressionAnyMemberHook !== undefined) {\n        const result = expressionAnyMemberHook.call(expression);\n        if (result === true) return;\n      }\n    }\n    this.walkExpression(expression.object);\n    if (expression.computed === true) this.walkExpression(expression.property);\n  }\n  walkThisExpression(expression) {\n    const expressionHook = this.hooks.expression.get(\"this\");\n    if (expressionHook !== undefined) {\n      expressionHook.call(expression);\n    }\n  }\n  walkIdentifier(expression) {\n    if (!this.scope.definitions.has(expression.name)) {\n      const hook = this.hooks.expression.get(this.scope.renames.get(expression.name) || expression.name);\n      if (hook !== undefined) {\n        const result = hook.call(expression);\n        if (result === true) return;\n      }\n    }\n  }\n\n  /**\n   * @deprecated\n   * @param {any} params scope params\n   * @param {function(): void} fn inner function\n   * @returns {void}\n   */\n  inScope(params, fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: false,\n      inShorthand: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild(),\n      renames: oldScope.renames.createChild()\n    };\n    this.scope.renames.set(\"this\", null);\n    this.enterPatterns(params, ident => {\n      this.scope.renames.set(ident, null);\n      this.scope.definitions.add(ident);\n    });\n    fn();\n    this.scope = oldScope;\n  }\n  inFunctionScope(hasThis, params, fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: false,\n      inShorthand: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild(),\n      renames: oldScope.renames.createChild()\n    };\n    if (hasThis) {\n      this.scope.renames.set(\"this\", null);\n    }\n    this.enterPatterns(params, ident => {\n      this.scope.renames.set(ident, null);\n      this.scope.definitions.add(ident);\n    });\n    fn();\n    this.scope = oldScope;\n  }\n  inBlockScope(fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: oldScope.inTry,\n      inShorthand: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild(),\n      renames: oldScope.renames.createChild()\n    };\n    fn();\n    this.scope = oldScope;\n  }\n\n  // TODO webpack 5: remove this methods\n  // only for backward-compat\n  detectStrictMode(statements) {\n    this.detectMode(statements);\n  }\n  detectMode(statements) {\n    const isLiteral = statements.length >= 1 && statements[0].type === \"ExpressionStatement\" && statements[0].expression.type === \"Literal\";\n    if (isLiteral && statements[0].expression.value === \"use strict\") {\n      this.scope.isStrict = true;\n    }\n    if (isLiteral && statements[0].expression.value === \"use asm\") {\n      this.scope.isAsmJs = true;\n    }\n  }\n  enterPatterns(patterns, onIdent) {\n    for (const pattern of patterns) {\n      if (typeof pattern !== \"string\") {\n        this.enterPattern(pattern, onIdent);\n      } else if (pattern) {\n        onIdent(pattern);\n      }\n    }\n  }\n  enterPattern(pattern, onIdent) {\n    if (!pattern) return;\n    switch (pattern.type) {\n      case \"ArrayPattern\":\n        this.enterArrayPattern(pattern, onIdent);\n        break;\n      case \"AssignmentPattern\":\n        this.enterAssignmentPattern(pattern, onIdent);\n        break;\n      case \"Identifier\":\n        this.enterIdentifier(pattern, onIdent);\n        break;\n      case \"ObjectPattern\":\n        this.enterObjectPattern(pattern, onIdent);\n        break;\n      case \"RestElement\":\n        this.enterRestElement(pattern, onIdent);\n        break;\n      case \"Property\":\n        this.enterPattern(pattern.value, onIdent);\n        break;\n    }\n  }\n  enterIdentifier(pattern, onIdent) {\n    onIdent(pattern.name, pattern);\n  }\n  enterObjectPattern(pattern, onIdent) {\n    for (let propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {\n      const prop = pattern.properties[propIndex];\n      this.enterPattern(prop, onIdent);\n    }\n  }\n  enterArrayPattern(pattern, onIdent) {\n    for (let elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {\n      const element = pattern.elements[elementIndex];\n      this.enterPattern(element, onIdent);\n    }\n  }\n  enterRestElement(pattern, onIdent) {\n    this.enterPattern(pattern.argument, onIdent);\n  }\n  enterAssignmentPattern(pattern, onIdent) {\n    this.enterPattern(pattern.left, onIdent);\n  }\n  evaluateExpression(expression) {\n    try {\n      const hook = this.hooks.evaluate.get(expression.type);\n      if (hook !== undefined) {\n        const result = hook.call(expression);\n        if (result !== undefined) {\n          if (result) {\n            result.setExpression(expression);\n          }\n          return result;\n        }\n      }\n    } catch (e) {\n      console.warn(e);\n      // ignore error\n    }\n    return new BasicEvaluatedExpression().setRange(expression.range).setExpression(expression);\n  }\n  parseString(expression) {\n    switch (expression.type) {\n      case \"BinaryExpression\":\n        if (expression.operator === \"+\") {\n          return this.parseString(expression.left) + this.parseString(expression.right);\n        }\n        break;\n      case \"Literal\":\n        return expression.value + \"\";\n    }\n    throw new Error(expression.type + \" is not supported as parameter for require\");\n  }\n  parseCalculatedString(expression) {\n    switch (expression.type) {\n      case \"BinaryExpression\":\n        if (expression.operator === \"+\") {\n          const left = this.parseCalculatedString(expression.left);\n          const right = this.parseCalculatedString(expression.right);\n          if (left.code) {\n            return {\n              range: left.range,\n              value: left.value,\n              code: true,\n              conditional: false\n            };\n          } else if (right.code) {\n            return {\n              range: [left.range[0], right.range ? right.range[1] : left.range[1]],\n              value: left.value + right.value,\n              code: true,\n              conditional: false\n            };\n          } else {\n            return {\n              range: [left.range[0], right.range[1]],\n              value: left.value + right.value,\n              code: false,\n              conditional: false\n            };\n          }\n        }\n        break;\n      case \"ConditionalExpression\":\n        {\n          const consequent = this.parseCalculatedString(expression.consequent);\n          const alternate = this.parseCalculatedString(expression.alternate);\n          const items = [];\n          if (consequent.conditional) {\n            items.push(...consequent.conditional);\n          } else if (!consequent.code) {\n            items.push(consequent);\n          } else {\n            break;\n          }\n          if (alternate.conditional) {\n            items.push(...alternate.conditional);\n          } else if (!alternate.code) {\n            items.push(alternate);\n          } else {\n            break;\n          }\n          return {\n            range: undefined,\n            value: \"\",\n            code: true,\n            conditional: items\n          };\n        }\n      case \"Literal\":\n        return {\n          range: expression.range,\n          value: expression.value + \"\",\n          code: false,\n          conditional: false\n        };\n    }\n    return {\n      range: undefined,\n      value: \"\",\n      code: true,\n      conditional: false\n    };\n  }\n  parse(source, initialState) {\n    let ast;\n    let comments;\n    if (typeof source === \"object\" && source !== null) {\n      ast = source;\n      comments = source.comments;\n    } else {\n      comments = [];\n      ast = Parser.parse(source, {\n        sourceType: this.sourceType,\n        onComment: comments\n      });\n    }\n    const oldScope = this.scope;\n    const oldState = this.state;\n    const oldComments = this.comments;\n    this.scope = {\n      topLevelScope: true,\n      inTry: false,\n      inShorthand: false,\n      isStrict: false,\n      isAsmJs: false,\n      definitions: new StackedSetMap(),\n      renames: new StackedSetMap()\n    };\n    const state = this.state = initialState || {};\n    this.comments = comments;\n    if (this.hooks.program.call(ast, comments) === undefined) {\n      this.detectMode(ast.body);\n      this.prewalkStatements(ast.body);\n      this.blockPrewalkStatements(ast.body);\n      this.walkStatements(ast.body);\n    }\n    this.scope = oldScope;\n    this.state = oldState;\n    this.comments = oldComments;\n    return state;\n  }\n  evaluate(source) {\n    const ast = Parser.parse(\"(\" + source + \")\", {\n      sourceType: this.sourceType,\n      locations: false\n    });\n    // TODO(https://github.com/acornjs/acorn/issues/741)\n    // @ts-ignore\n    if (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n      throw new Error(\"evaluate: Source is not a expression\");\n    }\n    // TODO(https://github.com/acornjs/acorn/issues/741)\n    // @ts-ignore\n    return this.evaluateExpression(ast.body[0].expression);\n  }\n  getComments(range) {\n    return this.comments.filter(comment => comment.range[0] >= range[0] && comment.range[1] <= range[1]);\n  }\n  parseCommentOptions(range) {\n    const comments = this.getComments(range);\n    if (comments.length === 0) {\n      return EMPTY_COMMENT_OPTIONS;\n    }\n    let options = {};\n    let errors = [];\n    for (const comment of comments) {\n      const {\n        value\n      } = comment;\n      if (value && webpackCommentRegExp.test(value)) {\n        // try compile only if webpack options comment is present\n        try {\n          const val = vm.runInNewContext(`(function(){return {${value}};})()`);\n          Object.assign(options, val);\n        } catch (e) {\n          e.comment = comment;\n          errors.push(e);\n        }\n      }\n    }\n    return {\n      options,\n      errors\n    };\n  }\n  getNameForExpression(expression) {\n    let expr = expression;\n    const exprName = [];\n    while (expr.type === \"MemberExpression\" && expr.property.type === (expr.computed ? \"Literal\" : \"Identifier\")) {\n      exprName.push(expr.computed ? expr.property.value : expr.property.name);\n      expr = expr.object;\n    }\n    let free;\n    if (expr.type === \"Identifier\") {\n      free = !this.scope.definitions.has(expr.name);\n      exprName.push(this.scope.renames.get(expr.name) || expr.name);\n    } else if (expr.type === \"ThisExpression\" && this.scope.renames.get(\"this\")) {\n      free = true;\n      exprName.push(this.scope.renames.get(\"this\"));\n    } else if (expr.type === \"ThisExpression\") {\n      free = this.scope.topLevelScope;\n      exprName.push(\"this\");\n    } else {\n      return null;\n    }\n    let prefix = \"\";\n    for (let i = exprName.length - 1; i >= 2; i--) {\n      prefix += exprName[i] + \".\";\n    }\n    if (exprName.length > 1) {\n      prefix += exprName[1];\n    }\n    const name = prefix ? prefix + \".\" + exprName[0] : exprName[0];\n    const nameGeneral = prefix;\n    return {\n      name,\n      nameGeneral,\n      free\n    };\n  }\n  static parse(code, options) {\n    const type = options ? options.sourceType : \"module\";\n    const parserOptions = Object.assign(Object.create(null), defaultParserOptions, options);\n    if (type === \"auto\") {\n      parserOptions.sourceType = \"module\";\n    } else if (parserOptions.sourceType === \"script\") {\n      parserOptions.allowReturnOutsideFunction = true;\n    }\n    let ast;\n    let error;\n    let threw = false;\n    try {\n      ast = acornParser.parse(code, parserOptions);\n    } catch (e) {\n      error = e;\n      threw = true;\n    }\n    if (threw && type === \"auto\") {\n      parserOptions.sourceType = \"script\";\n      parserOptions.allowReturnOutsideFunction = true;\n      if (Array.isArray(parserOptions.onComment)) {\n        parserOptions.onComment.length = 0;\n      }\n      try {\n        ast = acornParser.parse(code, parserOptions);\n        threw = false;\n      } catch (e) {\n        threw = true;\n      }\n    }\n    if (threw) {\n      throw error;\n    }\n    return ast;\n  }\n}\n\n// TODO remove in webpack 5\nObject.defineProperty(Parser.prototype, \"getCommentOptions\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {TODO} range Range\n   * @returns {void}\n   * @this {Parser}\n   */\n  function (range) {\n    return this.parseCommentOptions(range).options;\n  }, \"Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead\")\n});\nmodule.exports = Parser;","map":{"version":3,"names":["acorn","require","Tapable","SyncBailHook","HookMap","util","vm","BasicEvaluatedExpression","StackedSetMap","acornParser","Parser","joinRanges","startRange","endRange","defaultParserOptions","ranges","locations","ecmaVersion","sourceType","onComment","webpackCommentRegExp","RegExp","EMPTY_COMMENT_OPTIONS","options","errors","constructor","hooks","evaluateTypeof","evaluate","evaluateIdentifier","evaluateDefinedIdentifier","evaluateCallExpressionMember","statement","statementIf","label","import","importSpecifier","export","exportImport","exportDeclaration","exportExpression","exportSpecifier","exportImportSpecifier","varDeclaration","varDeclarationLet","varDeclarationConst","varDeclarationVar","canRename","rename","assigned","assign","typeof","importCall","call","callAnyMember","new","expression","expressionAnyMember","expressionConditionalOperator","expressionLogicalOperator","program","HOOK_MAP_COMPAT_CONFIG","_pluginCompat","tap","name","Object","keys","regexp","match","exec","fn","bind","scope","undefined","state","comments","initializeEvaluating","for","expr","value","setNumber","setRange","range","setString","setBoolean","setNull","setRegExp","left","leftAsBool","right","operator","evaluateExpression","asBool","res","isString","string","isNumber","number","isWrapped","prefix","setWrapped","postfix","wrappedInnerExpressions","concat","Math","pow","isBoolean","bool","argument","type","renames","get","definitions","has","hook","exprName","getNameForExpression","free","arg","isArray","isConstArray","isRegExp","isTruthy","isFalsy","result","setIdentifier","callee","property","computed","param","object","arguments","length","arg1","arg2","regExp","replace","forEach","str","getSimplifiedTemplateResult","kind","templateLiteralExpr","quasis","parts","i","quasiExpr","quasi","prevExpr","expressions","exprAsString","asString","setExpression","push","part","node","setTemplateString","tag","identifier","stringSuffix","hasUnknownParams","argExpr","newString","newRange","split","setArray","condition","test","conditionValue","consequent","alternate","isConditional","setOptions","addOptions","items","elements","map","element","every","Boolean","setItems","getRenameIdentifier","isIdentifier","walkClass","classy","superClass","walkExpression","body","wasTopLevel","topLevelScope","methodDefinition","walkMethodDefinition","key","prewalkStatements","statements","index","len","prewalkStatement","blockPrewalkStatements","blockPrewalkStatement","walkStatements","walkStatement","prewalkBlockStatement","prewalkDoWhileStatement","prewalkExportAllDeclaration","prewalkExportDefaultDeclaration","prewalkExportNamedDeclaration","prewalkForInStatement","prewalkForOfStatement","prewalkForStatement","prewalkFunctionDeclaration","prewalkIfStatement","prewalkImportDeclaration","prewalkLabeledStatement","prewalkSwitchStatement","prewalkTryStatement","prewalkVariableDeclaration","prewalkWhileStatement","prewalkWithStatement","blockPrewalkVariableDeclaration","blockPrewalkExportDefaultDeclaration","blockPrewalkExportNamedDeclaration","blockPrewalkClassDeclaration","walkBlockStatement","walkClassDeclaration","walkDoWhileStatement","walkExportDefaultDeclaration","walkExportNamedDeclaration","walkExpressionStatement","walkForInStatement","walkForOfStatement","walkForStatement","walkFunctionDeclaration","walkIfStatement","walkLabeledStatement","walkReturnStatement","walkSwitchStatement","walkThrowStatement","walkTryStatement","walkVariableDeclaration","walkWhileStatement","walkWithStatement","inBlockScope","prewalkSwitchCases","cases","discriminant","walkSwitchCases","walkTerminatingStatement","block","inTry","handler","walkCatchClause","finalizer","init","update","walkPattern","id","set","add","inFunctionScope","params","detectMode","source","specifier","specifiers","local","imported","enterDeclaration","declaration","onIdent","declarator","declarations","enterPattern","def","specifierIndex","exported","_prewalkVariableDeclaration","hookMap","decl","renameIdentifier","delete","switchCases","switchCase","catchClause","ident","pattern","walkArrayPattern","walkAssignmentPattern","walkMemberExpression","walkObjectPattern","walkRestElement","properties","prop","walkExpressions","walkArrayExpression","walkArrowFunctionExpression","walkAssignmentExpression","walkAwaitExpression","walkBinaryExpression","walkCallExpression","walkClassExpression","walkConditionalExpression","walkFunctionExpression","walkIdentifier","walkLogicalExpression","walkNewExpression","walkObjectExpression","walkSequenceExpression","walkSpreadElement","walkTaggedTemplateExpression","walkTemplateLiteral","walkThisExpression","walkUnaryExpression","walkUpdateExpression","walkYieldExpression","propIndex","shorthand","inShorthand","scopeParams","walkLeftRightExpression","assignedHook","assignHook","_walkIIFE","functionExpression","currentThis","renameArgOrThis","argOrThis","renameThis","args","filter","idx","slice","callHook","callAnyHook","expressionHook","expressionAnyMemberHook","nameGeneral","inScope","oldScope","isStrict","isAsmJs","createChild","enterPatterns","hasThis","detectStrictMode","isLiteral","patterns","enterArrayPattern","enterAssignmentPattern","enterIdentifier","enterObjectPattern","enterRestElement","elementIndex","e","console","warn","parseString","Error","parseCalculatedString","code","conditional","parse","initialState","ast","oldState","oldComments","getComments","comment","parseCommentOptions","val","runInNewContext","parserOptions","create","allowReturnOutsideFunction","error","threw","Array","defineProperty","prototype","configurable","deprecate","module","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/Parser.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\n// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nconst acorn = require(\"acorn\");\nconst { Tapable, SyncBailHook, HookMap } = require(\"tapable\");\nconst util = require(\"util\");\nconst vm = require(\"vm\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\nconst StackedSetMap = require(\"./util/StackedSetMap\");\n\nconst acornParser = acorn.Parser;\n\nconst joinRanges = (startRange, endRange) => {\n\tif (!endRange) return startRange;\n\tif (!startRange) return endRange;\n\treturn [startRange[0], endRange[1]];\n};\n\nconst defaultParserOptions = {\n\tranges: true,\n\tlocations: true,\n\tecmaVersion: 11,\n\tsourceType: \"module\",\n\tonComment: null\n};\n\n// regexp to match at least one \"magic comment\"\nconst webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\n\nconst EMPTY_COMMENT_OPTIONS = {\n\toptions: null,\n\terrors: null\n};\n\nclass Parser extends Tapable {\n\tconstructor(options, sourceType = \"auto\") {\n\t\tsuper();\n\t\tthis.hooks = {\n\t\t\tevaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tevaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tevaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tevaluateDefinedIdentifier: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\tevaluateCallExpressionMember: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"param\"])\n\t\t\t),\n\t\t\tstatement: new SyncBailHook([\"statement\"]),\n\t\t\tstatementIf: new SyncBailHook([\"statement\"]),\n\t\t\tlabel: new HookMap(() => new SyncBailHook([\"statement\"])),\n\t\t\timport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\timportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"identifierName\"\n\t\t\t]),\n\t\t\texport: new SyncBailHook([\"statement\"]),\n\t\t\texportImport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\texportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\texportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\texportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\texportImportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\tvarDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tvarDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tvarDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tvarDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tcanRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\trename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\tassigned: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tassign: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\ttypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\timportCall: new SyncBailHook([\"expression\"]),\n\t\t\tcall: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tcallAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tnew: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\texpression: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\texpressionAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\texpressionConditionalOperator: new SyncBailHook([\"expression\"]),\n\t\t\texpressionLogicalOperator: new SyncBailHook([\"expression\"]),\n\t\t\tprogram: new SyncBailHook([\"ast\", \"comments\"])\n\t\t};\n\t\tconst HOOK_MAP_COMPAT_CONFIG = {\n\t\t\tevaluateTypeof: /^evaluate typeof (.+)$/,\n\t\t\tevaluateIdentifier: /^evaluate Identifier (.+)$/,\n\t\t\tevaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,\n\t\t\tevaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,\n\t\t\tevaluate: /^evaluate (.+)$/,\n\t\t\tlabel: /^label (.+)$/,\n\t\t\tvarDeclarationLet: /^var-let (.+)$/,\n\t\t\tvarDeclarationConst: /^var-const (.+)$/,\n\t\t\tvarDeclarationVar: /^var-var (.+)$/,\n\t\t\tvarDeclaration: /^var (.+)$/,\n\t\t\tcanRename: /^can-rename (.+)$/,\n\t\t\trename: /^rename (.+)$/,\n\t\t\ttypeof: /^typeof (.+)$/,\n\t\t\tassigned: /^assigned (.+)$/,\n\t\t\tassign: /^assign (.+)$/,\n\t\t\tcallAnyMember: /^call (.+)\\.\\*$/,\n\t\t\tcall: /^call (.+)$/,\n\t\t\tnew: /^new (.+)$/,\n\t\t\texpressionConditionalOperator: /^expression \\?:$/,\n\t\t\texpressionAnyMember: /^expression (.+)\\.\\*$/,\n\t\t\texpression: /^expression (.+)$/\n\t\t};\n\t\tthis._pluginCompat.tap(\"Parser\", options => {\n\t\t\tfor (const name of Object.keys(HOOK_MAP_COMPAT_CONFIG)) {\n\t\t\t\tconst regexp = HOOK_MAP_COMPAT_CONFIG[name];\n\t\t\t\tconst match = regexp.exec(options.name);\n\t\t\t\tif (match) {\n\t\t\t\t\tif (match[1]) {\n\t\t\t\t\t\tthis.hooks[name].tap(\n\t\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\t\toptions.fn.name || \"unnamed compat plugin\",\n\t\t\t\t\t\t\toptions.fn.bind(this)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.hooks[name].tap(\n\t\t\t\t\t\t\toptions.fn.name || \"unnamed compat plugin\",\n\t\t\t\t\t\t\toptions.fn.bind(this)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.options = options;\n\t\tthis.sourceType = sourceType;\n\t\tthis.scope = undefined;\n\t\tthis.state = undefined;\n\t\tthis.comments = undefined;\n\t\tthis.initializeEvaluating();\n\t}\n\n\tinitializeEvaluating() {\n\t\tthis.hooks.evaluate.for(\"Literal\").tap(\"Parser\", expr => {\n\t\t\tswitch (typeof expr.value) {\n\t\t\t\tcase \"number\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setNumber(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t\tif (expr.value === null) {\n\t\t\t\treturn new BasicEvaluatedExpression().setNull().setRange(expr.range);\n\t\t\t}\n\t\t\tif (expr.value instanceof RegExp) {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setRegExp(expr.value)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"LogicalExpression\").tap(\"Parser\", expr => {\n\t\t\tlet left;\n\t\t\tlet leftAsBool;\n\t\t\tlet right;\n\t\t\tif (expr.operator === \"&&\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tleftAsBool = left && left.asBool();\n\t\t\t\tif (leftAsBool === false) return left.setRange(expr.range);\n\t\t\t\tif (leftAsBool !== true) return;\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\treturn right.setRange(expr.range);\n\t\t\t} else if (expr.operator === \"||\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tleftAsBool = left && left.asBool();\n\t\t\t\tif (leftAsBool === true) return left.setRange(expr.range);\n\t\t\t\tif (leftAsBool !== false) return;\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\treturn right.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"BinaryExpression\").tap(\"Parser\", expr => {\n\t\t\tlet left;\n\t\t\tlet right;\n\t\t\tlet res;\n\t\t\tif (expr.operator === \"+\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tif (left.isString()) {\n\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\tres.setString(left.string + right.string);\n\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\tres.setString(left.string + right.number);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tright.isWrapped() &&\n\t\t\t\t\t\tright.prefix &&\n\t\t\t\t\t\tright.prefix.isString()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// \"left\" + (\"prefix\" + inner + \"postfix\")\n\t\t\t\t\t\t// => (\"leftprefix\" + inner + \"postfix\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(left.string + right.prefix.string)\n\t\t\t\t\t\t\t\t.setRange(joinRanges(left.range, right.prefix.range)),\n\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t// \"left\" + ([null] + inner + \"postfix\")\n\t\t\t\t\t\t// => (\"left\" + inner + \"postfix\")\n\t\t\t\t\t\tres.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// \"left\" + expr\n\t\t\t\t\t\t// => (\"left\" + expr + \"\")\n\t\t\t\t\t\tres.setWrapped(left, null, [right]);\n\t\t\t\t\t}\n\t\t\t\t} else if (left.isNumber()) {\n\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\tres.setString(left.number + right.string);\n\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\tres.setNumber(left.number + right.number);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (left.isWrapped()) {\n\t\t\t\t\tif (left.postfix && left.postfix.isString() && right.isString()) {\n\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + \"right\"\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfixright\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.string)\n\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tleft.postfix &&\n\t\t\t\t\t\tleft.postfix.isString() &&\n\t\t\t\t\t\tright.isNumber()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + 123\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfix123\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.number)\n\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (right.isString()) {\n\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + \"right\"\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"right\")\n\t\t\t\t\t\tres.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + 123\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"123\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(right.number + \"\")\n\t\t\t\t\t\t\t\t.setRange(right.range),\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t\t.concat(left.postfix ? [left.postfix] : [])\n\t\t\t\t\t\t\t\t\t.concat(right.prefix ? [right.prefix] : [])\n\t\t\t\t\t\t\t\t\t.concat(right.wrappedInnerExpressions)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// (\"prefix\" + inner + postfix) + expr\n\t\t\t\t\t\t// => (\"prefix\" + inner + postfix + expr + [null])\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions.concat(\n\t\t\t\t\t\t\t\t\tleft.postfix ? [left.postfix, right] : [right]\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t// left + \"right\"\n\t\t\t\t\t\t// => ([null] + left + \"right\")\n\t\t\t\t\t\tres.setWrapped(null, right, [left]);\n\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t// left + (prefix + inner + \"postfix\")\n\t\t\t\t\t\t// => ([null] + left + prefix + inner + \"postfix\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t(right.prefix ? [left, right.prefix] : [left]).concat(\n\t\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"-\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number - right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"*\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number * right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"/\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number / right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"**\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(Math.pow(left.number, right.number));\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"==\" || expr.operator === \"===\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\tif (left.isString() && right.isString()) {\n\t\t\t\t\treturn res.setBoolean(left.string === right.string);\n\t\t\t\t} else if (left.isNumber() && right.isNumber()) {\n\t\t\t\t\treturn res.setBoolean(left.number === right.number);\n\t\t\t\t} else if (left.isBoolean() && right.isBoolean()) {\n\t\t\t\t\treturn res.setBoolean(left.bool === right.bool);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"!=\" || expr.operator === \"!==\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\tif (left.isString() && right.isString()) {\n\t\t\t\t\treturn res.setBoolean(left.string !== right.string);\n\t\t\t\t} else if (left.isNumber() && right.isNumber()) {\n\t\t\t\t\treturn res.setBoolean(left.number !== right.number);\n\t\t\t\t} else if (left.isBoolean() && right.isBoolean()) {\n\t\t\t\t\treturn res.setBoolean(left.bool !== right.bool);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"&\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number & right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"|\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number | right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"^\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number ^ right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \">>>\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number >>> right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \">>\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number >> right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"<<\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number << right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"UnaryExpression\").tap(\"Parser\", expr => {\n\t\t\tif (expr.operator === \"typeof\") {\n\t\t\t\tlet res;\n\t\t\t\tlet name;\n\t\t\t\tif (expr.argument.type === \"Identifier\") {\n\t\t\t\t\tname =\n\t\t\t\t\t\tthis.scope.renames.get(expr.argument.name) || expr.argument.name;\n\t\t\t\t\tif (!this.scope.definitions.has(name)) {\n\t\t\t\t\t\tconst hook = this.hooks.evaluateTypeof.get(name);\n\t\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\t\tres = hook.call(expr);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (expr.argument.type === \"MemberExpression\") {\n\t\t\t\t\tconst exprName = this.getNameForExpression(expr.argument);\n\t\t\t\t\tif (exprName && exprName.free) {\n\t\t\t\t\t\tconst hook = this.hooks.evaluateTypeof.get(exprName.name);\n\t\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\t\tres = hook.call(expr);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (expr.argument.type === \"FunctionExpression\") {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"function\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tconst arg = this.evaluateExpression(expr.argument);\n\t\t\t\tif (arg.isString() || arg.isWrapped()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"string\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (arg.isNumber()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"number\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (arg.isBoolean()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"boolean\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"object\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"!\") {\n\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\tif (!argument) return;\n\t\t\t\tif (argument.isBoolean()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!argument.bool)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isTruthy()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(false)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isFalsy()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(true)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isString()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!argument.string)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isNumber()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!argument.number)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"~\") {\n\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\tif (!argument) return;\n\t\t\t\tif (!argument.isNumber()) return;\n\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(~argument.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluateTypeof.for(\"undefined\").tap(\"Parser\", expr => {\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setString(\"undefined\")\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t\tthis.hooks.evaluate.for(\"Identifier\").tap(\"Parser\", expr => {\n\t\t\tconst name = this.scope.renames.get(expr.name) || expr.name;\n\t\t\tif (!this.scope.definitions.has(expr.name)) {\n\t\t\t\tconst hook = this.hooks.evaluateIdentifier.get(name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tconst result = hook.call(expr);\n\t\t\t\t\tif (result) return result;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setIdentifier(name)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t} else {\n\t\t\t\tconst hook = this.hooks.evaluateDefinedIdentifier.get(name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\treturn hook.call(expr);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"ThisExpression\").tap(\"Parser\", expr => {\n\t\t\tconst name = this.scope.renames.get(\"this\");\n\t\t\tif (name) {\n\t\t\t\tconst hook = this.hooks.evaluateIdentifier.get(name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tconst result = hook.call(expr);\n\t\t\t\t\tif (result) return result;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setIdentifier(name)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"MemberExpression\").tap(\"Parser\", expression => {\n\t\t\tlet exprName = this.getNameForExpression(expression);\n\t\t\tif (exprName) {\n\t\t\t\tif (exprName.free) {\n\t\t\t\t\tconst hook = this.hooks.evaluateIdentifier.get(exprName.name);\n\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\tconst result = hook.call(expression);\n\t\t\t\t\t\tif (result) return result;\n\t\t\t\t\t}\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setIdentifier(exprName.name)\n\t\t\t\t\t\t.setRange(expression.range);\n\t\t\t\t} else {\n\t\t\t\t\tconst hook = this.hooks.evaluateDefinedIdentifier.get(exprName.name);\n\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\treturn hook.call(expression);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"CallExpression\").tap(\"Parser\", expr => {\n\t\t\tif (expr.callee.type !== \"MemberExpression\") return;\n\t\t\tif (\n\t\t\t\texpr.callee.property.type !==\n\t\t\t\t(expr.callee.computed ? \"Literal\" : \"Identifier\")\n\t\t\t)\n\t\t\t\treturn;\n\t\t\tconst param = this.evaluateExpression(expr.callee.object);\n\t\t\tif (!param) return;\n\t\t\tconst property = expr.callee.property.name || expr.callee.property.value;\n\t\t\tconst hook = this.hooks.evaluateCallExpressionMember.get(property);\n\t\t\tif (hook !== undefined) {\n\t\t\t\treturn hook.call(expr, param);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"replace\")\n\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 2) return;\n\t\t\t\tlet arg1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tlet arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\tif (!arg1.isString() && !arg1.isRegExp()) return;\n\t\t\t\targ1 = arg1.regExp || arg1.string;\n\t\t\t\tif (!arg2.isString()) return;\n\t\t\t\targ2 = arg2.string;\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(param.string.replace(arg1, arg2))\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\t[\"substr\", \"substring\"].forEach(fn => {\n\t\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t\t.for(fn)\n\t\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\t\tif (!param.isString()) return;\n\t\t\t\t\tlet arg1;\n\t\t\t\t\tlet result,\n\t\t\t\t\t\tstr = param.string;\n\t\t\t\t\tswitch (expr.arguments.length) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tconst arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tif (!arg2.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number, arg2.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(result)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t});\n\t\t});\n\n\t\t/**\n\t\t * @param {string} kind \"cooked\" | \"raw\"\n\t\t * @param {TODO} templateLiteralExpr TemplateLiteral expr\n\t\t * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n\t\t */\n\t\tconst getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n\t\t\tconst quasis = [];\n\t\t\tconst parts = [];\n\n\t\t\tfor (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n\t\t\t\tconst quasiExpr = templateLiteralExpr.quasis[i];\n\t\t\t\tconst quasi = quasiExpr.value[kind];\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tconst prevExpr = parts[parts.length - 1];\n\t\t\t\t\tconst expr = this.evaluateExpression(\n\t\t\t\t\t\ttemplateLiteralExpr.expressions[i - 1]\n\t\t\t\t\t);\n\t\t\t\t\tconst exprAsString = expr.asString();\n\t\t\t\t\tif (typeof exprAsString === \"string\") {\n\t\t\t\t\t\t// We can merge quasi + expr + quasi when expr\n\t\t\t\t\t\t// is a const string\n\n\t\t\t\t\t\tprevExpr.setString(prevExpr.string + exprAsString + quasi);\n\t\t\t\t\t\tprevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);\n\t\t\t\t\t\t// We unset the expression as it doesn't match to a single expression\n\t\t\t\t\t\tprevExpr.setExpression(undefined);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tparts.push(expr);\n\t\t\t\t}\n\n\t\t\t\tconst part = new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(quasi)\n\t\t\t\t\t.setRange(quasiExpr.range)\n\t\t\t\t\t.setExpression(quasiExpr);\n\t\t\t\tquasis.push(part);\n\t\t\t\tparts.push(part);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquasis,\n\t\t\t\tparts\n\t\t\t};\n\t\t};\n\n\t\tthis.hooks.evaluate.for(\"TemplateLiteral\").tap(\"Parser\", node => {\n\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\"cooked\", node);\n\t\t\tif (parts.length === 1) {\n\t\t\t\treturn parts[0].setRange(node.range);\n\t\t\t}\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setTemplateString(quasis, parts, \"cooked\")\n\t\t\t\t.setRange(node.range);\n\t\t});\n\t\tthis.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"Parser\", node => {\n\t\t\tif (this.evaluateExpression(node.tag).identifier !== \"String.raw\") return;\n\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\"raw\", node.quasi);\n\t\t\tif (parts.length === 1) {\n\t\t\t\treturn parts[0].setRange(node.range);\n\t\t\t}\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setTemplateString(quasis, parts, \"raw\")\n\t\t\t\t.setRange(node.range);\n\t\t});\n\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"concat\")\n\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\tif (!param.isString() && !param.isWrapped()) return;\n\n\t\t\t\tlet stringSuffix = null;\n\t\t\t\tlet hasUnknownParams = false;\n\t\t\t\tfor (let i = expr.arguments.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst argExpr = this.evaluateExpression(expr.arguments[i]);\n\t\t\t\t\tif (!argExpr.isString() && !argExpr.isNumber()) {\n\t\t\t\t\t\thasUnknownParams = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = argExpr.isString()\n\t\t\t\t\t\t? argExpr.string\n\t\t\t\t\t\t: \"\" + argExpr.number;\n\n\t\t\t\t\tconst newString = value + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\tconst newRange = [\n\t\t\t\t\t\targExpr.range[0],\n\t\t\t\t\t\t(stringSuffix || argExpr).range[1]\n\t\t\t\t\t];\n\t\t\t\t\tstringSuffix = new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setRange(newRange);\n\t\t\t\t}\n\n\t\t\t\tif (hasUnknownParams) {\n\t\t\t\t\tconst prefix = param.isString() ? param : param.prefix;\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(prefix, stringSuffix)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else if (param.isWrapped()) {\n\t\t\t\t\tconst postfix = stringSuffix || param.postfix;\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(param.prefix, postfix)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else {\n\t\t\t\t\tconst newString =\n\t\t\t\t\t\tparam.string + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"split\")\n\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 1) return;\n\t\t\t\tlet result;\n\t\t\t\tconst arg = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tif (arg.isString()) {\n\t\t\t\t\tresult = param.string.split(arg.string);\n\t\t\t\t} else if (arg.isRegExp()) {\n\t\t\t\t\tresult = param.string.split(arg.regExp);\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setArray(result)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\tthis.hooks.evaluate.for(\"ConditionalExpression\").tap(\"Parser\", expr => {\n\t\t\tconst condition = this.evaluateExpression(expr.test);\n\t\t\tconst conditionValue = condition.asBool();\n\t\t\tlet res;\n\t\t\tif (conditionValue === undefined) {\n\t\t\t\tconst consequent = this.evaluateExpression(expr.consequent);\n\t\t\t\tconst alternate = this.evaluateExpression(expr.alternate);\n\t\t\t\tif (!consequent || !alternate) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tif (consequent.isConditional()) {\n\t\t\t\t\tres.setOptions(consequent.options);\n\t\t\t\t} else {\n\t\t\t\t\tres.setOptions([consequent]);\n\t\t\t\t}\n\t\t\t\tif (alternate.isConditional()) {\n\t\t\t\t\tres.addOptions(alternate.options);\n\t\t\t\t} else {\n\t\t\t\t\tres.addOptions([alternate]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tres = this.evaluateExpression(\n\t\t\t\t\tconditionValue ? expr.consequent : expr.alternate\n\t\t\t\t);\n\t\t\t}\n\t\t\tres.setRange(expr.range);\n\t\t\treturn res;\n\t\t});\n\t\tthis.hooks.evaluate.for(\"ArrayExpression\").tap(\"Parser\", expr => {\n\t\t\tconst items = expr.elements.map(element => {\n\t\t\t\treturn element !== null && this.evaluateExpression(element);\n\t\t\t});\n\t\t\tif (!items.every(Boolean)) return;\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setItems(items)\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t}\n\n\tgetRenameIdentifier(expr) {\n\t\tconst result = this.evaluateExpression(expr);\n\t\tif (result && result.isIdentifier()) {\n\t\t\treturn result.identifier;\n\t\t}\n\t}\n\n\twalkClass(classy) {\n\t\tif (classy.superClass) this.walkExpression(classy.superClass);\n\t\tif (classy.body && classy.body.type === \"ClassBody\") {\n\t\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\t\tthis.scope.topLevelScope = false;\n\t\t\tfor (const methodDefinition of classy.body.body) {\n\t\t\t\tif (methodDefinition.type === \"MethodDefinition\") {\n\t\t\t\t\tthis.walkMethodDefinition(methodDefinition);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.scope.topLevelScope = wasTopLevel;\n\t\t}\n\t}\n\n\twalkMethodDefinition(methodDefinition) {\n\t\tif (methodDefinition.computed && methodDefinition.key) {\n\t\t\tthis.walkExpression(methodDefinition.key);\n\t\t}\n\t\tif (methodDefinition.value) {\n\t\t\tthis.walkExpression(methodDefinition.value);\n\t\t}\n\t}\n\n\t// Prewalking iterates the scope for variable declarations\n\tprewalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.prewalkStatement(statement);\n\t\t}\n\t}\n\n\t// Block-Prewalking iterates the scope for block variable declarations\n\tblockPrewalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.blockPrewalkStatement(statement);\n\t\t}\n\t}\n\n\t// Walking iterates the statements and expressions and processes them\n\twalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.walkStatement(statement);\n\t\t}\n\t}\n\n\tprewalkStatement(statement) {\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.prewalkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.prewalkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportAllDeclaration\":\n\t\t\t\tthis.prewalkExportAllDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.prewalkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.prewalkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.prewalkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.prewalkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.prewalkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.prewalkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.prewalkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ImportDeclaration\":\n\t\t\t\tthis.prewalkImportDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.prewalkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.prewalkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.prewalkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.prewalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.prewalkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.prewalkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tblockPrewalkStatement(statement) {\n\t\tswitch (statement.type) {\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.blockPrewalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.blockPrewalkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.blockPrewalkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.blockPrewalkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkStatement(statement) {\n\t\tif (this.hooks.statement.call(statement) !== undefined) return;\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.walkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.walkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.walkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.walkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.walkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExpressionStatement\":\n\t\t\t\tthis.walkExpressionStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.walkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.walkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.walkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.walkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.walkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.walkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ReturnStatement\":\n\t\t\t\tthis.walkReturnStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.walkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ThrowStatement\":\n\t\t\t\tthis.walkThrowStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.walkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.walkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.walkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.walkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Real Statements\n\tprewalkBlockStatement(statement) {\n\t\tthis.prewalkStatements(statement.body);\n\t}\n\n\twalkBlockStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tconst body = statement.body;\n\t\t\tthis.blockPrewalkStatements(body);\n\t\t\tthis.walkStatements(body);\n\t\t});\n\t}\n\n\twalkExpressionStatement(statement) {\n\t\tthis.walkExpression(statement.expression);\n\t}\n\n\tprewalkIfStatement(statement) {\n\t\tthis.prewalkStatement(statement.consequent);\n\t\tif (statement.alternate) {\n\t\t\tthis.prewalkStatement(statement.alternate);\n\t\t}\n\t}\n\n\twalkIfStatement(statement) {\n\t\tconst result = this.hooks.statementIf.call(statement);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(statement.test);\n\t\t\tthis.walkStatement(statement.consequent);\n\t\t\tif (statement.alternate) {\n\t\t\t\tthis.walkStatement(statement.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkStatement(statement.consequent);\n\t\t\t} else if (statement.alternate) {\n\t\t\t\tthis.walkStatement(statement.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\tprewalkLabeledStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkLabeledStatement(statement) {\n\t\tconst hook = this.hooks.label.get(statement.label.name);\n\t\tif (hook !== undefined) {\n\t\t\tconst result = hook.call(statement);\n\t\t\tif (result === true) return;\n\t\t}\n\t\tthis.walkStatement(statement.body);\n\t}\n\n\tprewalkWithStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkWithStatement(statement) {\n\t\tthis.walkExpression(statement.object);\n\t\tthis.walkStatement(statement.body);\n\t}\n\n\tprewalkSwitchStatement(statement) {\n\t\tthis.prewalkSwitchCases(statement.cases);\n\t}\n\n\twalkSwitchStatement(statement) {\n\t\tthis.walkExpression(statement.discriminant);\n\t\tthis.walkSwitchCases(statement.cases);\n\t}\n\n\twalkTerminatingStatement(statement) {\n\t\tif (statement.argument) this.walkExpression(statement.argument);\n\t}\n\n\twalkReturnStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\twalkThrowStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\tprewalkTryStatement(statement) {\n\t\tthis.prewalkStatement(statement.block);\n\t}\n\n\twalkTryStatement(statement) {\n\t\tif (this.scope.inTry) {\n\t\t\tthis.walkStatement(statement.block);\n\t\t} else {\n\t\t\tthis.scope.inTry = true;\n\t\t\tthis.walkStatement(statement.block);\n\t\t\tthis.scope.inTry = false;\n\t\t}\n\t\tif (statement.handler) this.walkCatchClause(statement.handler);\n\t\tif (statement.finalizer) this.walkStatement(statement.finalizer);\n\t}\n\n\tprewalkWhileStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkWhileStatement(statement) {\n\t\tthis.walkExpression(statement.test);\n\t\tthis.walkStatement(statement.body);\n\t}\n\n\tprewalkDoWhileStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkDoWhileStatement(statement) {\n\t\tthis.walkStatement(statement.body);\n\t\tthis.walkExpression(statement.test);\n\t}\n\n\tprewalkForStatement(statement) {\n\t\tif (statement.init) {\n\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\tthis.prewalkStatement(statement.init);\n\t\t\t}\n\t\t}\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkForStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.init) {\n\t\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\t\tthis.blockPrewalkVariableDeclaration(statement.init);\n\t\t\t\t\tthis.walkStatement(statement.init);\n\t\t\t\t} else {\n\t\t\t\t\tthis.walkExpression(statement.init);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (statement.test) {\n\t\t\t\tthis.walkExpression(statement.test);\n\t\t\t}\n\t\t\tif (statement.update) {\n\t\t\t\tthis.walkExpression(statement.update);\n\t\t\t}\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tthis.blockPrewalkStatements(body.body);\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tprewalkForInStatement(statement) {\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.prewalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkForInStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPrewalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tthis.blockPrewalkStatements(body.body);\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tprewalkForOfStatement(statement) {\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.prewalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkForOfStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPrewalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tthis.blockPrewalkStatements(body.body);\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Declarations\n\tprewalkFunctionDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.scope.renames.set(statement.id.name, null);\n\t\t\tthis.scope.definitions.add(statement.id.name);\n\t\t}\n\t}\n\n\twalkFunctionDeclaration(statement) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tthis.inFunctionScope(true, statement.params, () => {\n\t\t\tfor (const param of statement.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (statement.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(statement.body.body);\n\t\t\t\tthis.prewalkStatement(statement.body);\n\t\t\t\tthis.walkStatement(statement.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\tprewalkImportDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tthis.hooks.import.call(statement, source);\n\t\tfor (const specifier of statement.specifiers) {\n\t\t\tconst name = specifier.local.name;\n\t\t\tthis.scope.renames.set(name, null);\n\t\t\tthis.scope.definitions.add(name);\n\t\t\tswitch (specifier.type) {\n\t\t\t\tcase \"ImportDefaultSpecifier\":\n\t\t\t\t\tthis.hooks.importSpecifier.call(statement, source, \"default\", name);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportSpecifier\":\n\t\t\t\t\tthis.hooks.importSpecifier.call(\n\t\t\t\t\t\tstatement,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\tspecifier.imported.name,\n\t\t\t\t\t\tname\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportNamespaceSpecifier\":\n\t\t\t\t\tthis.hooks.importSpecifier.call(statement, source, null, name);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tenterDeclaration(declaration, onIdent) {\n\t\tswitch (declaration.type) {\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tfor (const declarator of declaration.declarations) {\n\t\t\t\t\tswitch (declarator.type) {\n\t\t\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\t\t\tthis.enterPattern(declarator.id, onIdent);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tblockPrewalkExportNamedDeclaration(statement) {\n\t\tif (statement.declaration) {\n\t\t\tthis.blockPrewalkStatement(statement.declaration);\n\t\t}\n\t}\n\n\tprewalkExportNamedDeclaration(statement) {\n\t\tlet source;\n\t\tif (statement.source) {\n\t\t\tsource = statement.source.value;\n\t\t\tthis.hooks.exportImport.call(statement, source);\n\t\t} else {\n\t\t\tthis.hooks.export.call(statement);\n\t\t}\n\t\tif (statement.declaration) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tthis.prewalkStatement(statement.declaration);\n\t\t\t\tlet index = 0;\n\t\t\t\tthis.enterDeclaration(statement.declaration, def => {\n\t\t\t\t\tthis.hooks.exportSpecifier.call(statement, def, def, index++);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (statement.specifiers) {\n\t\t\tfor (\n\t\t\t\tlet specifierIndex = 0;\n\t\t\t\tspecifierIndex < statement.specifiers.length;\n\t\t\t\tspecifierIndex++\n\t\t\t) {\n\t\t\t\tconst specifier = statement.specifiers[specifierIndex];\n\t\t\t\tswitch (specifier.type) {\n\t\t\t\t\tcase \"ExportSpecifier\": {\n\t\t\t\t\t\tconst name = specifier.exported.name;\n\t\t\t\t\t\tif (source) {\n\t\t\t\t\t\t\tthis.hooks.exportImportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalkExportNamedDeclaration(statement) {\n\t\tif (statement.declaration) {\n\t\t\tthis.walkStatement(statement.declaration);\n\t\t}\n\t}\n\n\tblockPrewalkExportDefaultDeclaration(statement) {\n\t\tif (statement.declaration.type === \"ClassDeclaration\") {\n\t\t\tthis.blockPrewalkClassDeclaration(statement.declaration);\n\t\t}\n\t}\n\n\tprewalkExportDefaultDeclaration(statement) {\n\t\tthis.prewalkStatement(statement.declaration);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\tstatement,\n\t\t\t\tstatement.declaration.id.name,\n\t\t\t\t\"default\"\n\t\t\t);\n\t\t}\n\t}\n\n\twalkExportDefaultDeclaration(statement) {\n\t\tthis.hooks.export.call(statement);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tthis.walkStatement(statement.declaration);\n\t\t\t}\n\t\t} else {\n\t\t\t// Acorn parses `export default function() {}` as `FunctionDeclaration` and\n\t\t\t// `export default class {}` as `ClassDeclaration`, both with `id = null`.\n\t\t\t// These nodes must be treated as expressions.\n\t\t\tif (statement.declaration.type === \"FunctionDeclaration\") {\n\t\t\t\tthis.walkFunctionDeclaration(statement.declaration);\n\t\t\t} else if (statement.declaration.type === \"ClassDeclaration\") {\n\t\t\t\tthis.walkClassDeclaration(statement.declaration);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.declaration);\n\t\t\t}\n\t\t\tif (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\tstatement,\n\t\t\t\t\tstatement.declaration,\n\t\t\t\t\t\"default\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprewalkExportAllDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tthis.hooks.exportImport.call(statement, source);\n\t\tthis.hooks.exportImportSpecifier.call(statement, source, null, null, 0);\n\t}\n\n\tprewalkVariableDeclaration(statement) {\n\t\tif (statement.kind !== \"var\") return;\n\t\tthis._prewalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n\t}\n\n\tblockPrewalkVariableDeclaration(statement) {\n\t\tif (statement.kind === \"var\") return;\n\t\tconst hookMap =\n\t\t\tstatement.kind === \"const\"\n\t\t\t\t? this.hooks.varDeclarationConst\n\t\t\t\t: this.hooks.varDeclarationLet;\n\t\tthis._prewalkVariableDeclaration(statement, hookMap);\n\t}\n\n\t_prewalkVariableDeclaration(statement, hookMap) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tthis.enterPattern(declarator.id, (name, decl) => {\n\t\t\t\t\t\tlet hook = hookMap.get(name);\n\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\thook = this.hooks.varDeclaration.get(name);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\t\tthis.scope.renames.set(name, null);\n\t\t\t\t\t\t\t\tthis.scope.definitions.add(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalkVariableDeclaration(statement) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tconst renameIdentifier =\n\t\t\t\t\t\tdeclarator.init && this.getRenameIdentifier(declarator.init);\n\t\t\t\t\tif (renameIdentifier && declarator.id.type === \"Identifier\") {\n\t\t\t\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\t\t\t\tif (hook !== undefined && hook.call(declarator.init)) {\n\t\t\t\t\t\t\t// renaming with \"var a = b;\"\n\t\t\t\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(declarator.init)) {\n\t\t\t\t\t\t\t\tthis.scope.renames.set(\n\t\t\t\t\t\t\t\t\tdeclarator.id.name,\n\t\t\t\t\t\t\t\t\tthis.scope.renames.get(renameIdentifier) || renameIdentifier\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis.scope.definitions.delete(declarator.id.name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.walkPattern(declarator.id);\n\t\t\t\t\tif (declarator.init) this.walkExpression(declarator.init);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tblockPrewalkClassDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.scope.renames.set(statement.id.name, null);\n\t\t\tthis.scope.definitions.add(statement.id.name);\n\t\t}\n\t}\n\n\twalkClassDeclaration(statement) {\n\t\tthis.walkClass(statement);\n\t}\n\n\tprewalkSwitchCases(switchCases) {\n\t\tfor (let index = 0, len = switchCases.length; index < len; index++) {\n\t\t\tconst switchCase = switchCases[index];\n\t\t\tthis.prewalkStatements(switchCase.consequent);\n\t\t}\n\t}\n\n\twalkSwitchCases(switchCases) {\n\t\tfor (let index = 0, len = switchCases.length; index < len; index++) {\n\t\t\tconst switchCase = switchCases[index];\n\n\t\t\tif (switchCase.test) {\n\t\t\t\tthis.walkExpression(switchCase.test);\n\t\t\t}\n\t\t\tthis.walkStatements(switchCase.consequent);\n\t\t}\n\t}\n\n\twalkCatchClause(catchClause) {\n\t\tthis.inBlockScope(() => {\n\t\t\t// Error binding is optional in catch clause since ECMAScript 2019\n\t\t\tif (catchClause.param !== null) {\n\t\t\t\tthis.enterPattern(catchClause.param, ident => {\n\t\t\t\t\tthis.scope.renames.set(ident, null);\n\t\t\t\t\tthis.scope.definitions.add(ident);\n\t\t\t\t});\n\t\t\t\tthis.walkPattern(catchClause.param);\n\t\t\t}\n\t\t\tthis.prewalkStatement(catchClause.body);\n\t\t\tthis.walkStatement(catchClause.body);\n\t\t});\n\t}\n\n\twalkPattern(pattern) {\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.walkArrayPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.walkAssignmentPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.walkObjectPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.walkRestElement(pattern);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkAssignmentPattern(pattern) {\n\t\tthis.walkExpression(pattern.right);\n\t\tthis.walkPattern(pattern.left);\n\t}\n\n\twalkObjectPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.properties.length; i < len; i++) {\n\t\t\tconst prop = pattern.properties[i];\n\t\t\tif (prop) {\n\t\t\t\tif (prop.computed) this.walkExpression(prop.key);\n\t\t\t\tif (prop.value) this.walkPattern(prop.value);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkArrayPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.elements.length; i < len; i++) {\n\t\t\tconst element = pattern.elements[i];\n\t\t\tif (element) this.walkPattern(element);\n\t\t}\n\t}\n\n\twalkRestElement(pattern) {\n\t\tthis.walkPattern(pattern.argument);\n\t}\n\n\twalkExpressions(expressions) {\n\t\tfor (const expression of expressions) {\n\t\t\tif (expression) {\n\t\t\t\tthis.walkExpression(expression);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkExpression(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"ArrayExpression\":\n\t\t\t\tthis.walkArrayExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ArrowFunctionExpression\":\n\t\t\t\tthis.walkArrowFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentExpression\":\n\t\t\t\tthis.walkAssignmentExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AwaitExpression\":\n\t\t\t\tthis.walkAwaitExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tthis.walkBinaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"CallExpression\":\n\t\t\t\tthis.walkCallExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassExpression\":\n\t\t\t\tthis.walkClassExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\":\n\t\t\t\tthis.walkConditionalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionExpression\":\n\t\t\t\tthis.walkFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.walkIdentifier(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"LogicalExpression\":\n\t\t\t\tthis.walkLogicalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"NewExpression\":\n\t\t\t\tthis.walkNewExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectExpression\":\n\t\t\t\tthis.walkObjectExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SequenceExpression\":\n\t\t\t\tthis.walkSequenceExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SpreadElement\":\n\t\t\t\tthis.walkSpreadElement(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TaggedTemplateExpression\":\n\t\t\t\tthis.walkTaggedTemplateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TemplateLiteral\":\n\t\t\t\tthis.walkTemplateLiteral(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ThisExpression\":\n\t\t\t\tthis.walkThisExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UnaryExpression\":\n\t\t\t\tthis.walkUnaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UpdateExpression\":\n\t\t\t\tthis.walkUpdateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"YieldExpression\":\n\t\t\t\tthis.walkYieldExpression(expression);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkAwaitExpression(expression) {\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkArrayExpression(expression) {\n\t\tif (expression.elements) {\n\t\t\tthis.walkExpressions(expression.elements);\n\t\t}\n\t}\n\n\twalkSpreadElement(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\twalkObjectExpression(expression) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = expression.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = expression.properties[propIndex];\n\t\t\tif (prop.type === \"SpreadElement\") {\n\t\t\t\tthis.walkExpression(prop.argument);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (prop.computed) {\n\t\t\t\tthis.walkExpression(prop.key);\n\t\t\t}\n\t\t\tif (prop.shorthand) {\n\t\t\t\tthis.scope.inShorthand = true;\n\t\t\t}\n\t\t\tthis.walkExpression(prop.value);\n\t\t\tif (prop.shorthand) {\n\t\t\t\tthis.scope.inShorthand = false;\n\t\t\t}\n\t\t}\n\t}\n\n\twalkFunctionExpression(expression) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tconst scopeParams = expression.params;\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (expression.id) {\n\t\t\tscopeParams.push(expression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tthis.prewalkStatement(expression.body);\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\twalkArrowFunctionExpression(expression) {\n\t\tthis.inFunctionScope(false, expression.params, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tthis.prewalkStatement(expression.body);\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t}\n\n\twalkSequenceExpression(expression) {\n\t\tif (expression.expressions) this.walkExpressions(expression.expressions);\n\t}\n\n\twalkUpdateExpression(expression) {\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkUnaryExpression(expression) {\n\t\tif (expression.operator === \"typeof\") {\n\t\t\tconst exprName = this.getNameForExpression(expression.argument);\n\t\t\tif (exprName && exprName.free) {\n\t\t\t\tconst hook = this.hooks.typeof.get(exprName.name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tconst result = hook.call(expression);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkLeftRightExpression(expression) {\n\t\tthis.walkExpression(expression.left);\n\t\tthis.walkExpression(expression.right);\n\t}\n\n\twalkBinaryExpression(expression) {\n\t\tthis.walkLeftRightExpression(expression);\n\t}\n\n\twalkLogicalExpression(expression) {\n\t\tconst result = this.hooks.expressionLogicalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkLeftRightExpression(expression);\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.right);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkAssignmentExpression(expression) {\n\t\tconst renameIdentifier = this.getRenameIdentifier(expression.right);\n\t\tif (expression.left.type === \"Identifier\" && renameIdentifier) {\n\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\tif (hook !== undefined && hook.call(expression.right)) {\n\t\t\t\t// renaming \"a = b;\"\n\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\tif (hook === undefined || !hook.call(expression.right)) {\n\t\t\t\t\tthis.scope.renames.set(expression.left.name, renameIdentifier);\n\t\t\t\t\tthis.scope.definitions.delete(expression.left.name);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (expression.left.type === \"Identifier\") {\n\t\t\tconst assignedHook = this.hooks.assigned.get(expression.left.name);\n\t\t\tif (assignedHook === undefined || !assignedHook.call(expression)) {\n\t\t\t\tthis.walkExpression(expression.right);\n\t\t\t}\n\t\t\tthis.scope.renames.set(expression.left.name, null);\n\t\t\tconst assignHook = this.hooks.assign.get(expression.left.name);\n\t\t\tif (assignHook === undefined || !assignHook.call(expression)) {\n\t\t\t\tthis.walkExpression(expression.left);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.walkExpression(expression.right);\n\t\tthis.walkPattern(expression.left);\n\t\tthis.enterPattern(expression.left, (name, decl) => {\n\t\t\tthis.scope.renames.set(name, null);\n\t\t});\n\t}\n\n\twalkConditionalExpression(expression) {\n\t\tconst result = this.hooks.expressionConditionalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(expression.test);\n\t\t\tthis.walkExpression(expression.consequent);\n\t\t\tif (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.consequent);\n\t\t\t} else if (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkNewExpression(expression) {\n\t\tconst callee = this.evaluateExpression(expression.callee);\n\t\tif (callee.isIdentifier()) {\n\t\t\tconst hook = this.hooks.new.get(callee.identifier);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result === true) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.walkExpression(expression.callee);\n\t\tif (expression.arguments) {\n\t\t\tthis.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\twalkYieldExpression(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\twalkTemplateLiteral(expression) {\n\t\tif (expression.expressions) {\n\t\t\tthis.walkExpressions(expression.expressions);\n\t\t}\n\t}\n\n\twalkTaggedTemplateExpression(expression) {\n\t\tif (expression.tag) {\n\t\t\tthis.walkExpression(expression.tag);\n\t\t}\n\t\tif (expression.quasi && expression.quasi.expressions) {\n\t\t\tthis.walkExpressions(expression.quasi.expressions);\n\t\t}\n\t}\n\n\twalkClassExpression(expression) {\n\t\tthis.walkClass(expression);\n\t}\n\n\t_walkIIFE(functionExpression, options, currentThis) {\n\t\tconst renameArgOrThis = argOrThis => {\n\t\t\tconst renameIdentifier = this.getRenameIdentifier(argOrThis);\n\t\t\tif (renameIdentifier) {\n\t\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\t\tif (hook !== undefined && hook.call(argOrThis)) {\n\t\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\t\tif (hook === undefined || !hook.call(argOrThis)) {\n\t\t\t\t\t\treturn renameIdentifier;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(argOrThis);\n\t\t};\n\t\tconst params = functionExpression.params;\n\t\tconst renameThis = currentThis ? renameArgOrThis(currentThis) : null;\n\t\tconst args = options.map(renameArgOrThis);\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tconst scopeParams = params.filter((identifier, idx) => !args[idx]);\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (functionExpression.id) {\n\t\t\tscopeParams.push(functionExpression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tif (renameThis) {\n\t\t\t\tthis.scope.renames.set(\"this\", renameThis);\n\t\t\t}\n\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\tconst param = args[i];\n\t\t\t\tif (!param) continue;\n\t\t\t\tif (!params[i] || params[i].type !== \"Identifier\") continue;\n\t\t\t\tthis.scope.renames.set(params[i].name, param);\n\t\t\t}\n\t\t\tif (functionExpression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(functionExpression.body.body);\n\t\t\t\tthis.prewalkStatement(functionExpression.body);\n\t\t\t\tthis.walkStatement(functionExpression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(functionExpression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\twalkCallExpression(expression) {\n\t\tif (\n\t\t\texpression.callee.type === \"MemberExpression\" &&\n\t\t\texpression.callee.object.type === \"FunctionExpression\" &&\n\t\t\t!expression.callee.computed &&\n\t\t\t(expression.callee.property.name === \"call\" ||\n\t\t\t\texpression.callee.property.name === \"bind\") &&\n\t\t\texpression.arguments.length > 0\n\t\t) {\n\t\t\t// (function() { }.call/bind(?, ))\n\t\t\tthis._walkIIFE(\n\t\t\t\texpression.callee.object,\n\t\t\t\texpression.arguments.slice(1),\n\t\t\t\texpression.arguments[0]\n\t\t\t);\n\t\t} else if (expression.callee.type === \"FunctionExpression\") {\n\t\t\t// (function() { }())\n\t\t\tthis._walkIIFE(expression.callee, expression.arguments, null);\n\t\t} else if (expression.callee.type === \"Import\") {\n\t\t\tlet result = this.hooks.importCall.call(expression);\n\t\t\tif (result === true) return;\n\n\t\t\tif (expression.arguments) this.walkExpressions(expression.arguments);\n\t\t} else {\n\t\t\tconst callee = this.evaluateExpression(expression.callee);\n\t\t\tif (callee.isIdentifier()) {\n\t\t\t\tconst callHook = this.hooks.call.get(callee.identifier);\n\t\t\t\tif (callHook !== undefined) {\n\t\t\t\t\tlet result = callHook.call(expression);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t}\n\t\t\t\tlet identifier = callee.identifier.replace(/\\.[^.]+$/, \"\");\n\t\t\t\tif (identifier !== callee.identifier) {\n\t\t\t\t\tconst callAnyHook = this.hooks.callAnyMember.get(identifier);\n\t\t\t\t\tif (callAnyHook !== undefined) {\n\t\t\t\t\t\tlet result = callAnyHook.call(expression);\n\t\t\t\t\t\tif (result === true) return;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (expression.callee) this.walkExpression(expression.callee);\n\t\t\tif (expression.arguments) this.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\twalkMemberExpression(expression) {\n\t\tconst exprName = this.getNameForExpression(expression);\n\t\tif (exprName && exprName.free) {\n\t\t\tconst expressionHook = this.hooks.expression.get(exprName.name);\n\t\t\tif (expressionHook !== undefined) {\n\t\t\t\tconst result = expressionHook.call(expression);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t\tconst expressionAnyMemberHook = this.hooks.expressionAnyMember.get(\n\t\t\t\texprName.nameGeneral\n\t\t\t);\n\t\t\tif (expressionAnyMemberHook !== undefined) {\n\t\t\t\tconst result = expressionAnyMemberHook.call(expression);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.object);\n\t\tif (expression.computed === true) this.walkExpression(expression.property);\n\t}\n\n\twalkThisExpression(expression) {\n\t\tconst expressionHook = this.hooks.expression.get(\"this\");\n\t\tif (expressionHook !== undefined) {\n\t\t\texpressionHook.call(expression);\n\t\t}\n\t}\n\n\twalkIdentifier(expression) {\n\t\tif (!this.scope.definitions.has(expression.name)) {\n\t\t\tconst hook = this.hooks.expression.get(\n\t\t\t\tthis.scope.renames.get(expression.name) || expression.name\n\t\t\t);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @deprecated\n\t * @param {any} params scope params\n\t * @param {function(): void} fn inner function\n\t * @returns {void}\n\t */\n\tinScope(params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild(),\n\t\t\trenames: oldScope.renames.createChild()\n\t\t};\n\n\t\tthis.scope.renames.set(\"this\", null);\n\n\t\tthis.enterPatterns(params, ident => {\n\t\t\tthis.scope.renames.set(ident, null);\n\t\t\tthis.scope.definitions.add(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tinFunctionScope(hasThis, params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild(),\n\t\t\trenames: oldScope.renames.createChild()\n\t\t};\n\n\t\tif (hasThis) {\n\t\t\tthis.scope.renames.set(\"this\", null);\n\t\t}\n\n\t\tthis.enterPatterns(params, ident => {\n\t\t\tthis.scope.renames.set(ident, null);\n\t\t\tthis.scope.definitions.add(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tinBlockScope(fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: oldScope.inTry,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild(),\n\t\t\trenames: oldScope.renames.createChild()\n\t\t};\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\t// TODO webpack 5: remove this methods\n\t// only for backward-compat\n\tdetectStrictMode(statements) {\n\t\tthis.detectMode(statements);\n\t}\n\n\tdetectMode(statements) {\n\t\tconst isLiteral =\n\t\t\tstatements.length >= 1 &&\n\t\t\tstatements[0].type === \"ExpressionStatement\" &&\n\t\t\tstatements[0].expression.type === \"Literal\";\n\t\tif (isLiteral && statements[0].expression.value === \"use strict\") {\n\t\t\tthis.scope.isStrict = true;\n\t\t}\n\t\tif (isLiteral && statements[0].expression.value === \"use asm\") {\n\t\t\tthis.scope.isAsmJs = true;\n\t\t}\n\t}\n\n\tenterPatterns(patterns, onIdent) {\n\t\tfor (const pattern of patterns) {\n\t\t\tif (typeof pattern !== \"string\") {\n\t\t\t\tthis.enterPattern(pattern, onIdent);\n\t\t\t} else if (pattern) {\n\t\t\t\tonIdent(pattern);\n\t\t\t}\n\t\t}\n\t}\n\n\tenterPattern(pattern, onIdent) {\n\t\tif (!pattern) return;\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.enterArrayPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.enterAssignmentPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.enterIdentifier(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.enterObjectPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.enterRestElement(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Property\":\n\t\t\t\tthis.enterPattern(pattern.value, onIdent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tenterIdentifier(pattern, onIdent) {\n\t\tonIdent(pattern.name, pattern);\n\t}\n\n\tenterObjectPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = pattern.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = pattern.properties[propIndex];\n\t\t\tthis.enterPattern(prop, onIdent);\n\t\t}\n\t}\n\n\tenterArrayPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet elementIndex = 0, len = pattern.elements.length;\n\t\t\telementIndex < len;\n\t\t\telementIndex++\n\t\t) {\n\t\t\tconst element = pattern.elements[elementIndex];\n\t\t\tthis.enterPattern(element, onIdent);\n\t\t}\n\t}\n\n\tenterRestElement(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.argument, onIdent);\n\t}\n\n\tenterAssignmentPattern(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.left, onIdent);\n\t}\n\n\tevaluateExpression(expression) {\n\t\ttry {\n\t\t\tconst hook = this.hooks.evaluate.get(expression.type);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result !== undefined) {\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tresult.setExpression(expression);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.warn(e);\n\t\t\t// ignore error\n\t\t}\n\t\treturn new BasicEvaluatedExpression()\n\t\t\t.setRange(expression.range)\n\t\t\t.setExpression(expression);\n\t}\n\n\tparseString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.parseString(expression.left) +\n\t\t\t\t\t\tthis.parseString(expression.right)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"Literal\":\n\t\t\t\treturn expression.value + \"\";\n\t\t}\n\t\tthrow new Error(\n\t\t\texpression.type + \" is not supported as parameter for require\"\n\t\t);\n\t}\n\n\tparseCalculatedString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\tconst left = this.parseCalculatedString(expression.left);\n\t\t\t\t\tconst right = this.parseCalculatedString(expression.right);\n\t\t\t\t\tif (left.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: left.range,\n\t\t\t\t\t\t\tvalue: left.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (right.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [\n\t\t\t\t\t\t\t\tleft.range[0],\n\t\t\t\t\t\t\t\tright.range ? right.range[1] : left.range[1]\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [left.range[0], right.range[1]],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: false,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\": {\n\t\t\t\tconst consequent = this.parseCalculatedString(expression.consequent);\n\t\t\t\tconst alternate = this.parseCalculatedString(expression.alternate);\n\t\t\t\tconst items = [];\n\t\t\t\tif (consequent.conditional) {\n\t\t\t\t\titems.push(...consequent.conditional);\n\t\t\t\t} else if (!consequent.code) {\n\t\t\t\t\titems.push(consequent);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (alternate.conditional) {\n\t\t\t\t\titems.push(...alternate.conditional);\n\t\t\t\t} else if (!alternate.code) {\n\t\t\t\t\titems.push(alternate);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\trange: undefined,\n\t\t\t\t\tvalue: \"\",\n\t\t\t\t\tcode: true,\n\t\t\t\t\tconditional: items\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Literal\":\n\t\t\t\treturn {\n\t\t\t\t\trange: expression.range,\n\t\t\t\t\tvalue: expression.value + \"\",\n\t\t\t\t\tcode: false,\n\t\t\t\t\tconditional: false\n\t\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\trange: undefined,\n\t\t\tvalue: \"\",\n\t\t\tcode: true,\n\t\t\tconditional: false\n\t\t};\n\t}\n\n\tparse(source, initialState) {\n\t\tlet ast;\n\t\tlet comments;\n\t\tif (typeof source === \"object\" && source !== null) {\n\t\t\tast = source;\n\t\t\tcomments = source.comments;\n\t\t} else {\n\t\t\tcomments = [];\n\t\t\tast = Parser.parse(source, {\n\t\t\t\tsourceType: this.sourceType,\n\t\t\t\tonComment: comments\n\t\t\t});\n\t\t}\n\n\t\tconst oldScope = this.scope;\n\t\tconst oldState = this.state;\n\t\tconst oldComments = this.comments;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: true,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: false,\n\t\t\tisAsmJs: false,\n\t\t\tdefinitions: new StackedSetMap(),\n\t\t\trenames: new StackedSetMap()\n\t\t};\n\t\tconst state = (this.state = initialState || {});\n\t\tthis.comments = comments;\n\t\tif (this.hooks.program.call(ast, comments) === undefined) {\n\t\t\tthis.detectMode(ast.body);\n\t\t\tthis.prewalkStatements(ast.body);\n\t\t\tthis.blockPrewalkStatements(ast.body);\n\t\t\tthis.walkStatements(ast.body);\n\t\t}\n\t\tthis.scope = oldScope;\n\t\tthis.state = oldState;\n\t\tthis.comments = oldComments;\n\t\treturn state;\n\t}\n\n\tevaluate(source) {\n\t\tconst ast = Parser.parse(\"(\" + source + \")\", {\n\t\t\tsourceType: this.sourceType,\n\t\t\tlocations: false\n\t\t});\n\t\t// TODO(https://github.com/acornjs/acorn/issues/741)\n\t\t// @ts-ignore\n\t\tif (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n\t\t\tthrow new Error(\"evaluate: Source is not a expression\");\n\t\t}\n\t\t// TODO(https://github.com/acornjs/acorn/issues/741)\n\t\t// @ts-ignore\n\t\treturn this.evaluateExpression(ast.body[0].expression);\n\t}\n\n\tgetComments(range) {\n\t\treturn this.comments.filter(\n\t\t\tcomment => comment.range[0] >= range[0] && comment.range[1] <= range[1]\n\t\t);\n\t}\n\n\tparseCommentOptions(range) {\n\t\tconst comments = this.getComments(range);\n\t\tif (comments.length === 0) {\n\t\t\treturn EMPTY_COMMENT_OPTIONS;\n\t\t}\n\t\tlet options = {};\n\t\tlet errors = [];\n\t\tfor (const comment of comments) {\n\t\t\tconst { value } = comment;\n\t\t\tif (value && webpackCommentRegExp.test(value)) {\n\t\t\t\t// try compile only if webpack options comment is present\n\t\t\t\ttry {\n\t\t\t\t\tconst val = vm.runInNewContext(`(function(){return {${value}};})()`);\n\t\t\t\t\tObject.assign(options, val);\n\t\t\t\t} catch (e) {\n\t\t\t\t\te.comment = comment;\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { options, errors };\n\t}\n\n\tgetNameForExpression(expression) {\n\t\tlet expr = expression;\n\t\tconst exprName = [];\n\t\twhile (\n\t\t\texpr.type === \"MemberExpression\" &&\n\t\t\texpr.property.type === (expr.computed ? \"Literal\" : \"Identifier\")\n\t\t) {\n\t\t\texprName.push(expr.computed ? expr.property.value : expr.property.name);\n\t\t\texpr = expr.object;\n\t\t}\n\t\tlet free;\n\t\tif (expr.type === \"Identifier\") {\n\t\t\tfree = !this.scope.definitions.has(expr.name);\n\t\t\texprName.push(this.scope.renames.get(expr.name) || expr.name);\n\t\t} else if (\n\t\t\texpr.type === \"ThisExpression\" &&\n\t\t\tthis.scope.renames.get(\"this\")\n\t\t) {\n\t\t\tfree = true;\n\t\t\texprName.push(this.scope.renames.get(\"this\"));\n\t\t} else if (expr.type === \"ThisExpression\") {\n\t\t\tfree = this.scope.topLevelScope;\n\t\t\texprName.push(\"this\");\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t\tlet prefix = \"\";\n\t\tfor (let i = exprName.length - 1; i >= 2; i--) {\n\t\t\tprefix += exprName[i] + \".\";\n\t\t}\n\t\tif (exprName.length > 1) {\n\t\t\tprefix += exprName[1];\n\t\t}\n\t\tconst name = prefix ? prefix + \".\" + exprName[0] : exprName[0];\n\t\tconst nameGeneral = prefix;\n\t\treturn {\n\t\t\tname,\n\t\t\tnameGeneral,\n\t\t\tfree\n\t\t};\n\t}\n\n\tstatic parse(code, options) {\n\t\tconst type = options ? options.sourceType : \"module\";\n\t\tconst parserOptions = Object.assign(\n\t\t\tObject.create(null),\n\t\t\tdefaultParserOptions,\n\t\t\toptions\n\t\t);\n\n\t\tif (type === \"auto\") {\n\t\t\tparserOptions.sourceType = \"module\";\n\t\t} else if (parserOptions.sourceType === \"script\") {\n\t\t\tparserOptions.allowReturnOutsideFunction = true;\n\t\t}\n\n\t\tlet ast;\n\t\tlet error;\n\t\tlet threw = false;\n\t\ttry {\n\t\t\tast = acornParser.parse(code, parserOptions);\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t\tthrew = true;\n\t\t}\n\n\t\tif (threw && type === \"auto\") {\n\t\t\tparserOptions.sourceType = \"script\";\n\t\t\tparserOptions.allowReturnOutsideFunction = true;\n\t\t\tif (Array.isArray(parserOptions.onComment)) {\n\t\t\t\tparserOptions.onComment.length = 0;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tast = acornParser.parse(code, parserOptions);\n\t\t\t\tthrew = false;\n\t\t\t} catch (e) {\n\t\t\t\tthrew = true;\n\t\t\t}\n\t\t}\n\n\t\tif (threw) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn ast;\n\t}\n}\n\n// TODO remove in webpack 5\nObject.defineProperty(Parser.prototype, \"getCommentOptions\", {\n\tconfigurable: false,\n\tvalue: util.deprecate(\n\t\t/**\n\t\t * @deprecated\n\t\t * @param {TODO} range Range\n\t\t * @returns {void}\n\t\t * @this {Parser}\n\t\t */\n\t\tfunction(range) {\n\t\t\treturn this.parseCommentOptions(range).options;\n\t\t},\n\t\t\"Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead\"\n\t)\n});\n\nmodule.exports = Parser;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}