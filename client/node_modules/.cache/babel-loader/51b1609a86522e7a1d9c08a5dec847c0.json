{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Florent Cailhol @ooflorent\n*/\n\"use strict\";\n\n/** @typedef {import(\"../Module\")} Module */\nclass DependencyReference {\n  // TODO webpack 5: module must be dynamic, you must pass a function returning a module\n  // This is needed to remove the hack in ConcatenatedModule\n  // The problem is that the `module` in Dependency could be replaced i. e. because of Scope Hoisting\n  /**\n   *\n   * @param {Module} module the referenced module\n   * @param {string[] | boolean} importedNames imported named from the module\n   * @param {boolean=} weak if this is a weak reference\n   * @param {number} order the order information or NaN if don't care\n   */\n  constructor(module, importedNames, weak = false, order = NaN) {\n    // TODO webpack 5: make it a getter\n    this.module = module;\n    // true: full object\n    // false: only sideeffects/no export\n    // array of strings: the exports with this names\n    this.importedNames = importedNames;\n    this.weak = !!weak;\n    this.order = order;\n  }\n\n  /**\n   * @param {DependencyReference[]} array an array (will be modified)\n   * @returns {DependencyReference[]} the array again\n   */\n  static sort(array) {\n    /** @type {WeakMap<DependencyReference, number>} */\n    const originalOrder = new WeakMap();\n    let i = 0;\n    for (const ref of array) {\n      originalOrder.set(ref, i++);\n    }\n    return array.sort((a, b) => {\n      const aOrder = a.order;\n      const bOrder = b.order;\n      if (isNaN(aOrder)) {\n        if (!isNaN(bOrder)) {\n          return 1;\n        }\n      } else {\n        if (isNaN(bOrder)) {\n          return -1;\n        }\n        if (aOrder !== bOrder) {\n          return aOrder - bOrder;\n        }\n      }\n      const aOrg = originalOrder.get(a);\n      const bOrg = originalOrder.get(b);\n      return aOrg - bOrg;\n    });\n  }\n}\nmodule.exports = DependencyReference;","map":{"version":3,"names":["DependencyReference","constructor","module","importedNames","weak","order","NaN","sort","array","originalOrder","WeakMap","i","ref","set","a","b","aOrder","bOrder","isNaN","aOrg","get","bOrg","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/dependencies/DependencyReference.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Florent Cailhol @ooflorent\n*/\n\"use strict\";\n\n/** @typedef {import(\"../Module\")} Module */\n\nclass DependencyReference {\n\t// TODO webpack 5: module must be dynamic, you must pass a function returning a module\n\t// This is needed to remove the hack in ConcatenatedModule\n\t// The problem is that the `module` in Dependency could be replaced i. e. because of Scope Hoisting\n\t/**\n\t *\n\t * @param {Module} module the referenced module\n\t * @param {string[] | boolean} importedNames imported named from the module\n\t * @param {boolean=} weak if this is a weak reference\n\t * @param {number} order the order information or NaN if don't care\n\t */\n\tconstructor(module, importedNames, weak = false, order = NaN) {\n\t\t// TODO webpack 5: make it a getter\n\t\tthis.module = module;\n\t\t// true: full object\n\t\t// false: only sideeffects/no export\n\t\t// array of strings: the exports with this names\n\t\tthis.importedNames = importedNames;\n\t\tthis.weak = !!weak;\n\t\tthis.order = order;\n\t}\n\n\t/**\n\t * @param {DependencyReference[]} array an array (will be modified)\n\t * @returns {DependencyReference[]} the array again\n\t */\n\tstatic sort(array) {\n\t\t/** @type {WeakMap<DependencyReference, number>} */\n\t\tconst originalOrder = new WeakMap();\n\t\tlet i = 0;\n\t\tfor (const ref of array) {\n\t\t\toriginalOrder.set(ref, i++);\n\t\t}\n\t\treturn array.sort((a, b) => {\n\t\t\tconst aOrder = a.order;\n\t\t\tconst bOrder = b.order;\n\t\t\tif (isNaN(aOrder)) {\n\t\t\t\tif (!isNaN(bOrder)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (isNaN(bOrder)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (aOrder !== bOrder) {\n\t\t\t\t\treturn aOrder - bOrder;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst aOrg = originalOrder.get(a);\n\t\t\tconst bOrg = originalOrder.get(b);\n\t\t\treturn aOrg - bOrg;\n\t\t});\n\t}\n}\n\nmodule.exports = DependencyReference;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AAEA,MAAMA,mBAAmB,CAAC;EACzB;EACA;EACA;EACA;AACD;AACA;AACA;AACA;AACA;AACA;EACCC,WAAWA,CAACC,MAAM,EAAEC,aAAa,EAAEC,IAAI,GAAG,KAAK,EAAEC,KAAK,GAAGC,GAAG,EAAE;IAC7D;IACA,IAAI,CAACJ,MAAM,GAAGA,MAAM;IACpB;IACA;IACA;IACA,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,IAAI,GAAG,CAAC,CAACA,IAAI;IAClB,IAAI,CAACC,KAAK,GAAGA,KAAK;EACnB;;EAEA;AACD;AACA;AACA;EACC,OAAOE,IAAIA,CAACC,KAAK,EAAE;IAClB;IACA,MAAMC,aAAa,GAAG,IAAIC,OAAO,CAAC,CAAC;IACnC,IAAIC,CAAC,GAAG,CAAC;IACT,KAAK,MAAMC,GAAG,IAAIJ,KAAK,EAAE;MACxBC,aAAa,CAACI,GAAG,CAACD,GAAG,EAAED,CAAC,EAAE,CAAC;IAC5B;IACA,OAAOH,KAAK,CAACD,IAAI,CAAC,CAACO,CAAC,EAAEC,CAAC,KAAK;MAC3B,MAAMC,MAAM,GAAGF,CAAC,CAACT,KAAK;MACtB,MAAMY,MAAM,GAAGF,CAAC,CAACV,KAAK;MACtB,IAAIa,KAAK,CAACF,MAAM,CAAC,EAAE;QAClB,IAAI,CAACE,KAAK,CAACD,MAAM,CAAC,EAAE;UACnB,OAAO,CAAC;QACT;MACD,CAAC,MAAM;QACN,IAAIC,KAAK,CAACD,MAAM,CAAC,EAAE;UAClB,OAAO,CAAC,CAAC;QACV;QACA,IAAID,MAAM,KAAKC,MAAM,EAAE;UACtB,OAAOD,MAAM,GAAGC,MAAM;QACvB;MACD;MACA,MAAME,IAAI,GAAGV,aAAa,CAACW,GAAG,CAACN,CAAC,CAAC;MACjC,MAAMO,IAAI,GAAGZ,aAAa,CAACW,GAAG,CAACL,CAAC,CAAC;MACjC,OAAOI,IAAI,GAAGE,IAAI;IACnB,CAAC,CAAC;EACH;AACD;AAEAnB,MAAM,CAACoB,OAAO,GAAGtB,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"script"}