{"ast":null,"code":"\"use strict\";\n\nconst path = require(\"path\");\n\n/**\n * @param {string} context context for relative path\n * @param {string} relativePath path\n * @returns {string} absolute path\n */\nconst requestToAbsolute = (context, relativePath) => {\n  if (relativePath.startsWith(\"./\") || relativePath.startsWith(\"../\")) return path.join(context, relativePath);\n  return relativePath;\n};\n\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\n/**\n *\n * @param {string} maybeAbsolutePath path to check\n * @returns {boolean} returns true if path is \"Absolute Path\"-like\n */\nconst looksLikeAbsolutePath = maybeAbsolutePath => {\n  if (/^\\/.*\\/$/.test(maybeAbsolutePath)) {\n    // this 'path' is actually a regexp generated by dynamic requires.\n    // Don't treat it as an absolute path.\n    return false;\n  }\n  return /^(?:[a-z]:\\\\|\\/)/i.test(maybeAbsolutePath);\n};\n\n/**\n *\n * @param {string} p path to normalize\n * @returns {string} normalized version of path\n */\nconst normalizePathSeparator = p => p.replace(/\\\\/g, \"/\");\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nconst _makePathsRelative = (context, identifier) => {\n  return identifier.split(/([|! ])/).map(str => looksLikeAbsolutePath(str) ? normalizePathSeparator(path.relative(context, str)) : str).join(\"\");\n};\n\n/**\n *\n * @param {string} context context used to create relative path\n * @param {string} identifier identifier used to create relative path\n * @param {MakeRelativePathsCache=} cache the cache object being set\n * @returns {string} the returned relative path\n */\nexports.makePathsRelative = (context, identifier, cache) => {\n  if (!cache) return _makePathsRelative(context, identifier);\n  const relativePaths = cache.relativePaths || (cache.relativePaths = new Map());\n  let cachedResult;\n  let contextCache = relativePaths.get(context);\n  if (contextCache === undefined) {\n    relativePaths.set(context, contextCache = new Map());\n  } else {\n    cachedResult = contextCache.get(identifier);\n  }\n  if (cachedResult !== undefined) {\n    return cachedResult;\n  } else {\n    const relativePath = _makePathsRelative(context, identifier);\n    contextCache.set(identifier, relativePath);\n    return relativePath;\n  }\n};\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\nexports.contextify = (context, request) => {\n  return request.split(\"!\").map(r => {\n    const splitPath = r.split(\"?\", 2);\n    if (/^[a-zA-Z]:\\\\/.test(splitPath[0])) {\n      splitPath[0] = path.win32.relative(context, splitPath[0]);\n      if (!/^[a-zA-Z]:\\\\/.test(splitPath[0])) {\n        splitPath[0] = splitPath[0].replace(/\\\\/g, \"/\");\n      }\n    }\n    if (/^\\//.test(splitPath[0])) {\n      splitPath[0] = path.posix.relative(context, splitPath[0]);\n    }\n    if (!/^(\\.\\.\\/|\\/|[a-zA-Z]:\\\\)/.test(splitPath[0])) {\n      splitPath[0] = \"./\" + splitPath[0];\n    }\n    return splitPath.join(\"?\");\n  }).join(\"!\");\n};\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string\n * @returns {string} a new request string using absolute paths when possible\n */\nconst _absolutify = (context, request) => {\n  return request.split(\"!\").map(r => requestToAbsolute(context, r)).join(\"!\");\n};\nexports.absolutify = _absolutify;","map":{"version":3,"names":["path","require","requestToAbsolute","context","relativePath","startsWith","join","looksLikeAbsolutePath","maybeAbsolutePath","test","normalizePathSeparator","p","replace","_makePathsRelative","identifier","split","map","str","relative","exports","makePathsRelative","cache","relativePaths","Map","cachedResult","contextCache","get","undefined","set","contextify","request","r","splitPath","win32","posix","_absolutify","absolutify"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/util/identifier.js"],"sourcesContent":["\"use strict\";\nconst path = require(\"path\");\n\n/**\n * @param {string} context context for relative path\n * @param {string} relativePath path\n * @returns {string} absolute path\n */\nconst requestToAbsolute = (context, relativePath) => {\n\tif (relativePath.startsWith(\"./\") || relativePath.startsWith(\"../\"))\n\t\treturn path.join(context, relativePath);\n\treturn relativePath;\n};\n\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\n/**\n *\n * @param {string} maybeAbsolutePath path to check\n * @returns {boolean} returns true if path is \"Absolute Path\"-like\n */\nconst looksLikeAbsolutePath = maybeAbsolutePath => {\n\tif (/^\\/.*\\/$/.test(maybeAbsolutePath)) {\n\t\t// this 'path' is actually a regexp generated by dynamic requires.\n\t\t// Don't treat it as an absolute path.\n\t\treturn false;\n\t}\n\treturn /^(?:[a-z]:\\\\|\\/)/i.test(maybeAbsolutePath);\n};\n\n/**\n *\n * @param {string} p path to normalize\n * @returns {string} normalized version of path\n */\nconst normalizePathSeparator = p => p.replace(/\\\\/g, \"/\");\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nconst _makePathsRelative = (context, identifier) => {\n\treturn identifier\n\t\t.split(/([|! ])/)\n\t\t.map(str =>\n\t\t\tlooksLikeAbsolutePath(str)\n\t\t\t\t? normalizePathSeparator(path.relative(context, str))\n\t\t\t\t: str\n\t\t)\n\t\t.join(\"\");\n};\n\n/**\n *\n * @param {string} context context used to create relative path\n * @param {string} identifier identifier used to create relative path\n * @param {MakeRelativePathsCache=} cache the cache object being set\n * @returns {string} the returned relative path\n */\nexports.makePathsRelative = (context, identifier, cache) => {\n\tif (!cache) return _makePathsRelative(context, identifier);\n\n\tconst relativePaths =\n\t\tcache.relativePaths || (cache.relativePaths = new Map());\n\n\tlet cachedResult;\n\tlet contextCache = relativePaths.get(context);\n\tif (contextCache === undefined) {\n\t\trelativePaths.set(context, (contextCache = new Map()));\n\t} else {\n\t\tcachedResult = contextCache.get(identifier);\n\t}\n\n\tif (cachedResult !== undefined) {\n\t\treturn cachedResult;\n\t} else {\n\t\tconst relativePath = _makePathsRelative(context, identifier);\n\t\tcontextCache.set(identifier, relativePath);\n\t\treturn relativePath;\n\t}\n};\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\nexports.contextify = (context, request) => {\n\treturn request\n\t\t.split(\"!\")\n\t\t.map(r => {\n\t\t\tconst splitPath = r.split(\"?\", 2);\n\t\t\tif (/^[a-zA-Z]:\\\\/.test(splitPath[0])) {\n\t\t\t\tsplitPath[0] = path.win32.relative(context, splitPath[0]);\n\t\t\t\tif (!/^[a-zA-Z]:\\\\/.test(splitPath[0])) {\n\t\t\t\t\tsplitPath[0] = splitPath[0].replace(/\\\\/g, \"/\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (/^\\//.test(splitPath[0])) {\n\t\t\t\tsplitPath[0] = path.posix.relative(context, splitPath[0]);\n\t\t\t}\n\t\t\tif (!/^(\\.\\.\\/|\\/|[a-zA-Z]:\\\\)/.test(splitPath[0])) {\n\t\t\t\tsplitPath[0] = \"./\" + splitPath[0];\n\t\t\t}\n\t\t\treturn splitPath.join(\"?\");\n\t\t})\n\t\t.join(\"!\");\n};\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string\n * @returns {string} a new request string using absolute paths when possible\n */\nconst _absolutify = (context, request) => {\n\treturn request\n\t\t.split(\"!\")\n\t\t.map(r => requestToAbsolute(context, r))\n\t\t.join(\"!\");\n};\n\nexports.absolutify = _absolutify;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}