{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst path = require(\"path\");\nconst {\n  ConcatSource,\n  RawSource\n} = require(\"webpack-sources\");\nconst ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\nconst SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\nconst createHash = require(\"./util/createHash\");\nconst {\n  absolutify\n} = require(\"./util/identifier\");\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../schemas/plugins/SourceMapDevToolPlugin.json\");\n\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"source-map\").RawSourceMap} SourceMap */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Compilation\")} SourceMapDefinition */\n\n/**\n * @typedef {object} SourceMapTask\n * @property {Source} asset\n * @property {Array<string | Module>} [modules]\n * @property {string} source\n * @property {string} file\n * @property {SourceMap} sourceMap\n * @property {Chunk} chunk\n */\n\n/**\n * @param {string} name file path\n * @returns {string} file name\n */\nconst basename = name => {\n  if (!name.includes(\"/\")) return name;\n  return name.substr(name.lastIndexOf(\"/\") + 1);\n};\n\n/**\n * @type {WeakMap<Source, {file: string, assets: {[k: string]: ConcatSource | RawSource}}>}\n */\nconst assetsCache = new WeakMap();\n\n/**\n * Creating {@link SourceMapTask} for given file\n * @param {string} file current compiled file\n * @param {Source} asset the asset\n * @param {Chunk} chunk related chunk\n * @param {SourceMapDevToolPluginOptions} options source map options\n * @param {Compilation} compilation compilation instance\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\n */\nconst getTaskForFile = (file, asset, chunk, options, compilation) => {\n  let source, sourceMap;\n  /**\n   * Check if asset can build source map\n   */\n  if (asset.sourceAndMap) {\n    const sourceAndMap = asset.sourceAndMap(options);\n    sourceMap = sourceAndMap.map;\n    source = sourceAndMap.source;\n  } else {\n    sourceMap = asset.map(options);\n    source = asset.source();\n  }\n  if (!sourceMap || typeof source !== \"string\") return;\n  const context = compilation.options.context;\n  const modules = sourceMap.sources.map(source => {\n    if (source.startsWith(\"webpack://\")) {\n      source = absolutify(context, source.slice(10));\n    }\n    const module = compilation.findModule(source);\n    return module || source;\n  });\n  return {\n    chunk,\n    file,\n    asset,\n    source,\n    sourceMap,\n    modules\n  };\n};\nclass SourceMapDevToolPlugin {\n  /**\n   * @param {SourceMapDevToolPluginOptions} [options] options object\n   * @throws {Error} throws error, if got more than 1 arguments\n   */\n  constructor(options) {\n    if (arguments.length > 1) {\n      throw new Error(\"SourceMapDevToolPlugin only takes one argument (pass an options object)\");\n    }\n    if (!options) options = {};\n    validateOptions(schema, options, \"SourceMap DevTool Plugin\");\n\n    /** @type {string | false} */\n    this.sourceMapFilename = options.filename;\n    /** @type {string | false} */\n    this.sourceMappingURLComment = options.append === false ? false : options.append || \"\\n//# sourceMappingURL=[url]\";\n    /** @type {string | Function} */\n    this.moduleFilenameTemplate = options.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n    /** @type {string | Function} */\n    this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || \"webpack://[namespace]/[resourcePath]?[hash]\";\n    /** @type {string} */\n    this.namespace = options.namespace || \"\";\n    /** @type {SourceMapDevToolPluginOptions} */\n    this.options = options;\n  }\n\n  /**\n   * Apply compiler\n   * @param {Compiler} compiler compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const sourceMapFilename = this.sourceMapFilename;\n    const sourceMappingURLComment = this.sourceMappingURLComment;\n    const moduleFilenameTemplate = this.moduleFilenameTemplate;\n    const namespace = this.namespace;\n    const fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n    const requestShortener = compiler.requestShortener;\n    const options = this.options;\n    options.test = options.test || /\\.(m?js|css)($|\\?)/i;\n    const matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, options);\n    compiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", compilation => {\n      new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n      compilation.hooks.afterOptimizeChunkAssets.tap(/** @type {TODO} */\n      {\n        name: \"SourceMapDevToolPlugin\",\n        context: true\n      },\n      /**\n       * @param {object} context hook context\n       * @param {Array<Chunk>} chunks resulted chunks\n       * @throws {Error} throws error, if `sourceMapFilename === false && sourceMappingURLComment === false`\n       * @returns {void}\n       */\n      (context, chunks) => {\n        /** @type {Map<string | Module, string>} */\n        const moduleToSourceNameMapping = new Map();\n        /**\n         * @type {Function}\n         * @returns {void}\n         */\n        const reportProgress = context && context.reportProgress ? context.reportProgress : () => {};\n        const files = [];\n        for (const chunk of chunks) {\n          for (const file of chunk.files) {\n            if (matchObject(file)) {\n              files.push({\n                file,\n                chunk\n              });\n            }\n          }\n        }\n        reportProgress(0.0);\n        const tasks = [];\n        files.forEach(({\n          file,\n          chunk\n        }, idx) => {\n          const asset = compilation.getAsset(file).source;\n          const cache = assetsCache.get(asset);\n          /**\n           * If presented in cache, reassigns assets. Cache assets already have source maps.\n           */\n          if (cache && cache.file === file) {\n            for (const cachedFile in cache.assets) {\n              if (cachedFile === file) {\n                compilation.updateAsset(cachedFile, cache.assets[cachedFile]);\n              } else {\n                compilation.emitAsset(cachedFile, cache.assets[cachedFile], {\n                  development: true\n                });\n              }\n              /**\n               * Add file to chunk, if not presented there\n               */\n              if (cachedFile !== file) chunk.files.push(cachedFile);\n            }\n            return;\n          }\n          reportProgress(0.5 * idx / files.length, file, \"generate SourceMap\");\n          /** @type {SourceMapTask | undefined} */\n          const task = getTaskForFile(file, asset, chunk, options, compilation);\n          if (task) {\n            const modules = task.modules;\n            for (let idx = 0; idx < modules.length; idx++) {\n              const module = modules[idx];\n              if (!moduleToSourceNameMapping.get(module)) {\n                moduleToSourceNameMapping.set(module, ModuleFilenameHelpers.createFilename(module, {\n                  moduleFilenameTemplate: moduleFilenameTemplate,\n                  namespace: namespace\n                }, requestShortener));\n              }\n            }\n            tasks.push(task);\n          }\n        });\n        reportProgress(0.5, \"resolve sources\");\n        /** @type {Set<string>} */\n        const usedNamesSet = new Set(moduleToSourceNameMapping.values());\n        /** @type {Set<string>} */\n        const conflictDetectionSet = new Set();\n\n        /**\n         * all modules in defined order (longest identifier first)\n         * @type {Array<string | Module>}\n         */\n        const allModules = Array.from(moduleToSourceNameMapping.keys()).sort((a, b) => {\n          const ai = typeof a === \"string\" ? a : a.identifier();\n          const bi = typeof b === \"string\" ? b : b.identifier();\n          return ai.length - bi.length;\n        });\n\n        // find modules with conflicting source names\n        for (let idx = 0; idx < allModules.length; idx++) {\n          const module = allModules[idx];\n          let sourceName = moduleToSourceNameMapping.get(module);\n          let hasName = conflictDetectionSet.has(sourceName);\n          if (!hasName) {\n            conflictDetectionSet.add(sourceName);\n            continue;\n          }\n\n          // try the fallback name first\n          sourceName = ModuleFilenameHelpers.createFilename(module, {\n            moduleFilenameTemplate: fallbackModuleFilenameTemplate,\n            namespace: namespace\n          }, requestShortener);\n          hasName = usedNamesSet.has(sourceName);\n          if (!hasName) {\n            moduleToSourceNameMapping.set(module, sourceName);\n            usedNamesSet.add(sourceName);\n            continue;\n          }\n\n          // elsewise just append stars until we have a valid name\n          while (hasName) {\n            sourceName += \"*\";\n            hasName = usedNamesSet.has(sourceName);\n          }\n          moduleToSourceNameMapping.set(module, sourceName);\n          usedNamesSet.add(sourceName);\n        }\n        tasks.forEach((task, index) => {\n          reportProgress(0.5 + 0.5 * index / tasks.length, task.file, \"attach SourceMap\");\n          const assets = Object.create(null);\n          const chunk = task.chunk;\n          const file = task.file;\n          const asset = task.asset;\n          const sourceMap = task.sourceMap;\n          const source = task.source;\n          const modules = task.modules;\n          const moduleFilenames = modules.map(m => moduleToSourceNameMapping.get(m));\n          sourceMap.sources = moduleFilenames;\n          if (options.noSources) {\n            sourceMap.sourcesContent = undefined;\n          }\n          sourceMap.sourceRoot = options.sourceRoot || \"\";\n          sourceMap.file = file;\n          assetsCache.set(asset, {\n            file,\n            assets\n          });\n          /** @type {string | false} */\n          let currentSourceMappingURLComment = sourceMappingURLComment;\n          if (currentSourceMappingURLComment !== false && /\\.css($|\\?)/i.test(file)) {\n            currentSourceMappingURLComment = currentSourceMappingURLComment.replace(/^\\n\\/\\/(.*)$/, \"\\n/*$1*/\");\n          }\n          const sourceMapString = JSON.stringify(sourceMap);\n          if (sourceMapFilename) {\n            let filename = file;\n            let query = \"\";\n            const idx = filename.indexOf(\"?\");\n            if (idx >= 0) {\n              query = filename.substr(idx);\n              filename = filename.substr(0, idx);\n            }\n            const pathParams = {\n              chunk,\n              filename: options.fileContext ? path.relative(options.fileContext, filename) : filename,\n              query,\n              basename: basename(filename),\n              contentHash: createHash(\"md4\").update(sourceMapString).digest(\"hex\")\n            };\n            let sourceMapFile = compilation.getPath(sourceMapFilename, pathParams);\n            const sourceMapUrl = options.publicPath ? options.publicPath + sourceMapFile.replace(/\\\\/g, \"/\") : path.relative(path.dirname(file), sourceMapFile).replace(/\\\\/g, \"/\");\n            /**\n             * Add source map url to compilation asset, if {@link currentSourceMappingURLComment} presented\n             */\n            if (currentSourceMappingURLComment !== false) {\n              const asset = new ConcatSource(new RawSource(source), compilation.getPath(currentSourceMappingURLComment, Object.assign({\n                url: sourceMapUrl\n              }, pathParams)));\n              assets[file] = asset;\n              compilation.updateAsset(file, asset);\n            }\n            /**\n             * Add source map file to compilation assets and chunk files\n             */\n            const asset = new RawSource(sourceMapString);\n            assets[sourceMapFile] = asset;\n            compilation.emitAsset(sourceMapFile, asset, {\n              development: true\n            });\n            chunk.files.push(sourceMapFile);\n          } else {\n            if (currentSourceMappingURLComment === false) {\n              throw new Error(\"SourceMapDevToolPlugin: append can't be false when no filename is provided\");\n            }\n            /**\n             * Add source map as data url to asset\n             */\n            const asset = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\\[map\\]/g, () => sourceMapString).replace(/\\[url\\]/g, () => `data:application/json;charset=utf-8;base64,${Buffer.from(sourceMapString, \"utf-8\").toString(\"base64\")}`));\n            assets[file] = asset;\n            compilation.updateAsset(file, asset);\n          }\n        });\n        reportProgress(1.0);\n      });\n    });\n  }\n}\nmodule.exports = SourceMapDevToolPlugin;","map":{"version":3,"names":["path","require","ConcatSource","RawSource","ModuleFilenameHelpers","SourceMapDevToolModuleOptionsPlugin","createHash","absolutify","validateOptions","schema","basename","name","includes","substr","lastIndexOf","assetsCache","WeakMap","getTaskForFile","file","asset","chunk","options","compilation","source","sourceMap","sourceAndMap","map","context","modules","sources","startsWith","slice","module","findModule","SourceMapDevToolPlugin","constructor","arguments","length","Error","sourceMapFilename","filename","sourceMappingURLComment","append","moduleFilenameTemplate","fallbackModuleFilenameTemplate","namespace","apply","compiler","requestShortener","test","matchObject","bind","undefined","hooks","tap","afterOptimizeChunkAssets","chunks","moduleToSourceNameMapping","Map","reportProgress","files","push","tasks","forEach","idx","getAsset","cache","get","cachedFile","assets","updateAsset","emitAsset","development","task","set","createFilename","usedNamesSet","Set","values","conflictDetectionSet","allModules","Array","from","keys","sort","a","b","ai","identifier","bi","sourceName","hasName","has","add","index","Object","create","moduleFilenames","m","noSources","sourcesContent","sourceRoot","currentSourceMappingURLComment","replace","sourceMapString","JSON","stringify","query","indexOf","pathParams","fileContext","relative","contentHash","update","digest","sourceMapFile","getPath","sourceMapUrl","publicPath","dirname","assign","url","Buffer","toString","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/SourceMapDevToolPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst path = require(\"path\");\nconst { ConcatSource, RawSource } = require(\"webpack-sources\");\nconst ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\nconst SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\nconst createHash = require(\"./util/createHash\");\nconst { absolutify } = require(\"./util/identifier\");\n\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../schemas/plugins/SourceMapDevToolPlugin.json\");\n\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"source-map\").RawSourceMap} SourceMap */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Compilation\")} SourceMapDefinition */\n\n/**\n * @typedef {object} SourceMapTask\n * @property {Source} asset\n * @property {Array<string | Module>} [modules]\n * @property {string} source\n * @property {string} file\n * @property {SourceMap} sourceMap\n * @property {Chunk} chunk\n */\n\n/**\n * @param {string} name file path\n * @returns {string} file name\n */\nconst basename = name => {\n\tif (!name.includes(\"/\")) return name;\n\treturn name.substr(name.lastIndexOf(\"/\") + 1);\n};\n\n/**\n * @type {WeakMap<Source, {file: string, assets: {[k: string]: ConcatSource | RawSource}}>}\n */\nconst assetsCache = new WeakMap();\n\n/**\n * Creating {@link SourceMapTask} for given file\n * @param {string} file current compiled file\n * @param {Source} asset the asset\n * @param {Chunk} chunk related chunk\n * @param {SourceMapDevToolPluginOptions} options source map options\n * @param {Compilation} compilation compilation instance\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\n */\nconst getTaskForFile = (file, asset, chunk, options, compilation) => {\n\tlet source, sourceMap;\n\t/**\n\t * Check if asset can build source map\n\t */\n\tif (asset.sourceAndMap) {\n\t\tconst sourceAndMap = asset.sourceAndMap(options);\n\t\tsourceMap = sourceAndMap.map;\n\t\tsource = sourceAndMap.source;\n\t} else {\n\t\tsourceMap = asset.map(options);\n\t\tsource = asset.source();\n\t}\n\tif (!sourceMap || typeof source !== \"string\") return;\n\tconst context = compilation.options.context;\n\tconst modules = sourceMap.sources.map(source => {\n\t\tif (source.startsWith(\"webpack://\")) {\n\t\t\tsource = absolutify(context, source.slice(10));\n\t\t}\n\t\tconst module = compilation.findModule(source);\n\t\treturn module || source;\n\t});\n\n\treturn {\n\t\tchunk,\n\t\tfile,\n\t\tasset,\n\t\tsource,\n\t\tsourceMap,\n\t\tmodules\n\t};\n};\n\nclass SourceMapDevToolPlugin {\n\t/**\n\t * @param {SourceMapDevToolPluginOptions} [options] options object\n\t * @throws {Error} throws error, if got more than 1 arguments\n\t */\n\tconstructor(options) {\n\t\tif (arguments.length > 1) {\n\t\t\tthrow new Error(\n\t\t\t\t\"SourceMapDevToolPlugin only takes one argument (pass an options object)\"\n\t\t\t);\n\t\t}\n\n\t\tif (!options) options = {};\n\n\t\tvalidateOptions(schema, options, \"SourceMap DevTool Plugin\");\n\n\t\t/** @type {string | false} */\n\t\tthis.sourceMapFilename = options.filename;\n\t\t/** @type {string | false} */\n\t\tthis.sourceMappingURLComment =\n\t\t\toptions.append === false\n\t\t\t\t? false\n\t\t\t\t: options.append || \"\\n//# sourceMappingURL=[url]\";\n\t\t/** @type {string | Function} */\n\t\tthis.moduleFilenameTemplate =\n\t\t\toptions.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n\t\t/** @type {string | Function} */\n\t\tthis.fallbackModuleFilenameTemplate =\n\t\t\toptions.fallbackModuleFilenameTemplate ||\n\t\t\t\"webpack://[namespace]/[resourcePath]?[hash]\";\n\t\t/** @type {string} */\n\t\tthis.namespace = options.namespace || \"\";\n\t\t/** @type {SourceMapDevToolPluginOptions} */\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply compiler\n\t * @param {Compiler} compiler compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst sourceMapFilename = this.sourceMapFilename;\n\t\tconst sourceMappingURLComment = this.sourceMappingURLComment;\n\t\tconst moduleFilenameTemplate = this.moduleFilenameTemplate;\n\t\tconst namespace = this.namespace;\n\t\tconst fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n\t\tconst requestShortener = compiler.requestShortener;\n\t\tconst options = this.options;\n\t\toptions.test = options.test || /\\.(m?js|css)($|\\?)/i;\n\n\t\tconst matchObject = ModuleFilenameHelpers.matchObject.bind(\n\t\t\tundefined,\n\t\t\toptions\n\t\t);\n\n\t\tcompiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", compilation => {\n\t\t\tnew SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n\n\t\t\tcompilation.hooks.afterOptimizeChunkAssets.tap(\n\t\t\t\t/** @type {TODO} */\n\t\t\t\t({ name: \"SourceMapDevToolPlugin\", context: true }),\n\t\t\t\t/**\n\t\t\t\t * @param {object} context hook context\n\t\t\t\t * @param {Array<Chunk>} chunks resulted chunks\n\t\t\t\t * @throws {Error} throws error, if `sourceMapFilename === false && sourceMappingURLComment === false`\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(context, chunks) => {\n\t\t\t\t\t/** @type {Map<string | Module, string>} */\n\t\t\t\t\tconst moduleToSourceNameMapping = new Map();\n\t\t\t\t\t/**\n\t\t\t\t\t * @type {Function}\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst reportProgress =\n\t\t\t\t\t\tcontext && context.reportProgress\n\t\t\t\t\t\t\t? context.reportProgress\n\t\t\t\t\t\t\t: () => {};\n\n\t\t\t\t\tconst files = [];\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tfor (const file of chunk.files) {\n\t\t\t\t\t\t\tif (matchObject(file)) {\n\t\t\t\t\t\t\t\tfiles.push({\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\tchunk\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treportProgress(0.0);\n\t\t\t\t\tconst tasks = [];\n\t\t\t\t\tfiles.forEach(({ file, chunk }, idx) => {\n\t\t\t\t\t\tconst asset = compilation.getAsset(file).source;\n\t\t\t\t\t\tconst cache = assetsCache.get(asset);\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * If presented in cache, reassigns assets. Cache assets already have source maps.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (cache && cache.file === file) {\n\t\t\t\t\t\t\tfor (const cachedFile in cache.assets) {\n\t\t\t\t\t\t\t\tif (cachedFile === file) {\n\t\t\t\t\t\t\t\t\tcompilation.updateAsset(cachedFile, cache.assets[cachedFile]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcompilation.emitAsset(cachedFile, cache.assets[cachedFile], {\n\t\t\t\t\t\t\t\t\t\tdevelopment: true\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * Add file to chunk, if not presented there\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tif (cachedFile !== file) chunk.files.push(cachedFile);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t(0.5 * idx) / files.length,\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\"generate SourceMap\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\t/** @type {SourceMapTask | undefined} */\n\t\t\t\t\t\tconst task = getTaskForFile(\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tasset,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\tcompilation\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (task) {\n\t\t\t\t\t\t\tconst modules = task.modules;\n\n\t\t\t\t\t\t\tfor (let idx = 0; idx < modules.length; idx++) {\n\t\t\t\t\t\t\t\tconst module = modules[idx];\n\t\t\t\t\t\t\t\tif (!moduleToSourceNameMapping.get(module)) {\n\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(\n\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\tModuleFilenameHelpers.createFilename(\n\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tmoduleFilenameTemplate: moduleFilenameTemplate,\n\t\t\t\t\t\t\t\t\t\t\t\tnamespace: namespace\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttasks.push(task);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treportProgress(0.5, \"resolve sources\");\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\tconst usedNamesSet = new Set(moduleToSourceNameMapping.values());\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\tconst conflictDetectionSet = new Set();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * all modules in defined order (longest identifier first)\n\t\t\t\t\t * @type {Array<string | Module>}\n\t\t\t\t\t */\n\t\t\t\t\tconst allModules = Array.from(moduleToSourceNameMapping.keys()).sort(\n\t\t\t\t\t\t(a, b) => {\n\t\t\t\t\t\t\tconst ai = typeof a === \"string\" ? a : a.identifier();\n\t\t\t\t\t\t\tconst bi = typeof b === \"string\" ? b : b.identifier();\n\t\t\t\t\t\t\treturn ai.length - bi.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\t// find modules with conflicting source names\n\t\t\t\t\tfor (let idx = 0; idx < allModules.length; idx++) {\n\t\t\t\t\t\tconst module = allModules[idx];\n\t\t\t\t\t\tlet sourceName = moduleToSourceNameMapping.get(module);\n\t\t\t\t\t\tlet hasName = conflictDetectionSet.has(sourceName);\n\t\t\t\t\t\tif (!hasName) {\n\t\t\t\t\t\t\tconflictDetectionSet.add(sourceName);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// try the fallback name first\n\t\t\t\t\t\tsourceName = ModuleFilenameHelpers.createFilename(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmoduleFilenameTemplate: fallbackModuleFilenameTemplate,\n\t\t\t\t\t\t\t\tnamespace: namespace\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t);\n\t\t\t\t\t\thasName = usedNamesSet.has(sourceName);\n\t\t\t\t\t\tif (!hasName) {\n\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(module, sourceName);\n\t\t\t\t\t\t\tusedNamesSet.add(sourceName);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// elsewise just append stars until we have a valid name\n\t\t\t\t\t\twhile (hasName) {\n\t\t\t\t\t\t\tsourceName += \"*\";\n\t\t\t\t\t\t\thasName = usedNamesSet.has(sourceName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmoduleToSourceNameMapping.set(module, sourceName);\n\t\t\t\t\t\tusedNamesSet.add(sourceName);\n\t\t\t\t\t}\n\t\t\t\t\ttasks.forEach((task, index) => {\n\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t0.5 + (0.5 * index) / tasks.length,\n\t\t\t\t\t\t\ttask.file,\n\t\t\t\t\t\t\t\"attach SourceMap\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst assets = Object.create(null);\n\t\t\t\t\t\tconst chunk = task.chunk;\n\t\t\t\t\t\tconst file = task.file;\n\t\t\t\t\t\tconst asset = task.asset;\n\t\t\t\t\t\tconst sourceMap = task.sourceMap;\n\t\t\t\t\t\tconst source = task.source;\n\t\t\t\t\t\tconst modules = task.modules;\n\t\t\t\t\t\tconst moduleFilenames = modules.map(m =>\n\t\t\t\t\t\t\tmoduleToSourceNameMapping.get(m)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tsourceMap.sources = moduleFilenames;\n\t\t\t\t\t\tif (options.noSources) {\n\t\t\t\t\t\t\tsourceMap.sourcesContent = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsourceMap.sourceRoot = options.sourceRoot || \"\";\n\t\t\t\t\t\tsourceMap.file = file;\n\t\t\t\t\t\tassetsCache.set(asset, { file, assets });\n\t\t\t\t\t\t/** @type {string | false} */\n\t\t\t\t\t\tlet currentSourceMappingURLComment = sourceMappingURLComment;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcurrentSourceMappingURLComment !== false &&\n\t\t\t\t\t\t\t/\\.css($|\\?)/i.test(file)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcurrentSourceMappingURLComment = currentSourceMappingURLComment.replace(\n\t\t\t\t\t\t\t\t/^\\n\\/\\/(.*)$/,\n\t\t\t\t\t\t\t\t\"\\n/*$1*/\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst sourceMapString = JSON.stringify(sourceMap);\n\t\t\t\t\t\tif (sourceMapFilename) {\n\t\t\t\t\t\t\tlet filename = file;\n\t\t\t\t\t\t\tlet query = \"\";\n\t\t\t\t\t\t\tconst idx = filename.indexOf(\"?\");\n\t\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\t\tquery = filename.substr(idx);\n\t\t\t\t\t\t\t\tfilename = filename.substr(0, idx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst pathParams = {\n\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\tfilename: options.fileContext\n\t\t\t\t\t\t\t\t\t? path.relative(options.fileContext, filename)\n\t\t\t\t\t\t\t\t\t: filename,\n\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\tbasename: basename(filename),\n\t\t\t\t\t\t\t\tcontentHash: createHash(\"md4\")\n\t\t\t\t\t\t\t\t\t.update(sourceMapString)\n\t\t\t\t\t\t\t\t\t.digest(\"hex\")\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tlet sourceMapFile = compilation.getPath(\n\t\t\t\t\t\t\t\tsourceMapFilename,\n\t\t\t\t\t\t\t\tpathParams\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst sourceMapUrl = options.publicPath\n\t\t\t\t\t\t\t\t? options.publicPath + sourceMapFile.replace(/\\\\/g, \"/\")\n\t\t\t\t\t\t\t\t: path\n\t\t\t\t\t\t\t\t\t\t.relative(path.dirname(file), sourceMapFile)\n\t\t\t\t\t\t\t\t\t\t.replace(/\\\\/g, \"/\");\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * Add source map url to compilation asset, if {@link currentSourceMappingURLComment} presented\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (currentSourceMappingURLComment !== false) {\n\t\t\t\t\t\t\t\tconst asset = new ConcatSource(\n\t\t\t\t\t\t\t\t\tnew RawSource(source),\n\t\t\t\t\t\t\t\t\tcompilation.getPath(\n\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment,\n\t\t\t\t\t\t\t\t\t\tObject.assign({ url: sourceMapUrl }, pathParams)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tassets[file] = asset;\n\t\t\t\t\t\t\t\tcompilation.updateAsset(file, asset);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * Add source map file to compilation assets and chunk files\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst asset = new RawSource(sourceMapString);\n\t\t\t\t\t\t\tassets[sourceMapFile] = asset;\n\t\t\t\t\t\t\tcompilation.emitAsset(sourceMapFile, asset, {\n\t\t\t\t\t\t\t\tdevelopment: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tchunk.files.push(sourceMapFile);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (currentSourceMappingURLComment === false) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\"SourceMapDevToolPlugin: append can't be false when no filename is provided\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * Add source map as data url to asset\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst asset = new ConcatSource(\n\t\t\t\t\t\t\t\tnew RawSource(source),\n\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment\n\t\t\t\t\t\t\t\t\t.replace(/\\[map\\]/g, () => sourceMapString)\n\t\t\t\t\t\t\t\t\t.replace(\n\t\t\t\t\t\t\t\t\t\t/\\[url\\]/g,\n\t\t\t\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\t\t\t\t`data:application/json;charset=utf-8;base64,${Buffer.from(\n\t\t\t\t\t\t\t\t\t\t\t\tsourceMapString,\n\t\t\t\t\t\t\t\t\t\t\t\t\"utf-8\"\n\t\t\t\t\t\t\t\t\t\t\t).toString(\"base64\")}`\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tassets[file] = asset;\n\t\t\t\t\t\t\tcompilation.updateAsset(file, asset);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treportProgress(1.0);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = SourceMapDevToolPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}