{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Template = require(\"../Template\");\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../MainTemplate\")} MainTemplate */\n\n// Get all wasm modules\nconst getAllWasmModules = chunk => {\n  const wasmModules = chunk.getAllAsyncChunks();\n  const array = [];\n  for (const chunk of wasmModules) {\n    for (const m of chunk.modulesIterable) {\n      if (m.type.startsWith(\"webassembly\")) {\n        array.push(m);\n      }\n    }\n  }\n  return array;\n};\n\n/**\n * generates the import object function for a module\n * @param {Module} module the module\n * @param {boolean} mangle mangle imports\n * @returns {string} source code\n */\nconst generateImportObject = (module, mangle) => {\n  const waitForInstances = new Map();\n  const properties = [];\n  const usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(module, mangle);\n  for (const usedDep of usedWasmDependencies) {\n    const dep = usedDep.dependency;\n    const importedModule = dep.module;\n    const exportName = dep.name;\n    const usedName = importedModule && importedModule.isUsed(exportName);\n    const description = dep.description;\n    const direct = dep.onlyDirectImport;\n    const module = usedDep.module;\n    const name = usedDep.name;\n    if (direct) {\n      const instanceVar = `m${waitForInstances.size}`;\n      waitForInstances.set(instanceVar, importedModule.id);\n      properties.push({\n        module,\n        name,\n        value: `${instanceVar}[${JSON.stringify(usedName)}]`\n      });\n    } else {\n      const params = description.signature.params.map((param, k) => \"p\" + k + param.valtype);\n      const mod = `installedModules[${JSON.stringify(importedModule.id)}]`;\n      const func = `${mod}.exports[${JSON.stringify(usedName)}]`;\n      properties.push({\n        module,\n        name,\n        value: Template.asString([(importedModule.type.startsWith(\"webassembly\") ? `${mod} ? ${func} : ` : \"\") + `function(${params}) {`, Template.indent([`return ${func}(${params});`]), \"}\"])\n      });\n    }\n  }\n  let importObject;\n  if (mangle) {\n    importObject = [\"return {\", Template.indent([properties.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(\",\\n\")]), \"};\"];\n  } else {\n    const propertiesByModule = new Map();\n    for (const p of properties) {\n      let list = propertiesByModule.get(p.module);\n      if (list === undefined) {\n        propertiesByModule.set(p.module, list = []);\n      }\n      list.push(p);\n    }\n    importObject = [\"return {\", Template.indent([Array.from(propertiesByModule, ([module, list]) => {\n      return Template.asString([`${JSON.stringify(module)}: {`, Template.indent([list.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(\",\\n\")]), \"}\"]);\n    }).join(\",\\n\")]), \"};\"];\n  }\n  if (waitForInstances.size === 1) {\n    const moduleId = Array.from(waitForInstances.values())[0];\n    const promise = `installedWasmModules[${JSON.stringify(moduleId)}]`;\n    const variable = Array.from(waitForInstances.keys())[0];\n    return Template.asString([`${JSON.stringify(module.id)}: function() {`, Template.indent([`return promiseResolve().then(function() { return ${promise}; }).then(function(${variable}) {`, Template.indent(importObject), \"});\"]), \"},\"]);\n  } else if (waitForInstances.size > 0) {\n    const promises = Array.from(waitForInstances.values(), id => `installedWasmModules[${JSON.stringify(id)}]`).join(\", \");\n    const variables = Array.from(waitForInstances.keys(), (name, i) => `${name} = array[${i}]`).join(\", \");\n    return Template.asString([`${JSON.stringify(module.id)}: function() {`, Template.indent([`return promiseResolve().then(function() { return Promise.all([${promises}]); }).then(function(array) {`, Template.indent([`var ${variables};`, ...importObject]), \"});\"]), \"},\"]);\n  } else {\n    return Template.asString([`${JSON.stringify(module.id)}: function() {`, Template.indent(importObject), \"},\"]);\n  }\n};\nclass WasmMainTemplatePlugin {\n  constructor({\n    generateLoadBinaryCode,\n    supportsStreaming,\n    mangleImports\n  }) {\n    this.generateLoadBinaryCode = generateLoadBinaryCode;\n    this.supportsStreaming = supportsStreaming;\n    this.mangleImports = mangleImports;\n  }\n\n  /**\n   * @param {MainTemplate} mainTemplate main template\n   * @returns {void}\n   */\n  apply(mainTemplate) {\n    mainTemplate.hooks.localVars.tap(\"WasmMainTemplatePlugin\", (source, chunk) => {\n      const wasmModules = getAllWasmModules(chunk);\n      if (wasmModules.length === 0) return source;\n      const importObjects = wasmModules.map(module => {\n        return generateImportObject(module, this.mangleImports);\n      });\n      return Template.asString([source, \"\", \"// object to store loaded and loading wasm modules\", \"var installedWasmModules = {};\", \"\",\n      // This function is used to delay reading the installed wasm module promises\n      // by a microtask. Sorting them doesn't help because there are egdecases where\n      // sorting is not possible (modules splitted into different chunks).\n      // So we not even trying and solve this by a microtask delay.\n      \"function promiseResolve() { return Promise.resolve(); }\", \"\", \"var wasmImportObjects = {\", Template.indent(importObjects), \"};\"]);\n    });\n    mainTemplate.hooks.requireEnsure.tap(\"WasmMainTemplatePlugin\", (source, chunk, hash) => {\n      const webassemblyModuleFilename = mainTemplate.outputOptions.webassemblyModuleFilename;\n      const chunkModuleMaps = chunk.getChunkModuleMaps(m => m.type.startsWith(\"webassembly\"));\n      if (Object.keys(chunkModuleMaps.id).length === 0) return source;\n      const wasmModuleSrcPath = mainTemplate.getAssetPath(JSON.stringify(webassemblyModuleFilename), {\n        hash: `\" + ${mainTemplate.renderCurrentHashCode(hash)} + \"`,\n        hashWithLength: length => `\" + ${mainTemplate.renderCurrentHashCode(hash, length)} + \"`,\n        module: {\n          id: '\" + wasmModuleId + \"',\n          hash: `\" + ${JSON.stringify(chunkModuleMaps.hash)}[wasmModuleId] + \"`,\n          hashWithLength(length) {\n            const shortChunkHashMap = Object.create(null);\n            for (const wasmModuleId of Object.keys(chunkModuleMaps.hash)) {\n              if (typeof chunkModuleMaps.hash[wasmModuleId] === \"string\") {\n                shortChunkHashMap[wasmModuleId] = chunkModuleMaps.hash[wasmModuleId].substr(0, length);\n              }\n            }\n            return `\" + ${JSON.stringify(shortChunkHashMap)}[wasmModuleId] + \"`;\n          }\n        }\n      });\n      const createImportObject = content => this.mangleImports ? `{ ${JSON.stringify(WebAssemblyUtils.MANGLED_MODULE)}: ${content} }` : content;\n      return Template.asString([source, \"\", \"// Fetch + compile chunk loading for webassembly\", \"\", `var wasmModules = ${JSON.stringify(chunkModuleMaps.id)}[chunkId] || [];`, \"\", \"wasmModules.forEach(function(wasmModuleId) {\", Template.indent([\"var installedWasmModuleData = installedWasmModules[wasmModuleId];\", \"\", '// a Promise means \"currently loading\" or \"already loaded\".', \"if(installedWasmModuleData)\", Template.indent([\"promises.push(installedWasmModuleData);\"]), \"else {\", Template.indent([`var importObject = wasmImportObjects[wasmModuleId]();`, `var req = ${this.generateLoadBinaryCode(wasmModuleSrcPath)};`, \"var promise;\", this.supportsStreaming ? Template.asString([\"if(importObject instanceof Promise && typeof WebAssembly.compileStreaming === 'function') {\", Template.indent([\"promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {\", Template.indent([`return WebAssembly.instantiate(items[0], ${createImportObject(\"items[1]\")});`]), \"});\"]), \"} else if(typeof WebAssembly.instantiateStreaming === 'function') {\", Template.indent([`promise = WebAssembly.instantiateStreaming(req, ${createImportObject(\"importObject\")});`])]) : Template.asString([\"if(importObject instanceof Promise) {\", Template.indent([\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\", \"promise = Promise.all([\", Template.indent([\"bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); }),\", \"importObject\"]), \"]).then(function(items) {\", Template.indent([`return WebAssembly.instantiate(items[0], ${createImportObject(\"items[1]\")});`]), \"});\"])]), \"} else {\", Template.indent([\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\", \"promise = bytesPromise.then(function(bytes) {\", Template.indent([`return WebAssembly.instantiate(bytes, ${createImportObject(\"importObject\")});`]), \"});\"]), \"}\", \"promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {\", Template.indent([`return ${mainTemplate.requireFn}.w[wasmModuleId] = (res.instance || res).exports;`]), \"}));\"]), \"}\"]), \"});\"]);\n    });\n    mainTemplate.hooks.requireExtensions.tap(\"WasmMainTemplatePlugin\", (source, chunk) => {\n      if (!chunk.hasModuleInGraph(m => m.type.startsWith(\"webassembly\"))) {\n        return source;\n      }\n      return Template.asString([source, \"\", \"// object with all WebAssembly.instance exports\", `${mainTemplate.requireFn}.w = {};`]);\n    });\n    mainTemplate.hooks.hash.tap(\"WasmMainTemplatePlugin\", hash => {\n      hash.update(\"WasmMainTemplatePlugin\");\n      hash.update(\"2\");\n    });\n  }\n}\nmodule.exports = WasmMainTemplatePlugin;","map":{"version":3,"names":["Template","require","WebAssemblyUtils","getAllWasmModules","chunk","wasmModules","getAllAsyncChunks","array","m","modulesIterable","type","startsWith","push","generateImportObject","module","mangle","waitForInstances","Map","properties","usedWasmDependencies","getUsedDependencies","usedDep","dep","dependency","importedModule","exportName","name","usedName","isUsed","description","direct","onlyDirectImport","instanceVar","size","set","id","value","JSON","stringify","params","signature","map","param","k","valtype","mod","func","asString","indent","importObject","p","join","propertiesByModule","list","get","undefined","Array","from","moduleId","values","promise","variable","keys","promises","variables","i","WasmMainTemplatePlugin","constructor","generateLoadBinaryCode","supportsStreaming","mangleImports","apply","mainTemplate","hooks","localVars","tap","source","length","importObjects","requireEnsure","hash","webassemblyModuleFilename","outputOptions","chunkModuleMaps","getChunkModuleMaps","Object","wasmModuleSrcPath","getAssetPath","renderCurrentHashCode","hashWithLength","shortChunkHashMap","create","wasmModuleId","substr","createImportObject","content","MANGLED_MODULE","requireFn","requireExtensions","hasModuleInGraph","update","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/wasm/WasmMainTemplatePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Template = require(\"../Template\");\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../MainTemplate\")} MainTemplate */\n\n// Get all wasm modules\nconst getAllWasmModules = chunk => {\n\tconst wasmModules = chunk.getAllAsyncChunks();\n\tconst array = [];\n\tfor (const chunk of wasmModules) {\n\t\tfor (const m of chunk.modulesIterable) {\n\t\t\tif (m.type.startsWith(\"webassembly\")) {\n\t\t\t\tarray.push(m);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn array;\n};\n\n/**\n * generates the import object function for a module\n * @param {Module} module the module\n * @param {boolean} mangle mangle imports\n * @returns {string} source code\n */\nconst generateImportObject = (module, mangle) => {\n\tconst waitForInstances = new Map();\n\tconst properties = [];\n\tconst usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(\n\t\tmodule,\n\t\tmangle\n\t);\n\tfor (const usedDep of usedWasmDependencies) {\n\t\tconst dep = usedDep.dependency;\n\t\tconst importedModule = dep.module;\n\t\tconst exportName = dep.name;\n\t\tconst usedName = importedModule && importedModule.isUsed(exportName);\n\t\tconst description = dep.description;\n\t\tconst direct = dep.onlyDirectImport;\n\n\t\tconst module = usedDep.module;\n\t\tconst name = usedDep.name;\n\n\t\tif (direct) {\n\t\t\tconst instanceVar = `m${waitForInstances.size}`;\n\t\t\twaitForInstances.set(instanceVar, importedModule.id);\n\t\t\tproperties.push({\n\t\t\t\tmodule,\n\t\t\t\tname,\n\t\t\t\tvalue: `${instanceVar}[${JSON.stringify(usedName)}]`\n\t\t\t});\n\t\t} else {\n\t\t\tconst params = description.signature.params.map(\n\t\t\t\t(param, k) => \"p\" + k + param.valtype\n\t\t\t);\n\n\t\t\tconst mod = `installedModules[${JSON.stringify(importedModule.id)}]`;\n\t\t\tconst func = `${mod}.exports[${JSON.stringify(usedName)}]`;\n\n\t\t\tproperties.push({\n\t\t\t\tmodule,\n\t\t\t\tname,\n\t\t\t\tvalue: Template.asString([\n\t\t\t\t\t(importedModule.type.startsWith(\"webassembly\")\n\t\t\t\t\t\t? `${mod} ? ${func} : `\n\t\t\t\t\t\t: \"\") + `function(${params}) {`,\n\t\t\t\t\tTemplate.indent([`return ${func}(${params});`]),\n\t\t\t\t\t\"}\"\n\t\t\t\t])\n\t\t\t});\n\t\t}\n\t}\n\n\tlet importObject;\n\tif (mangle) {\n\t\timportObject = [\n\t\t\t\"return {\",\n\t\t\tTemplate.indent([\n\t\t\t\tproperties.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(\",\\n\")\n\t\t\t]),\n\t\t\t\"};\"\n\t\t];\n\t} else {\n\t\tconst propertiesByModule = new Map();\n\t\tfor (const p of properties) {\n\t\t\tlet list = propertiesByModule.get(p.module);\n\t\t\tif (list === undefined) {\n\t\t\t\tpropertiesByModule.set(p.module, (list = []));\n\t\t\t}\n\t\t\tlist.push(p);\n\t\t}\n\t\timportObject = [\n\t\t\t\"return {\",\n\t\t\tTemplate.indent([\n\t\t\t\tArray.from(propertiesByModule, ([module, list]) => {\n\t\t\t\t\treturn Template.asString([\n\t\t\t\t\t\t`${JSON.stringify(module)}: {`,\n\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\tlist.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(\",\\n\")\n\t\t\t\t\t\t]),\n\t\t\t\t\t\t\"}\"\n\t\t\t\t\t]);\n\t\t\t\t}).join(\",\\n\")\n\t\t\t]),\n\t\t\t\"};\"\n\t\t];\n\t}\n\n\tif (waitForInstances.size === 1) {\n\t\tconst moduleId = Array.from(waitForInstances.values())[0];\n\t\tconst promise = `installedWasmModules[${JSON.stringify(moduleId)}]`;\n\t\tconst variable = Array.from(waitForInstances.keys())[0];\n\t\treturn Template.asString([\n\t\t\t`${JSON.stringify(module.id)}: function() {`,\n\t\t\tTemplate.indent([\n\t\t\t\t`return promiseResolve().then(function() { return ${promise}; }).then(function(${variable}) {`,\n\t\t\t\tTemplate.indent(importObject),\n\t\t\t\t\"});\"\n\t\t\t]),\n\t\t\t\"},\"\n\t\t]);\n\t} else if (waitForInstances.size > 0) {\n\t\tconst promises = Array.from(\n\t\t\twaitForInstances.values(),\n\t\t\tid => `installedWasmModules[${JSON.stringify(id)}]`\n\t\t).join(\", \");\n\t\tconst variables = Array.from(\n\t\t\twaitForInstances.keys(),\n\t\t\t(name, i) => `${name} = array[${i}]`\n\t\t).join(\", \");\n\t\treturn Template.asString([\n\t\t\t`${JSON.stringify(module.id)}: function() {`,\n\t\t\tTemplate.indent([\n\t\t\t\t`return promiseResolve().then(function() { return Promise.all([${promises}]); }).then(function(array) {`,\n\t\t\t\tTemplate.indent([`var ${variables};`, ...importObject]),\n\t\t\t\t\"});\"\n\t\t\t]),\n\t\t\t\"},\"\n\t\t]);\n\t} else {\n\t\treturn Template.asString([\n\t\t\t`${JSON.stringify(module.id)}: function() {`,\n\t\t\tTemplate.indent(importObject),\n\t\t\t\"},\"\n\t\t]);\n\t}\n};\n\nclass WasmMainTemplatePlugin {\n\tconstructor({ generateLoadBinaryCode, supportsStreaming, mangleImports }) {\n\t\tthis.generateLoadBinaryCode = generateLoadBinaryCode;\n\t\tthis.supportsStreaming = supportsStreaming;\n\t\tthis.mangleImports = mangleImports;\n\t}\n\n\t/**\n\t * @param {MainTemplate} mainTemplate main template\n\t * @returns {void}\n\t */\n\tapply(mainTemplate) {\n\t\tmainTemplate.hooks.localVars.tap(\n\t\t\t\"WasmMainTemplatePlugin\",\n\t\t\t(source, chunk) => {\n\t\t\t\tconst wasmModules = getAllWasmModules(chunk);\n\t\t\t\tif (wasmModules.length === 0) return source;\n\t\t\t\tconst importObjects = wasmModules.map(module => {\n\t\t\t\t\treturn generateImportObject(module, this.mangleImports);\n\t\t\t\t});\n\t\t\t\treturn Template.asString([\n\t\t\t\t\tsource,\n\t\t\t\t\t\"\",\n\t\t\t\t\t\"// object to store loaded and loading wasm modules\",\n\t\t\t\t\t\"var installedWasmModules = {};\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t// This function is used to delay reading the installed wasm module promises\n\t\t\t\t\t// by a microtask. Sorting them doesn't help because there are egdecases where\n\t\t\t\t\t// sorting is not possible (modules splitted into different chunks).\n\t\t\t\t\t// So we not even trying and solve this by a microtask delay.\n\t\t\t\t\t\"function promiseResolve() { return Promise.resolve(); }\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t\"var wasmImportObjects = {\",\n\t\t\t\t\tTemplate.indent(importObjects),\n\t\t\t\t\t\"};\"\n\t\t\t\t]);\n\t\t\t}\n\t\t);\n\t\tmainTemplate.hooks.requireEnsure.tap(\n\t\t\t\"WasmMainTemplatePlugin\",\n\t\t\t(source, chunk, hash) => {\n\t\t\t\tconst webassemblyModuleFilename =\n\t\t\t\t\tmainTemplate.outputOptions.webassemblyModuleFilename;\n\n\t\t\t\tconst chunkModuleMaps = chunk.getChunkModuleMaps(m =>\n\t\t\t\t\tm.type.startsWith(\"webassembly\")\n\t\t\t\t);\n\t\t\t\tif (Object.keys(chunkModuleMaps.id).length === 0) return source;\n\t\t\t\tconst wasmModuleSrcPath = mainTemplate.getAssetPath(\n\t\t\t\t\tJSON.stringify(webassemblyModuleFilename),\n\t\t\t\t\t{\n\t\t\t\t\t\thash: `\" + ${mainTemplate.renderCurrentHashCode(hash)} + \"`,\n\t\t\t\t\t\thashWithLength: length =>\n\t\t\t\t\t\t\t`\" + ${mainTemplate.renderCurrentHashCode(hash, length)} + \"`,\n\t\t\t\t\t\tmodule: {\n\t\t\t\t\t\t\tid: '\" + wasmModuleId + \"',\n\t\t\t\t\t\t\thash: `\" + ${JSON.stringify(\n\t\t\t\t\t\t\t\tchunkModuleMaps.hash\n\t\t\t\t\t\t\t)}[wasmModuleId] + \"`,\n\t\t\t\t\t\t\thashWithLength(length) {\n\t\t\t\t\t\t\t\tconst shortChunkHashMap = Object.create(null);\n\t\t\t\t\t\t\t\tfor (const wasmModuleId of Object.keys(chunkModuleMaps.hash)) {\n\t\t\t\t\t\t\t\t\tif (typeof chunkModuleMaps.hash[wasmModuleId] === \"string\") {\n\t\t\t\t\t\t\t\t\t\tshortChunkHashMap[wasmModuleId] = chunkModuleMaps.hash[\n\t\t\t\t\t\t\t\t\t\t\twasmModuleId\n\t\t\t\t\t\t\t\t\t\t].substr(0, length);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn `\" + ${JSON.stringify(\n\t\t\t\t\t\t\t\t\tshortChunkHashMap\n\t\t\t\t\t\t\t\t)}[wasmModuleId] + \"`;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tconst createImportObject = content =>\n\t\t\t\t\tthis.mangleImports\n\t\t\t\t\t\t? `{ ${JSON.stringify(\n\t\t\t\t\t\t\t\tWebAssemblyUtils.MANGLED_MODULE\n\t\t\t\t\t\t  )}: ${content} }`\n\t\t\t\t\t\t: content;\n\t\t\t\treturn Template.asString([\n\t\t\t\t\tsource,\n\t\t\t\t\t\"\",\n\t\t\t\t\t\"// Fetch + compile chunk loading for webassembly\",\n\t\t\t\t\t\"\",\n\t\t\t\t\t`var wasmModules = ${JSON.stringify(\n\t\t\t\t\t\tchunkModuleMaps.id\n\t\t\t\t\t)}[chunkId] || [];`,\n\t\t\t\t\t\"\",\n\t\t\t\t\t\"wasmModules.forEach(function(wasmModuleId) {\",\n\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\"var installedWasmModuleData = installedWasmModules[wasmModuleId];\",\n\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t'// a Promise means \"currently loading\" or \"already loaded\".',\n\t\t\t\t\t\t\"if(installedWasmModuleData)\",\n\t\t\t\t\t\tTemplate.indent([\"promises.push(installedWasmModuleData);\"]),\n\t\t\t\t\t\t\"else {\",\n\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t`var importObject = wasmImportObjects[wasmModuleId]();`,\n\t\t\t\t\t\t\t`var req = ${this.generateLoadBinaryCode(wasmModuleSrcPath)};`,\n\t\t\t\t\t\t\t\"var promise;\",\n\t\t\t\t\t\t\tthis.supportsStreaming\n\t\t\t\t\t\t\t\t? Template.asString([\n\t\t\t\t\t\t\t\t\t\t\"if(importObject instanceof Promise && typeof WebAssembly.compileStreaming === 'function') {\",\n\t\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t\t\"promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {\",\n\t\t\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t\t\t`return WebAssembly.instantiate(items[0], ${createImportObject(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"items[1]\"\n\t\t\t\t\t\t\t\t\t\t\t\t)});`\n\t\t\t\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\t\t\t\t\"});\"\n\t\t\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\t\t\t\"} else if(typeof WebAssembly.instantiateStreaming === 'function') {\",\n\t\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t\t`promise = WebAssembly.instantiateStreaming(req, ${createImportObject(\n\t\t\t\t\t\t\t\t\t\t\t\t\"importObject\"\n\t\t\t\t\t\t\t\t\t\t\t)});`\n\t\t\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t\t  ])\n\t\t\t\t\t\t\t\t: Template.asString([\n\t\t\t\t\t\t\t\t\t\t\"if(importObject instanceof Promise) {\",\n\t\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t\t\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\",\n\t\t\t\t\t\t\t\t\t\t\t\"promise = Promise.all([\",\n\t\t\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t\t\t\"bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); }),\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"importObject\"\n\t\t\t\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\t\t\t\t\"]).then(function(items) {\",\n\t\t\t\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t\t\t\t`return WebAssembly.instantiate(items[0], ${createImportObject(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"items[1]\"\n\t\t\t\t\t\t\t\t\t\t\t\t)});`\n\t\t\t\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\t\t\t\t\"});\"\n\t\t\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t\t  ]),\n\t\t\t\t\t\t\t\"} else {\",\n\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\",\n\t\t\t\t\t\t\t\t\"promise = bytesPromise.then(function(bytes) {\",\n\t\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t\t`return WebAssembly.instantiate(bytes, ${createImportObject(\n\t\t\t\t\t\t\t\t\t\t\"importObject\"\n\t\t\t\t\t\t\t\t\t)});`\n\t\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\t\"});\"\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\"}\",\n\t\t\t\t\t\t\t\"promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {\",\n\t\t\t\t\t\t\tTemplate.indent([\n\t\t\t\t\t\t\t\t`return ${mainTemplate.requireFn}.w[wasmModuleId] = (res.instance || res).exports;`\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t\"}));\"\n\t\t\t\t\t\t]),\n\t\t\t\t\t\t\"}\"\n\t\t\t\t\t]),\n\t\t\t\t\t\"});\"\n\t\t\t\t]);\n\t\t\t}\n\t\t);\n\t\tmainTemplate.hooks.requireExtensions.tap(\n\t\t\t\"WasmMainTemplatePlugin\",\n\t\t\t(source, chunk) => {\n\t\t\t\tif (!chunk.hasModuleInGraph(m => m.type.startsWith(\"webassembly\"))) {\n\t\t\t\t\treturn source;\n\t\t\t\t}\n\t\t\t\treturn Template.asString([\n\t\t\t\t\tsource,\n\t\t\t\t\t\"\",\n\t\t\t\t\t\"// object with all WebAssembly.instance exports\",\n\t\t\t\t\t`${mainTemplate.requireFn}.w = {};`\n\t\t\t\t]);\n\t\t\t}\n\t\t);\n\t\tmainTemplate.hooks.hash.tap(\"WasmMainTemplatePlugin\", hash => {\n\t\t\thash.update(\"WasmMainTemplatePlugin\");\n\t\t\thash.update(\"2\");\n\t\t});\n\t}\n}\n\nmodule.exports = WasmMainTemplatePlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}