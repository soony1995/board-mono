{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst identifierUtils = require(\"./util/identifier\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} RecordsChunks\n * @property {Record<string, number>=} byName\n * @property {Record<string, number>=} bySource\n * @property {number[]=} usedIds\n */\n\n/**\n * @typedef {Object} RecordsModules\n * @property {Record<string, number>=} byIdentifier\n * @property {Record<string, number>=} bySource\n * @property {Record<number, number>=} usedIds\n */\n\n/**\n * @typedef {Object} Records\n * @property {RecordsChunks=} chunks\n * @property {RecordsModules=} modules\n */\n\nclass RecordIdsPlugin {\n  /**\n   * @param {Object} options Options object\n   * @param {boolean=} options.portableIds true, when ids need to be portable\n   */\n  constructor(options) {\n    this.options = options || {};\n  }\n\n  /**\n   * @param {Compiler} compiler the Compiler\n   * @returns {void}\n   */\n  apply(compiler) {\n    const portableIds = this.options.portableIds;\n    compiler.hooks.compilation.tap(\"RecordIdsPlugin\", compilation => {\n      compilation.hooks.recordModules.tap(\"RecordIdsPlugin\",\n      /**\n       * @param {Module[]} modules the modules array\n       * @param {Records} records the records object\n       * @returns {void}\n       */\n      (modules, records) => {\n        if (!records.modules) records.modules = {};\n        if (!records.modules.byIdentifier) records.modules.byIdentifier = {};\n        if (!records.modules.usedIds) records.modules.usedIds = {};\n        for (const module of modules) {\n          if (typeof module.id !== \"number\") continue;\n          const identifier = portableIds ? identifierUtils.makePathsRelative(compiler.context, module.identifier(), compilation.cache) : module.identifier();\n          records.modules.byIdentifier[identifier] = module.id;\n          records.modules.usedIds[module.id] = module.id;\n        }\n      });\n      compilation.hooks.reviveModules.tap(\"RecordIdsPlugin\",\n      /**\n       * @param {Module[]} modules the modules array\n       * @param {Records} records the records object\n       * @returns {void}\n       */\n      (modules, records) => {\n        if (!records.modules) return;\n        if (records.modules.byIdentifier) {\n          /** @type {Set<number>} */\n          const usedIds = new Set();\n          for (const module of modules) {\n            if (module.id !== null) continue;\n            const identifier = portableIds ? identifierUtils.makePathsRelative(compiler.context, module.identifier(), compilation.cache) : module.identifier();\n            const id = records.modules.byIdentifier[identifier];\n            if (id === undefined) continue;\n            if (usedIds.has(id)) continue;\n            usedIds.add(id);\n            module.id = id;\n          }\n        }\n        if (Array.isArray(records.modules.usedIds)) {\n          compilation.usedModuleIds = new Set(records.modules.usedIds);\n        }\n      });\n\n      /**\n       * @param {Module} module the module\n       * @returns {string} the (portable) identifier\n       */\n      const getModuleIdentifier = module => {\n        if (portableIds) {\n          return identifierUtils.makePathsRelative(compiler.context, module.identifier(), compilation.cache);\n        }\n        return module.identifier();\n      };\n\n      /**\n       * @param {Chunk} chunk the chunk\n       * @returns {string[]} sources of the chunk\n       */\n      const getChunkSources = chunk => {\n        /** @type {string[]} */\n        const sources = [];\n        for (const chunkGroup of chunk.groupsIterable) {\n          const index = chunkGroup.chunks.indexOf(chunk);\n          for (const origin of chunkGroup.origins) {\n            if (origin.module) {\n              if (origin.request) {\n                sources.push(`${index} ${getModuleIdentifier(origin.module)} ${origin.request}`);\n              } else if (typeof origin.loc === \"string\") {\n                sources.push(`${index} ${getModuleIdentifier(origin.module)} ${origin.loc}`);\n              } else if (origin.loc && typeof origin.loc === \"object\" && origin.loc.start) {\n                sources.push(`${index} ${getModuleIdentifier(origin.module)} ${JSON.stringify(origin.loc.start)}`);\n              }\n            }\n          }\n        }\n        return sources;\n      };\n      compilation.hooks.recordChunks.tap(\"RecordIdsPlugin\",\n      /**\n       * @param {Chunk[]} chunks the chunks array\n       * @param {Records} records the records object\n       * @returns {void}\n       */\n      (chunks, records) => {\n        if (!records.chunks) records.chunks = {};\n        if (!records.chunks.byName) records.chunks.byName = {};\n        if (!records.chunks.bySource) records.chunks.bySource = {};\n        /** @type {Set<number>} */\n        const usedIds = new Set();\n        for (const chunk of chunks) {\n          if (typeof chunk.id !== \"number\") continue;\n          const name = chunk.name;\n          if (name) records.chunks.byName[name] = chunk.id;\n          const sources = getChunkSources(chunk);\n          for (const source of sources) {\n            records.chunks.bySource[source] = chunk.id;\n          }\n          usedIds.add(chunk.id);\n        }\n        records.chunks.usedIds = Array.from(usedIds).sort();\n      });\n      compilation.hooks.reviveChunks.tap(\"RecordIdsPlugin\",\n      /**\n       * @param {Chunk[]} chunks the chunks array\n       * @param {Records} records the records object\n       * @returns {void}\n       */\n      (chunks, records) => {\n        if (!records.chunks) return;\n        /** @type {Set<number>} */\n        const usedIds = new Set();\n        if (records.chunks.byName) {\n          for (const chunk of chunks) {\n            if (chunk.id !== null) continue;\n            if (!chunk.name) continue;\n            const id = records.chunks.byName[chunk.name];\n            if (id === undefined) continue;\n            if (usedIds.has(id)) continue;\n            usedIds.add(id);\n            chunk.id = id;\n          }\n        }\n        if (records.chunks.bySource) {\n          for (const chunk of chunks) {\n            const sources = getChunkSources(chunk);\n            for (const source of sources) {\n              const id = records.chunks.bySource[source];\n              if (id === undefined) continue;\n              if (usedIds.has(id)) continue;\n              usedIds.add(id);\n              chunk.id = id;\n              break;\n            }\n          }\n        }\n        if (Array.isArray(records.chunks.usedIds)) {\n          compilation.usedChunkIds = new Set(records.chunks.usedIds);\n        }\n      });\n    });\n  }\n}\nmodule.exports = RecordIdsPlugin;","map":{"version":3,"names":["identifierUtils","require","RecordIdsPlugin","constructor","options","apply","compiler","portableIds","hooks","compilation","tap","recordModules","modules","records","byIdentifier","usedIds","module","id","identifier","makePathsRelative","context","cache","reviveModules","Set","undefined","has","add","Array","isArray","usedModuleIds","getModuleIdentifier","getChunkSources","chunk","sources","chunkGroup","groupsIterable","index","chunks","indexOf","origin","origins","request","push","loc","start","JSON","stringify","recordChunks","byName","bySource","name","source","from","sort","reviveChunks","usedChunkIds","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/RecordIdsPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst identifierUtils = require(\"./util/identifier\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} RecordsChunks\n * @property {Record<string, number>=} byName\n * @property {Record<string, number>=} bySource\n * @property {number[]=} usedIds\n */\n\n/**\n * @typedef {Object} RecordsModules\n * @property {Record<string, number>=} byIdentifier\n * @property {Record<string, number>=} bySource\n * @property {Record<number, number>=} usedIds\n */\n\n/**\n * @typedef {Object} Records\n * @property {RecordsChunks=} chunks\n * @property {RecordsModules=} modules\n */\n\nclass RecordIdsPlugin {\n\t/**\n\t * @param {Object} options Options object\n\t * @param {boolean=} options.portableIds true, when ids need to be portable\n\t */\n\tconstructor(options) {\n\t\tthis.options = options || {};\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the Compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst portableIds = this.options.portableIds;\n\t\tcompiler.hooks.compilation.tap(\"RecordIdsPlugin\", compilation => {\n\t\t\tcompilation.hooks.recordModules.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Module[]} modules the modules array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(modules, records) => {\n\t\t\t\t\tif (!records.modules) records.modules = {};\n\t\t\t\t\tif (!records.modules.byIdentifier) records.modules.byIdentifier = {};\n\t\t\t\t\tif (!records.modules.usedIds) records.modules.usedIds = {};\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tif (typeof module.id !== \"number\") continue;\n\t\t\t\t\t\tconst identifier = portableIds\n\t\t\t\t\t\t\t? identifierUtils.makePathsRelative(\n\t\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\t\t\t\tcompilation.cache\n\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t: module.identifier();\n\t\t\t\t\t\trecords.modules.byIdentifier[identifier] = module.id;\n\t\t\t\t\t\trecords.modules.usedIds[module.id] = module.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tcompilation.hooks.reviveModules.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Module[]} modules the modules array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(modules, records) => {\n\t\t\t\t\tif (!records.modules) return;\n\t\t\t\t\tif (records.modules.byIdentifier) {\n\t\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\tif (module.id !== null) continue;\n\t\t\t\t\t\t\tconst identifier = portableIds\n\t\t\t\t\t\t\t\t? identifierUtils.makePathsRelative(\n\t\t\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\t\t\t\t\tcompilation.cache\n\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t: module.identifier();\n\t\t\t\t\t\t\tconst id = records.modules.byIdentifier[identifier];\n\t\t\t\t\t\t\tif (id === undefined) continue;\n\t\t\t\t\t\t\tif (usedIds.has(id)) continue;\n\t\t\t\t\t\t\tusedIds.add(id);\n\t\t\t\t\t\t\tmodule.id = id;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(records.modules.usedIds)) {\n\t\t\t\t\t\tcompilation.usedModuleIds = new Set(records.modules.usedIds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t/**\n\t\t\t * @param {Module} module the module\n\t\t\t * @returns {string} the (portable) identifier\n\t\t\t */\n\t\t\tconst getModuleIdentifier = module => {\n\t\t\t\tif (portableIds) {\n\t\t\t\t\treturn identifierUtils.makePathsRelative(\n\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\tcompilation.cache\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn module.identifier();\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * @param {Chunk} chunk the chunk\n\t\t\t * @returns {string[]} sources of the chunk\n\t\t\t */\n\t\t\tconst getChunkSources = chunk => {\n\t\t\t\t/** @type {string[]} */\n\t\t\t\tconst sources = [];\n\t\t\t\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\t\t\t\tconst index = chunkGroup.chunks.indexOf(chunk);\n\t\t\t\t\tfor (const origin of chunkGroup.origins) {\n\t\t\t\t\t\tif (origin.module) {\n\t\t\t\t\t\t\tif (origin.request) {\n\t\t\t\t\t\t\t\tsources.push(\n\t\t\t\t\t\t\t\t\t`${index} ${getModuleIdentifier(origin.module)} ${\n\t\t\t\t\t\t\t\t\t\torigin.request\n\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else if (typeof origin.loc === \"string\") {\n\t\t\t\t\t\t\t\tsources.push(\n\t\t\t\t\t\t\t\t\t`${index} ${getModuleIdentifier(origin.module)} ${origin.loc}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\torigin.loc &&\n\t\t\t\t\t\t\t\ttypeof origin.loc === \"object\" &&\n\t\t\t\t\t\t\t\torigin.loc.start\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tsources.push(\n\t\t\t\t\t\t\t\t\t`${index} ${getModuleIdentifier(\n\t\t\t\t\t\t\t\t\t\torigin.module\n\t\t\t\t\t\t\t\t\t)} ${JSON.stringify(origin.loc.start)}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sources;\n\t\t\t};\n\n\t\t\tcompilation.hooks.recordChunks.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Chunk[]} chunks the chunks array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(chunks, records) => {\n\t\t\t\t\tif (!records.chunks) records.chunks = {};\n\t\t\t\t\tif (!records.chunks.byName) records.chunks.byName = {};\n\t\t\t\t\tif (!records.chunks.bySource) records.chunks.bySource = {};\n\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tif (typeof chunk.id !== \"number\") continue;\n\t\t\t\t\t\tconst name = chunk.name;\n\t\t\t\t\t\tif (name) records.chunks.byName[name] = chunk.id;\n\t\t\t\t\t\tconst sources = getChunkSources(chunk);\n\t\t\t\t\t\tfor (const source of sources) {\n\t\t\t\t\t\t\trecords.chunks.bySource[source] = chunk.id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tusedIds.add(chunk.id);\n\t\t\t\t\t}\n\t\t\t\t\trecords.chunks.usedIds = Array.from(usedIds).sort();\n\t\t\t\t}\n\t\t\t);\n\t\t\tcompilation.hooks.reviveChunks.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Chunk[]} chunks the chunks array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(chunks, records) => {\n\t\t\t\t\tif (!records.chunks) return;\n\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\tif (records.chunks.byName) {\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tif (chunk.id !== null) continue;\n\t\t\t\t\t\t\tif (!chunk.name) continue;\n\t\t\t\t\t\t\tconst id = records.chunks.byName[chunk.name];\n\t\t\t\t\t\t\tif (id === undefined) continue;\n\t\t\t\t\t\t\tif (usedIds.has(id)) continue;\n\t\t\t\t\t\t\tusedIds.add(id);\n\t\t\t\t\t\t\tchunk.id = id;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (records.chunks.bySource) {\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tconst sources = getChunkSources(chunk);\n\t\t\t\t\t\t\tfor (const source of sources) {\n\t\t\t\t\t\t\t\tconst id = records.chunks.bySource[source];\n\t\t\t\t\t\t\t\tif (id === undefined) continue;\n\t\t\t\t\t\t\t\tif (usedIds.has(id)) continue;\n\t\t\t\t\t\t\t\tusedIds.add(id);\n\t\t\t\t\t\t\t\tchunk.id = id;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(records.chunks.usedIds)) {\n\t\t\t\t\t\tcompilation.usedChunkIds = new Set(records.chunks.usedIds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = RecordIdsPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}