{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nconst GraphHelpers = require(\"./GraphHelpers\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {QueueItem[]} skippedItems queue items that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<Module>} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroup>} children set of children chunk groups, that will be revisited when availableModules shrink\n */\n\n/**\n * @typedef {Object} ChunkGroupDep\n * @property {AsyncDependenciesBlock} block referencing block\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/**\n * @template T\n * @param {Set<T>} a first set\n * @param {Set<T>} b second set\n * @returns {number} cmp\n */\nconst bySetSize = (a, b) => {\n  return b.size - a.size;\n};\n\n/**\n * Extracts simplified info from the modules and their dependencies\n * @param {Compilation} compilation the compilation\n * @returns {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} the mapping block to modules and inner blocks\n */\nconst extraceBlockInfoMap = compilation => {\n  /** @type {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} */\n  const blockInfoMap = new Map();\n\n  /**\n   * @param {Dependency} d dependency to iterate over\n   * @returns {void}\n   */\n  const iteratorDependency = d => {\n    // We skip Dependencies without Reference\n    const ref = compilation.getDependencyReference(currentModule, d);\n    if (!ref) {\n      return;\n    }\n    // We skip Dependencies without Module pointer\n    const refModule = ref.module;\n    if (!refModule) {\n      return;\n    }\n    // We skip weak Dependencies\n    if (ref.weak) {\n      return;\n    }\n    blockInfoModules.add(refModule);\n  };\n\n  /**\n   * @param {AsyncDependenciesBlock} b blocks to prepare\n   * @returns {void}\n   */\n  const iteratorBlockPrepare = b => {\n    blockInfoBlocks.push(b);\n    blockQueue.push(b);\n  };\n\n  /** @type {Module} */\n  let currentModule;\n  /** @type {DependenciesBlock} */\n  let block;\n  /** @type {DependenciesBlock[]} */\n  let blockQueue;\n  /** @type {Set<Module>} */\n  let blockInfoModules;\n  /** @type {AsyncDependenciesBlock[]} */\n  let blockInfoBlocks;\n  for (const module of compilation.modules) {\n    blockQueue = [module];\n    currentModule = module;\n    while (blockQueue.length > 0) {\n      block = blockQueue.pop();\n      blockInfoModules = new Set();\n      blockInfoBlocks = [];\n      if (block.variables) {\n        for (const variable of block.variables) {\n          for (const dep of variable.dependencies) iteratorDependency(dep);\n        }\n      }\n      if (block.dependencies) {\n        for (const dep of block.dependencies) iteratorDependency(dep);\n      }\n      if (block.blocks) {\n        for (const b of block.blocks) iteratorBlockPrepare(b);\n      }\n      const blockInfo = {\n        modules: blockInfoModules,\n        blocks: blockInfoBlocks\n      };\n      blockInfoMap.set(block, blockInfo);\n    }\n  }\n  return blockInfoMap;\n};\n\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups input groups\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<ChunkGroup, ChunkGroupDep[]>} chunkDependencies dependencies for chunk groups\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\nconst visitModules = (compilation, inputChunkGroups, chunkGroupInfoMap, chunkDependencies, blocksWithNestedBlocks, allCreatedChunkGroups) => {\n  const logger = compilation.getLogger(\"webpack.buildChunkGraph.visitModules\");\n  const {\n    namedChunkGroups\n  } = compilation;\n  logger.time(\"prepare\");\n  const blockInfoMap = extraceBlockInfoMap(compilation);\n\n  /** @type {Map<ChunkGroup, { index: number, index2: number }>} */\n  const chunkGroupCounters = new Map();\n  for (const chunkGroup of inputChunkGroups) {\n    chunkGroupCounters.set(chunkGroup, {\n      index: 0,\n      index2: 0\n    });\n  }\n  let nextFreeModuleIndex = 0;\n  let nextFreeModuleIndex2 = 0;\n\n  /** @type {Map<DependenciesBlock, ChunkGroup>} */\n  const blockChunkGroups = new Map();\n  const ADD_AND_ENTER_MODULE = 0;\n  const ENTER_MODULE = 1;\n  const PROCESS_BLOCK = 2;\n  const LEAVE_MODULE = 3;\n\n  /**\n   * @param {QueueItem[]} queue the queue array (will be mutated)\n   * @param {ChunkGroup} chunkGroup chunk group\n   * @returns {QueueItem[]} the queue array again\n   */\n  const reduceChunkGroupToQueueItem = (queue, chunkGroup) => {\n    for (const chunk of chunkGroup.chunks) {\n      const module = chunk.entryModule;\n      queue.push({\n        action: ENTER_MODULE,\n        block: module,\n        module,\n        chunk,\n        chunkGroup\n      });\n    }\n    chunkGroupInfoMap.set(chunkGroup, {\n      chunkGroup,\n      minAvailableModules: new Set(),\n      minAvailableModulesOwned: true,\n      availableModulesToBeMerged: [],\n      skippedItems: [],\n      resultingAvailableModules: undefined,\n      children: undefined\n    });\n    return queue;\n  };\n\n  // Start with the provided modules/chunks\n  /** @type {QueueItem[]} */\n  let queue = inputChunkGroups.reduce(reduceChunkGroupToQueueItem, []).reverse();\n  /** @type {Map<ChunkGroup, Set<ChunkGroup>>} */\n  const queueConnect = new Map();\n  /** @type {Set<ChunkGroupInfo>} */\n  const outdatedChunkGroupInfo = new Set();\n  /** @type {QueueItem[]} */\n  let queueDelayed = [];\n  logger.timeEnd(\"prepare\");\n\n  /** @type {Module} */\n  let module;\n  /** @type {Chunk} */\n  let chunk;\n  /** @type {ChunkGroup} */\n  let chunkGroup;\n  /** @type {DependenciesBlock} */\n  let block;\n  /** @type {Set<Module>} */\n  let minAvailableModules;\n  /** @type {QueueItem[]} */\n  let skippedItems;\n\n  // For each async Block in graph\n  /**\n   * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n   * @returns {void}\n   */\n  const iteratorBlock = b => {\n    // 1. We create a chunk for this Block\n    // but only once (blockChunkGroups map)\n    let c = blockChunkGroups.get(b);\n    if (c === undefined) {\n      c = namedChunkGroups.get(b.chunkName);\n      if (c && c.isInitial()) {\n        compilation.errors.push(new AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc));\n        c = chunkGroup;\n      } else {\n        c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request);\n        chunkGroupCounters.set(c, {\n          index: 0,\n          index2: 0\n        });\n        blockChunkGroups.set(b, c);\n        allCreatedChunkGroups.add(c);\n      }\n    } else {\n      // TODO webpack 5 remove addOptions check\n      if (c.addOptions) c.addOptions(b.groupOptions);\n      c.addOrigin(module, b.loc, b.request);\n    }\n\n    // 2. We store the Block+Chunk mapping as dependency for the chunk\n    let deps = chunkDependencies.get(chunkGroup);\n    if (!deps) chunkDependencies.set(chunkGroup, deps = []);\n    deps.push({\n      block: b,\n      chunkGroup: c\n    });\n\n    // 3. We create/update the chunk group info\n    let connectList = queueConnect.get(chunkGroup);\n    if (connectList === undefined) {\n      connectList = new Set();\n      queueConnect.set(chunkGroup, connectList);\n    }\n    connectList.add(c);\n\n    // 4. We enqueue the DependenciesBlock for traversal\n    queueDelayed.push({\n      action: PROCESS_BLOCK,\n      block: b,\n      module: module,\n      chunk: c.chunks[0],\n      chunkGroup: c\n    });\n  };\n\n  // Iterative traversal of the Module graph\n  // Recursive would be simpler to write but could result in Stack Overflows\n  while (queue.length) {\n    logger.time(\"visiting\");\n    while (queue.length) {\n      const queueItem = queue.pop();\n      module = queueItem.module;\n      block = queueItem.block;\n      chunk = queueItem.chunk;\n      if (chunkGroup !== queueItem.chunkGroup) {\n        chunkGroup = queueItem.chunkGroup;\n        const chunkGroupInfo = chunkGroupInfoMap.get(chunkGroup);\n        minAvailableModules = chunkGroupInfo.minAvailableModules;\n        skippedItems = chunkGroupInfo.skippedItems;\n      }\n      switch (queueItem.action) {\n        case ADD_AND_ENTER_MODULE:\n          {\n            if (minAvailableModules.has(module)) {\n              // already in parent chunks\n              // skip it for now, but enqueue for rechecking when minAvailableModules shrinks\n              skippedItems.push(queueItem);\n              break;\n            }\n            // We connect Module and Chunk when not already done\n            if (chunk.addModule(module)) {\n              module.addChunk(chunk);\n            } else {\n              // already connected, skip it\n              break;\n            }\n          }\n        // fallthrough\n        case ENTER_MODULE:\n          {\n            if (chunkGroup !== undefined) {\n              const index = chunkGroup.getModuleIndex(module);\n              if (index === undefined) {\n                chunkGroup.setModuleIndex(module, chunkGroupCounters.get(chunkGroup).index++);\n              }\n            }\n            if (module.index === null) {\n              module.index = nextFreeModuleIndex++;\n            }\n            queue.push({\n              action: LEAVE_MODULE,\n              block,\n              module,\n              chunk,\n              chunkGroup\n            });\n          }\n        // fallthrough\n        case PROCESS_BLOCK:\n          {\n            // get prepared block info\n            const blockInfo = blockInfoMap.get(block);\n\n            // Buffer items because order need to be reverse to get indicies correct\n            const skipBuffer = [];\n            const queueBuffer = [];\n            // Traverse all referenced modules\n            for (const refModule of blockInfo.modules) {\n              if (chunk.containsModule(refModule)) {\n                // skip early if already connected\n                continue;\n              }\n              if (minAvailableModules.has(refModule)) {\n                // already in parent chunks, skip it for now\n                skipBuffer.push({\n                  action: ADD_AND_ENTER_MODULE,\n                  block: refModule,\n                  module: refModule,\n                  chunk,\n                  chunkGroup\n                });\n                continue;\n              }\n              // enqueue the add and enter to enter in the correct order\n              // this is relevant with circular dependencies\n              queueBuffer.push({\n                action: ADD_AND_ENTER_MODULE,\n                block: refModule,\n                module: refModule,\n                chunk,\n                chunkGroup\n              });\n            }\n            // Add buffered items in reversed order\n            for (let i = skipBuffer.length - 1; i >= 0; i--) {\n              skippedItems.push(skipBuffer[i]);\n            }\n            for (let i = queueBuffer.length - 1; i >= 0; i--) {\n              queue.push(queueBuffer[i]);\n            }\n\n            // Traverse all Blocks\n            for (const block of blockInfo.blocks) iteratorBlock(block);\n            if (blockInfo.blocks.length > 0 && module !== block) {\n              blocksWithNestedBlocks.add(block);\n            }\n            break;\n          }\n        case LEAVE_MODULE:\n          {\n            if (chunkGroup !== undefined) {\n              const index = chunkGroup.getModuleIndex2(module);\n              if (index === undefined) {\n                chunkGroup.setModuleIndex2(module, chunkGroupCounters.get(chunkGroup).index2++);\n              }\n            }\n            if (module.index2 === null) {\n              module.index2 = nextFreeModuleIndex2++;\n            }\n            break;\n          }\n      }\n    }\n    logger.timeEnd(\"visiting\");\n    while (queueConnect.size > 0) {\n      logger.time(\"calculating available modules\");\n\n      // Figure out new parents for chunk groups\n      // to get new available modules for these children\n      for (const [chunkGroup, targets] of queueConnect) {\n        const info = chunkGroupInfoMap.get(chunkGroup);\n        let minAvailableModules = info.minAvailableModules;\n\n        // 1. Create a new Set of available modules at this points\n        const resultingAvailableModules = new Set(minAvailableModules);\n        for (const chunk of chunkGroup.chunks) {\n          for (const m of chunk.modulesIterable) {\n            resultingAvailableModules.add(m);\n          }\n        }\n        info.resultingAvailableModules = resultingAvailableModules;\n        if (info.children === undefined) {\n          info.children = targets;\n        } else {\n          for (const target of targets) {\n            info.children.add(target);\n          }\n        }\n\n        // 2. Update chunk group info\n        for (const target of targets) {\n          let chunkGroupInfo = chunkGroupInfoMap.get(target);\n          if (chunkGroupInfo === undefined) {\n            chunkGroupInfo = {\n              chunkGroup: target,\n              minAvailableModules: undefined,\n              minAvailableModulesOwned: undefined,\n              availableModulesToBeMerged: [],\n              skippedItems: [],\n              resultingAvailableModules: undefined,\n              children: undefined\n            };\n            chunkGroupInfoMap.set(target, chunkGroupInfo);\n          }\n          chunkGroupInfo.availableModulesToBeMerged.push(resultingAvailableModules);\n          outdatedChunkGroupInfo.add(chunkGroupInfo);\n        }\n      }\n      queueConnect.clear();\n      logger.timeEnd(\"calculating available modules\");\n      if (outdatedChunkGroupInfo.size > 0) {\n        logger.time(\"merging available modules\");\n        // Execute the merge\n        for (const info of outdatedChunkGroupInfo) {\n          const availableModulesToBeMerged = info.availableModulesToBeMerged;\n          let cachedMinAvailableModules = info.minAvailableModules;\n\n          // 1. Get minimal available modules\n          // It doesn't make sense to traverse a chunk again with more available modules.\n          // This step calculates the minimal available modules and skips traversal when\n          // the list didn't shrink.\n          if (availableModulesToBeMerged.length > 1) {\n            availableModulesToBeMerged.sort(bySetSize);\n          }\n          let changed = false;\n          for (const availableModules of availableModulesToBeMerged) {\n            if (cachedMinAvailableModules === undefined) {\n              cachedMinAvailableModules = availableModules;\n              info.minAvailableModules = cachedMinAvailableModules;\n              info.minAvailableModulesOwned = false;\n              changed = true;\n            } else {\n              if (info.minAvailableModulesOwned) {\n                // We own it and can modify it\n                for (const m of cachedMinAvailableModules) {\n                  if (!availableModules.has(m)) {\n                    cachedMinAvailableModules.delete(m);\n                    changed = true;\n                  }\n                }\n              } else {\n                for (const m of cachedMinAvailableModules) {\n                  if (!availableModules.has(m)) {\n                    // cachedMinAvailableModules need to be modified\n                    // but we don't own it\n                    // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n                    /** @type {Set<Module>} */\n                    const newSet = new Set();\n                    const iterator = cachedMinAvailableModules[Symbol.iterator]();\n                    /** @type {IteratorResult<Module>} */\n                    let it;\n                    while (!(it = iterator.next()).done) {\n                      const module = it.value;\n                      if (module === m) break;\n                      newSet.add(module);\n                    }\n                    while (!(it = iterator.next()).done) {\n                      const module = it.value;\n                      if (availableModules.has(module)) {\n                        newSet.add(module);\n                      }\n                    }\n                    cachedMinAvailableModules = newSet;\n                    info.minAvailableModulesOwned = true;\n                    info.minAvailableModules = newSet;\n\n                    // Update the cache from the first queue\n                    // if the chunkGroup is currently cached\n                    if (chunkGroup === info.chunkGroup) {\n                      minAvailableModules = cachedMinAvailableModules;\n                    }\n                    changed = true;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          availableModulesToBeMerged.length = 0;\n          if (!changed) continue;\n\n          // 2. Reconsider skipped items\n          for (const queueItem of info.skippedItems) {\n            queue.push(queueItem);\n          }\n          info.skippedItems.length = 0;\n\n          // 3. Reconsider children chunk groups\n          if (info.children !== undefined) {\n            const chunkGroup = info.chunkGroup;\n            for (const c of info.children) {\n              let connectList = queueConnect.get(chunkGroup);\n              if (connectList === undefined) {\n                connectList = new Set();\n                queueConnect.set(chunkGroup, connectList);\n              }\n              connectList.add(c);\n            }\n          }\n        }\n        outdatedChunkGroupInfo.clear();\n        logger.timeEnd(\"merging available modules\");\n      }\n    }\n\n    // Run queueDelayed when all items of the queue are processed\n    // This is important to get the global indicing correct\n    // Async blocks should be processed after all sync blocks are processed\n    if (queue.length === 0) {\n      const tempQueue = queue;\n      queue = queueDelayed.reverse();\n      queueDelayed = tempQueue;\n    }\n  }\n};\n\n/**\n *\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<ChunkGroup, ChunkGroupDep[]>} chunkDependencies dependencies for chunk groups\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\nconst connectChunkGroups = (blocksWithNestedBlocks, chunkDependencies, chunkGroupInfoMap) => {\n  /** @type {Set<Module>} */\n  let resultingAvailableModules;\n\n  /**\n   * Helper function to check if all modules of a chunk are available\n   *\n   * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n   * @param {Set<Module>} availableModules the comparitor set\n   * @returns {boolean} return true if all modules of a chunk are available\n   */\n  const areModulesAvailable = (chunkGroup, availableModules) => {\n    for (const chunk of chunkGroup.chunks) {\n      for (const module of chunk.modulesIterable) {\n        if (!availableModules.has(module)) return false;\n      }\n    }\n    return true;\n  };\n\n  // For each edge in the basic chunk graph\n  /**\n   * @param {ChunkGroupDep} dep the dependency used for filtering\n   * @returns {boolean} used to filter \"edges\" (aka Dependencies) that were pointing\n   * to modules that are already available. Also filters circular dependencies in the chunks graph\n   */\n  const filterFn = dep => {\n    const depChunkGroup = dep.chunkGroup;\n    // TODO is this needed?\n    if (blocksWithNestedBlocks.has(dep.block)) return true;\n    if (areModulesAvailable(depChunkGroup, resultingAvailableModules)) {\n      return false; // break all modules are already available\n    }\n    return true;\n  };\n\n  // For all deps, check if chunk groups need to be connected\n  for (const [chunkGroup, deps] of chunkDependencies) {\n    if (deps.length === 0) continue;\n\n    // 1. Get info from chunk group info map\n    const info = chunkGroupInfoMap.get(chunkGroup);\n    resultingAvailableModules = info.resultingAvailableModules;\n\n    // 2. Foreach edge\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i];\n\n      // Filter inline, rather than creating a new array from `.filter()`\n      // TODO check if inlining filterFn makes sense here\n      if (!filterFn(dep)) {\n        continue;\n      }\n      const depChunkGroup = dep.chunkGroup;\n      const depBlock = dep.block;\n\n      // 5. Connect block with chunk\n      GraphHelpers.connectDependenciesBlockAndChunkGroup(depBlock, depChunkGroup);\n\n      // 6. Connect chunk with parent\n      GraphHelpers.connectChunkGroupParentAndChild(chunkGroup, depChunkGroup);\n    }\n  }\n};\n\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n  for (const chunkGroup of allCreatedChunkGroups) {\n    if (chunkGroup.getNumberOfParents() === 0) {\n      for (const chunk of chunkGroup.chunks) {\n        const idx = compilation.chunks.indexOf(chunk);\n        if (idx >= 0) compilation.chunks.splice(idx, 1);\n        chunk.remove(\"unconnected\");\n      }\n      chunkGroup.remove(\"unconnected\");\n    }\n  }\n};\n\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups chunk groups which are processed\n * @returns {void}\n */\nconst buildChunkGraph = (compilation, inputChunkGroups) => {\n  // SHARED STATE\n\n  /** @type {Map<ChunkGroup, ChunkGroupDep[]>} */\n  const chunkDependencies = new Map();\n\n  /** @type {Set<ChunkGroup>} */\n  const allCreatedChunkGroups = new Set();\n\n  /** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n  const chunkGroupInfoMap = new Map();\n\n  /** @type {Set<DependenciesBlock>} */\n  const blocksWithNestedBlocks = new Set();\n\n  // PART ONE\n\n  visitModules(compilation, inputChunkGroups, chunkGroupInfoMap, chunkDependencies, blocksWithNestedBlocks, allCreatedChunkGroups);\n\n  // PART TWO\n\n  connectChunkGroups(blocksWithNestedBlocks, chunkDependencies, chunkGroupInfoMap);\n\n  // Cleaup work\n\n  cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n};\nmodule.exports = buildChunkGraph;","map":{"version":3,"names":["AsyncDependencyToInitialChunkError","require","GraphHelpers","bySetSize","a","b","size","extraceBlockInfoMap","compilation","blockInfoMap","Map","iteratorDependency","d","ref","getDependencyReference","currentModule","refModule","module","weak","blockInfoModules","add","iteratorBlockPrepare","blockInfoBlocks","push","blockQueue","block","modules","length","pop","Set","variables","variable","dep","dependencies","blocks","blockInfo","set","visitModules","inputChunkGroups","chunkGroupInfoMap","chunkDependencies","blocksWithNestedBlocks","allCreatedChunkGroups","logger","getLogger","namedChunkGroups","time","chunkGroupCounters","chunkGroup","index","index2","nextFreeModuleIndex","nextFreeModuleIndex2","blockChunkGroups","ADD_AND_ENTER_MODULE","ENTER_MODULE","PROCESS_BLOCK","LEAVE_MODULE","reduceChunkGroupToQueueItem","queue","chunk","chunks","entryModule","action","minAvailableModules","minAvailableModulesOwned","availableModulesToBeMerged","skippedItems","resultingAvailableModules","undefined","children","reduce","reverse","queueConnect","outdatedChunkGroupInfo","queueDelayed","timeEnd","iteratorBlock","c","get","chunkName","isInitial","errors","loc","addChunkInGroup","groupOptions","request","addOptions","addOrigin","deps","connectList","queueItem","chunkGroupInfo","has","addModule","addChunk","getModuleIndex","setModuleIndex","skipBuffer","queueBuffer","containsModule","i","getModuleIndex2","setModuleIndex2","targets","info","m","modulesIterable","target","clear","cachedMinAvailableModules","sort","changed","availableModules","delete","newSet","iterator","Symbol","it","next","done","value","tempQueue","connectChunkGroups","areModulesAvailable","filterFn","depChunkGroup","depBlock","connectDependenciesBlockAndChunkGroup","connectChunkGroupParentAndChild","cleanupUnconnectedGroups","getNumberOfParents","idx","indexOf","splice","remove","buildChunkGraph","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/buildChunkGraph.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nconst GraphHelpers = require(\"./GraphHelpers\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {QueueItem[]} skippedItems queue items that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<Module>} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroup>} children set of children chunk groups, that will be revisited when availableModules shrink\n */\n\n/**\n * @typedef {Object} ChunkGroupDep\n * @property {AsyncDependenciesBlock} block referencing block\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/**\n * @template T\n * @param {Set<T>} a first set\n * @param {Set<T>} b second set\n * @returns {number} cmp\n */\nconst bySetSize = (a, b) => {\n\treturn b.size - a.size;\n};\n\n/**\n * Extracts simplified info from the modules and their dependencies\n * @param {Compilation} compilation the compilation\n * @returns {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} the mapping block to modules and inner blocks\n */\nconst extraceBlockInfoMap = compilation => {\n\t/** @type {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} */\n\tconst blockInfoMap = new Map();\n\n\t/**\n\t * @param {Dependency} d dependency to iterate over\n\t * @returns {void}\n\t */\n\tconst iteratorDependency = d => {\n\t\t// We skip Dependencies without Reference\n\t\tconst ref = compilation.getDependencyReference(currentModule, d);\n\t\tif (!ref) {\n\t\t\treturn;\n\t\t}\n\t\t// We skip Dependencies without Module pointer\n\t\tconst refModule = ref.module;\n\t\tif (!refModule) {\n\t\t\treturn;\n\t\t}\n\t\t// We skip weak Dependencies\n\t\tif (ref.weak) {\n\t\t\treturn;\n\t\t}\n\n\t\tblockInfoModules.add(refModule);\n\t};\n\n\t/**\n\t * @param {AsyncDependenciesBlock} b blocks to prepare\n\t * @returns {void}\n\t */\n\tconst iteratorBlockPrepare = b => {\n\t\tblockInfoBlocks.push(b);\n\t\tblockQueue.push(b);\n\t};\n\n\t/** @type {Module} */\n\tlet currentModule;\n\t/** @type {DependenciesBlock} */\n\tlet block;\n\t/** @type {DependenciesBlock[]} */\n\tlet blockQueue;\n\t/** @type {Set<Module>} */\n\tlet blockInfoModules;\n\t/** @type {AsyncDependenciesBlock[]} */\n\tlet blockInfoBlocks;\n\n\tfor (const module of compilation.modules) {\n\t\tblockQueue = [module];\n\t\tcurrentModule = module;\n\t\twhile (blockQueue.length > 0) {\n\t\t\tblock = blockQueue.pop();\n\t\t\tblockInfoModules = new Set();\n\t\t\tblockInfoBlocks = [];\n\n\t\t\tif (block.variables) {\n\t\t\t\tfor (const variable of block.variables) {\n\t\t\t\t\tfor (const dep of variable.dependencies) iteratorDependency(dep);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (block.dependencies) {\n\t\t\t\tfor (const dep of block.dependencies) iteratorDependency(dep);\n\t\t\t}\n\n\t\t\tif (block.blocks) {\n\t\t\t\tfor (const b of block.blocks) iteratorBlockPrepare(b);\n\t\t\t}\n\n\t\t\tconst blockInfo = {\n\t\t\t\tmodules: blockInfoModules,\n\t\t\t\tblocks: blockInfoBlocks\n\t\t\t};\n\t\t\tblockInfoMap.set(block, blockInfo);\n\t\t}\n\t}\n\n\treturn blockInfoMap;\n};\n\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups input groups\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<ChunkGroup, ChunkGroupDep[]>} chunkDependencies dependencies for chunk groups\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\nconst visitModules = (\n\tcompilation,\n\tinputChunkGroups,\n\tchunkGroupInfoMap,\n\tchunkDependencies,\n\tblocksWithNestedBlocks,\n\tallCreatedChunkGroups\n) => {\n\tconst logger = compilation.getLogger(\"webpack.buildChunkGraph.visitModules\");\n\tconst { namedChunkGroups } = compilation;\n\n\tlogger.time(\"prepare\");\n\tconst blockInfoMap = extraceBlockInfoMap(compilation);\n\n\t/** @type {Map<ChunkGroup, { index: number, index2: number }>} */\n\tconst chunkGroupCounters = new Map();\n\tfor (const chunkGroup of inputChunkGroups) {\n\t\tchunkGroupCounters.set(chunkGroup, {\n\t\t\tindex: 0,\n\t\t\tindex2: 0\n\t\t});\n\t}\n\n\tlet nextFreeModuleIndex = 0;\n\tlet nextFreeModuleIndex2 = 0;\n\n\t/** @type {Map<DependenciesBlock, ChunkGroup>} */\n\tconst blockChunkGroups = new Map();\n\n\tconst ADD_AND_ENTER_MODULE = 0;\n\tconst ENTER_MODULE = 1;\n\tconst PROCESS_BLOCK = 2;\n\tconst LEAVE_MODULE = 3;\n\n\t/**\n\t * @param {QueueItem[]} queue the queue array (will be mutated)\n\t * @param {ChunkGroup} chunkGroup chunk group\n\t * @returns {QueueItem[]} the queue array again\n\t */\n\tconst reduceChunkGroupToQueueItem = (queue, chunkGroup) => {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tconst module = chunk.entryModule;\n\t\t\tqueue.push({\n\t\t\t\taction: ENTER_MODULE,\n\t\t\t\tblock: module,\n\t\t\t\tmodule,\n\t\t\t\tchunk,\n\t\t\t\tchunkGroup\n\t\t\t});\n\t\t}\n\t\tchunkGroupInfoMap.set(chunkGroup, {\n\t\t\tchunkGroup,\n\t\t\tminAvailableModules: new Set(),\n\t\t\tminAvailableModulesOwned: true,\n\t\t\tavailableModulesToBeMerged: [],\n\t\t\tskippedItems: [],\n\t\t\tresultingAvailableModules: undefined,\n\t\t\tchildren: undefined\n\t\t});\n\t\treturn queue;\n\t};\n\n\t// Start with the provided modules/chunks\n\t/** @type {QueueItem[]} */\n\tlet queue = inputChunkGroups\n\t\t.reduce(reduceChunkGroupToQueueItem, [])\n\t\t.reverse();\n\t/** @type {Map<ChunkGroup, Set<ChunkGroup>>} */\n\tconst queueConnect = new Map();\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst outdatedChunkGroupInfo = new Set();\n\t/** @type {QueueItem[]} */\n\tlet queueDelayed = [];\n\n\tlogger.timeEnd(\"prepare\");\n\n\t/** @type {Module} */\n\tlet module;\n\t/** @type {Chunk} */\n\tlet chunk;\n\t/** @type {ChunkGroup} */\n\tlet chunkGroup;\n\t/** @type {DependenciesBlock} */\n\tlet block;\n\t/** @type {Set<Module>} */\n\tlet minAvailableModules;\n\t/** @type {QueueItem[]} */\n\tlet skippedItems;\n\n\t// For each async Block in graph\n\t/**\n\t * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n\t * @returns {void}\n\t */\n\tconst iteratorBlock = b => {\n\t\t// 1. We create a chunk for this Block\n\t\t// but only once (blockChunkGroups map)\n\t\tlet c = blockChunkGroups.get(b);\n\t\tif (c === undefined) {\n\t\t\tc = namedChunkGroups.get(b.chunkName);\n\t\t\tif (c && c.isInitial()) {\n\t\t\t\tcompilation.errors.push(\n\t\t\t\t\tnew AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc)\n\t\t\t\t);\n\t\t\t\tc = chunkGroup;\n\t\t\t} else {\n\t\t\t\tc = compilation.addChunkInGroup(\n\t\t\t\t\tb.groupOptions || b.chunkName,\n\t\t\t\t\tmodule,\n\t\t\t\t\tb.loc,\n\t\t\t\t\tb.request\n\t\t\t\t);\n\t\t\t\tchunkGroupCounters.set(c, { index: 0, index2: 0 });\n\t\t\t\tblockChunkGroups.set(b, c);\n\t\t\t\tallCreatedChunkGroups.add(c);\n\t\t\t}\n\t\t} else {\n\t\t\t// TODO webpack 5 remove addOptions check\n\t\t\tif (c.addOptions) c.addOptions(b.groupOptions);\n\t\t\tc.addOrigin(module, b.loc, b.request);\n\t\t}\n\n\t\t// 2. We store the Block+Chunk mapping as dependency for the chunk\n\t\tlet deps = chunkDependencies.get(chunkGroup);\n\t\tif (!deps) chunkDependencies.set(chunkGroup, (deps = []));\n\t\tdeps.push({\n\t\t\tblock: b,\n\t\t\tchunkGroup: c\n\t\t});\n\n\t\t// 3. We create/update the chunk group info\n\t\tlet connectList = queueConnect.get(chunkGroup);\n\t\tif (connectList === undefined) {\n\t\t\tconnectList = new Set();\n\t\t\tqueueConnect.set(chunkGroup, connectList);\n\t\t}\n\t\tconnectList.add(c);\n\n\t\t// 4. We enqueue the DependenciesBlock for traversal\n\t\tqueueDelayed.push({\n\t\t\taction: PROCESS_BLOCK,\n\t\t\tblock: b,\n\t\t\tmodule: module,\n\t\t\tchunk: c.chunks[0],\n\t\t\tchunkGroup: c\n\t\t});\n\t};\n\n\t// Iterative traversal of the Module graph\n\t// Recursive would be simpler to write but could result in Stack Overflows\n\twhile (queue.length) {\n\t\tlogger.time(\"visiting\");\n\t\twhile (queue.length) {\n\t\t\tconst queueItem = queue.pop();\n\t\t\tmodule = queueItem.module;\n\t\t\tblock = queueItem.block;\n\t\t\tchunk = queueItem.chunk;\n\t\t\tif (chunkGroup !== queueItem.chunkGroup) {\n\t\t\t\tchunkGroup = queueItem.chunkGroup;\n\t\t\t\tconst chunkGroupInfo = chunkGroupInfoMap.get(chunkGroup);\n\t\t\t\tminAvailableModules = chunkGroupInfo.minAvailableModules;\n\t\t\t\tskippedItems = chunkGroupInfo.skippedItems;\n\t\t\t}\n\n\t\t\tswitch (queueItem.action) {\n\t\t\t\tcase ADD_AND_ENTER_MODULE: {\n\t\t\t\t\tif (minAvailableModules.has(module)) {\n\t\t\t\t\t\t// already in parent chunks\n\t\t\t\t\t\t// skip it for now, but enqueue for rechecking when minAvailableModules shrinks\n\t\t\t\t\t\tskippedItems.push(queueItem);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// We connect Module and Chunk when not already done\n\t\t\t\t\tif (chunk.addModule(module)) {\n\t\t\t\t\t\tmodule.addChunk(chunk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// already connected, skip it\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase ENTER_MODULE: {\n\t\t\t\t\tif (chunkGroup !== undefined) {\n\t\t\t\t\t\tconst index = chunkGroup.getModuleIndex(module);\n\t\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\t\tchunkGroup.setModuleIndex(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\tchunkGroupCounters.get(chunkGroup).index++\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (module.index === null) {\n\t\t\t\t\t\tmodule.index = nextFreeModuleIndex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\taction: LEAVE_MODULE,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tchunkGroup\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase PROCESS_BLOCK: {\n\t\t\t\t\t// get prepared block info\n\t\t\t\t\tconst blockInfo = blockInfoMap.get(block);\n\n\t\t\t\t\t// Buffer items because order need to be reverse to get indicies correct\n\t\t\t\t\tconst skipBuffer = [];\n\t\t\t\t\tconst queueBuffer = [];\n\t\t\t\t\t// Traverse all referenced modules\n\t\t\t\t\tfor (const refModule of blockInfo.modules) {\n\t\t\t\t\t\tif (chunk.containsModule(refModule)) {\n\t\t\t\t\t\t\t// skip early if already connected\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (minAvailableModules.has(refModule)) {\n\t\t\t\t\t\t\t// already in parent chunks, skip it for now\n\t\t\t\t\t\t\tskipBuffer.push({\n\t\t\t\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\t\t\t\tblock: refModule,\n\t\t\t\t\t\t\t\tmodule: refModule,\n\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\tchunkGroup\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// enqueue the add and enter to enter in the correct order\n\t\t\t\t\t\t// this is relevant with circular dependencies\n\t\t\t\t\t\tqueueBuffer.push({\n\t\t\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\t\t\tblock: refModule,\n\t\t\t\t\t\t\tmodule: refModule,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tchunkGroup\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t// Add buffered items in reversed order\n\t\t\t\t\tfor (let i = skipBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tskippedItems.push(skipBuffer[i]);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = queueBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tqueue.push(queueBuffer[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Traverse all Blocks\n\t\t\t\t\tfor (const block of blockInfo.blocks) iteratorBlock(block);\n\n\t\t\t\t\tif (blockInfo.blocks.length > 0 && module !== block) {\n\t\t\t\t\t\tblocksWithNestedBlocks.add(block);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase LEAVE_MODULE: {\n\t\t\t\t\tif (chunkGroup !== undefined) {\n\t\t\t\t\t\tconst index = chunkGroup.getModuleIndex2(module);\n\t\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\t\tchunkGroup.setModuleIndex2(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\tchunkGroupCounters.get(chunkGroup).index2++\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (module.index2 === null) {\n\t\t\t\t\t\tmodule.index2 = nextFreeModuleIndex2++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlogger.timeEnd(\"visiting\");\n\n\t\twhile (queueConnect.size > 0) {\n\t\t\tlogger.time(\"calculating available modules\");\n\n\t\t\t// Figure out new parents for chunk groups\n\t\t\t// to get new available modules for these children\n\t\t\tfor (const [chunkGroup, targets] of queueConnect) {\n\t\t\t\tconst info = chunkGroupInfoMap.get(chunkGroup);\n\t\t\t\tlet minAvailableModules = info.minAvailableModules;\n\n\t\t\t\t// 1. Create a new Set of available modules at this points\n\t\t\t\tconst resultingAvailableModules = new Set(minAvailableModules);\n\t\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\t\tfor (const m of chunk.modulesIterable) {\n\t\t\t\t\t\tresultingAvailableModules.add(m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinfo.resultingAvailableModules = resultingAvailableModules;\n\t\t\t\tif (info.children === undefined) {\n\t\t\t\t\tinfo.children = targets;\n\t\t\t\t} else {\n\t\t\t\t\tfor (const target of targets) {\n\t\t\t\t\t\tinfo.children.add(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 2. Update chunk group info\n\t\t\t\tfor (const target of targets) {\n\t\t\t\t\tlet chunkGroupInfo = chunkGroupInfoMap.get(target);\n\t\t\t\t\tif (chunkGroupInfo === undefined) {\n\t\t\t\t\t\tchunkGroupInfo = {\n\t\t\t\t\t\t\tchunkGroup: target,\n\t\t\t\t\t\t\tminAvailableModules: undefined,\n\t\t\t\t\t\t\tminAvailableModulesOwned: undefined,\n\t\t\t\t\t\t\tavailableModulesToBeMerged: [],\n\t\t\t\t\t\t\tskippedItems: [],\n\t\t\t\t\t\t\tresultingAvailableModules: undefined,\n\t\t\t\t\t\t\tchildren: undefined\n\t\t\t\t\t\t};\n\t\t\t\t\t\tchunkGroupInfoMap.set(target, chunkGroupInfo);\n\t\t\t\t\t}\n\t\t\t\t\tchunkGroupInfo.availableModulesToBeMerged.push(\n\t\t\t\t\t\tresultingAvailableModules\n\t\t\t\t\t);\n\t\t\t\t\toutdatedChunkGroupInfo.add(chunkGroupInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueueConnect.clear();\n\t\t\tlogger.timeEnd(\"calculating available modules\");\n\n\t\t\tif (outdatedChunkGroupInfo.size > 0) {\n\t\t\t\tlogger.time(\"merging available modules\");\n\t\t\t\t// Execute the merge\n\t\t\t\tfor (const info of outdatedChunkGroupInfo) {\n\t\t\t\t\tconst availableModulesToBeMerged = info.availableModulesToBeMerged;\n\t\t\t\t\tlet cachedMinAvailableModules = info.minAvailableModules;\n\n\t\t\t\t\t// 1. Get minimal available modules\n\t\t\t\t\t// It doesn't make sense to traverse a chunk again with more available modules.\n\t\t\t\t\t// This step calculates the minimal available modules and skips traversal when\n\t\t\t\t\t// the list didn't shrink.\n\t\t\t\t\tif (availableModulesToBeMerged.length > 1) {\n\t\t\t\t\t\tavailableModulesToBeMerged.sort(bySetSize);\n\t\t\t\t\t}\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\tfor (const availableModules of availableModulesToBeMerged) {\n\t\t\t\t\t\tif (cachedMinAvailableModules === undefined) {\n\t\t\t\t\t\t\tcachedMinAvailableModules = availableModules;\n\t\t\t\t\t\t\tinfo.minAvailableModules = cachedMinAvailableModules;\n\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = false;\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (info.minAvailableModulesOwned) {\n\t\t\t\t\t\t\t\t// We own it and can modify it\n\t\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\t\t\tif (!availableModules.has(m)) {\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.delete(m);\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\t\t\tif (!availableModules.has(m)) {\n\t\t\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\n\t\t\t\t\t\t\t\t\t\t// but we don't own it\n\t\t\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\t\t\t\t\t\t\tconst newSet = new Set();\n\t\t\t\t\t\t\t\t\t\tconst iterator = cachedMinAvailableModules[\n\t\t\t\t\t\t\t\t\t\t\tSymbol.iterator\n\t\t\t\t\t\t\t\t\t\t]();\n\t\t\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\t\t\tif (availableModules.has(module)) {\n\t\t\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\n\t\t\t\t\t\t\t\t\t\t// Update the cache from the first queue\n\t\t\t\t\t\t\t\t\t\t// if the chunkGroup is currently cached\n\t\t\t\t\t\t\t\t\t\tif (chunkGroup === info.chunkGroup) {\n\t\t\t\t\t\t\t\t\t\t\tminAvailableModules = cachedMinAvailableModules;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tavailableModulesToBeMerged.length = 0;\n\t\t\t\t\tif (!changed) continue;\n\n\t\t\t\t\t// 2. Reconsider skipped items\n\t\t\t\t\tfor (const queueItem of info.skippedItems) {\n\t\t\t\t\t\tqueue.push(queueItem);\n\t\t\t\t\t}\n\t\t\t\t\tinfo.skippedItems.length = 0;\n\n\t\t\t\t\t// 3. Reconsider children chunk groups\n\t\t\t\t\tif (info.children !== undefined) {\n\t\t\t\t\t\tconst chunkGroup = info.chunkGroup;\n\t\t\t\t\t\tfor (const c of info.children) {\n\t\t\t\t\t\t\tlet connectList = queueConnect.get(chunkGroup);\n\t\t\t\t\t\t\tif (connectList === undefined) {\n\t\t\t\t\t\t\t\tconnectList = new Set();\n\t\t\t\t\t\t\t\tqueueConnect.set(chunkGroup, connectList);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconnectList.add(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toutdatedChunkGroupInfo.clear();\n\t\t\t\tlogger.timeEnd(\"merging available modules\");\n\t\t\t}\n\t\t}\n\n\t\t// Run queueDelayed when all items of the queue are processed\n\t\t// This is important to get the global indicing correct\n\t\t// Async blocks should be processed after all sync blocks are processed\n\t\tif (queue.length === 0) {\n\t\t\tconst tempQueue = queue;\n\t\t\tqueue = queueDelayed.reverse();\n\t\t\tqueueDelayed = tempQueue;\n\t\t}\n\t}\n};\n\n/**\n *\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<ChunkGroup, ChunkGroupDep[]>} chunkDependencies dependencies for chunk groups\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\nconst connectChunkGroups = (\n\tblocksWithNestedBlocks,\n\tchunkDependencies,\n\tchunkGroupInfoMap\n) => {\n\t/** @type {Set<Module>} */\n\tlet resultingAvailableModules;\n\n\t/**\n\t * Helper function to check if all modules of a chunk are available\n\t *\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n\t * @param {Set<Module>} availableModules the comparitor set\n\t * @returns {boolean} return true if all modules of a chunk are available\n\t */\n\tconst areModulesAvailable = (chunkGroup, availableModules) => {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tfor (const module of chunk.modulesIterable) {\n\t\t\t\tif (!availableModules.has(module)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t// For each edge in the basic chunk graph\n\t/**\n\t * @param {ChunkGroupDep} dep the dependency used for filtering\n\t * @returns {boolean} used to filter \"edges\" (aka Dependencies) that were pointing\n\t * to modules that are already available. Also filters circular dependencies in the chunks graph\n\t */\n\tconst filterFn = dep => {\n\t\tconst depChunkGroup = dep.chunkGroup;\n\t\t// TODO is this needed?\n\t\tif (blocksWithNestedBlocks.has(dep.block)) return true;\n\t\tif (areModulesAvailable(depChunkGroup, resultingAvailableModules)) {\n\t\t\treturn false; // break all modules are already available\n\t\t}\n\t\treturn true;\n\t};\n\n\t// For all deps, check if chunk groups need to be connected\n\tfor (const [chunkGroup, deps] of chunkDependencies) {\n\t\tif (deps.length === 0) continue;\n\n\t\t// 1. Get info from chunk group info map\n\t\tconst info = chunkGroupInfoMap.get(chunkGroup);\n\t\tresultingAvailableModules = info.resultingAvailableModules;\n\n\t\t// 2. Foreach edge\n\t\tfor (let i = 0; i < deps.length; i++) {\n\t\t\tconst dep = deps[i];\n\n\t\t\t// Filter inline, rather than creating a new array from `.filter()`\n\t\t\t// TODO check if inlining filterFn makes sense here\n\t\t\tif (!filterFn(dep)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst depChunkGroup = dep.chunkGroup;\n\t\t\tconst depBlock = dep.block;\n\n\t\t\t// 5. Connect block with chunk\n\t\t\tGraphHelpers.connectDependenciesBlockAndChunkGroup(\n\t\t\t\tdepBlock,\n\t\t\t\tdepChunkGroup\n\t\t\t);\n\n\t\t\t// 6. Connect chunk with parent\n\t\t\tGraphHelpers.connectChunkGroupParentAndChild(chunkGroup, depChunkGroup);\n\t\t}\n\t}\n};\n\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n\tfor (const chunkGroup of allCreatedChunkGroups) {\n\t\tif (chunkGroup.getNumberOfParents() === 0) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tconst idx = compilation.chunks.indexOf(chunk);\n\t\t\t\tif (idx >= 0) compilation.chunks.splice(idx, 1);\n\t\t\t\tchunk.remove(\"unconnected\");\n\t\t\t}\n\t\t\tchunkGroup.remove(\"unconnected\");\n\t\t}\n\t}\n};\n\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups chunk groups which are processed\n * @returns {void}\n */\nconst buildChunkGraph = (compilation, inputChunkGroups) => {\n\t// SHARED STATE\n\n\t/** @type {Map<ChunkGroup, ChunkGroupDep[]>} */\n\tconst chunkDependencies = new Map();\n\n\t/** @type {Set<ChunkGroup>} */\n\tconst allCreatedChunkGroups = new Set();\n\n\t/** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n\tconst chunkGroupInfoMap = new Map();\n\n\t/** @type {Set<DependenciesBlock>} */\n\tconst blocksWithNestedBlocks = new Set();\n\n\t// PART ONE\n\n\tvisitModules(\n\t\tcompilation,\n\t\tinputChunkGroups,\n\t\tchunkGroupInfoMap,\n\t\tchunkDependencies,\n\t\tblocksWithNestedBlocks,\n\t\tallCreatedChunkGroups\n\t);\n\n\t// PART TWO\n\n\tconnectChunkGroups(\n\t\tblocksWithNestedBlocks,\n\t\tchunkDependencies,\n\t\tchunkGroupInfoMap\n\t);\n\n\t// Cleaup work\n\n\tcleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n};\n\nmodule.exports = buildChunkGraph;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}