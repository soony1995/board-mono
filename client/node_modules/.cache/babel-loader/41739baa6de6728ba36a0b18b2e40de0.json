{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar Source = require(\"./Source\");\nvar SourceNode = require(\"source-map\").SourceNode;\nclass Replacement {\n  constructor(start, end, content, insertIndex, name) {\n    this.start = start;\n    this.end = end;\n    this.content = content;\n    this.insertIndex = insertIndex;\n    this.name = name;\n  }\n}\nclass ReplaceSource extends Source {\n  constructor(source, name) {\n    super();\n    this._source = source;\n    this._name = name;\n    /** @type {Replacement[]} */\n    this.replacements = [];\n  }\n  replace(start, end, newValue, name) {\n    if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue);\n    this.replacements.push(new Replacement(start, end, newValue, this.replacements.length, name));\n  }\n  insert(pos, newValue, name) {\n    if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue + \": \" + newValue);\n    this.replacements.push(new Replacement(pos, pos - 1, newValue, this.replacements.length, name));\n  }\n  source(options) {\n    return this._replaceString(this._source.source());\n  }\n  original() {\n    return this._source;\n  }\n  _sortReplacements() {\n    this.replacements.sort(function (a, b) {\n      var diff = b.end - a.end;\n      if (diff !== 0) return diff;\n      diff = b.start - a.start;\n      if (diff !== 0) return diff;\n      return b.insertIndex - a.insertIndex;\n    });\n  }\n  _replaceString(str) {\n    if (typeof str !== \"string\") throw new Error(\"str must be a string, but is a \" + typeof str + \": \" + str);\n    this._sortReplacements();\n    var result = [str];\n    this.replacements.forEach(function (repl) {\n      var remSource = result.pop();\n      var splitted1 = this._splitString(remSource, Math.floor(repl.end + 1));\n      var splitted2 = this._splitString(splitted1[0], Math.floor(repl.start));\n      result.push(splitted1[1], repl.content, splitted2[0]);\n    }, this);\n\n    // write out result array in reverse order\n    let resultStr = \"\";\n    for (let i = result.length - 1; i >= 0; --i) {\n      resultStr += result[i];\n    }\n    return resultStr;\n  }\n  node(options) {\n    var node = this._source.node(options);\n    if (this.replacements.length === 0) {\n      return node;\n    }\n    this._sortReplacements();\n    var replace = new ReplacementEnumerator(this.replacements);\n    var output = [];\n    var position = 0;\n    var sources = Object.create(null);\n    var sourcesInLines = Object.create(null);\n\n    // We build a new list of SourceNodes in \"output\"\n    // from the original mapping data\n\n    var result = new SourceNode();\n\n    // We need to add source contents manually\n    // because \"walk\" will not handle it\n    node.walkSourceContents(function (sourceFile, sourceContent) {\n      result.setSourceContent(sourceFile, sourceContent);\n      sources[\"$\" + sourceFile] = sourceContent;\n    });\n    var replaceInStringNode = this._replaceInStringNode.bind(this, output, replace, function getOriginalSource(mapping) {\n      var key = \"$\" + mapping.source;\n      var lines = sourcesInLines[key];\n      if (!lines) {\n        var source = sources[key];\n        if (!source) return null;\n        lines = source.split(\"\\n\").map(function (line) {\n          return line + \"\\n\";\n        });\n        sourcesInLines[key] = lines;\n      }\n      // line is 1-based\n      if (mapping.line > lines.length) return null;\n      var line = lines[mapping.line - 1];\n      return line.substr(mapping.column);\n    });\n    node.walk(function (chunk, mapping) {\n      position = replaceInStringNode(chunk, position, mapping);\n    });\n\n    // If any replacements occur after the end of the original file, then we append them\n    // directly to the end of the output\n    var remaining = replace.footer();\n    if (remaining) {\n      output.push(remaining);\n    }\n    result.add(output);\n    return result;\n  }\n  listMap(options) {\n    this._sortReplacements();\n    var map = this._source.listMap(options);\n    var currentIndex = 0;\n    var replacements = this.replacements;\n    var idxReplacement = replacements.length - 1;\n    var removeChars = 0;\n    map = map.mapGeneratedCode(function (str) {\n      var newCurrentIndex = currentIndex + str.length;\n      if (removeChars > str.length) {\n        removeChars -= str.length;\n        str = \"\";\n      } else {\n        if (removeChars > 0) {\n          str = str.substr(removeChars);\n          currentIndex += removeChars;\n          removeChars = 0;\n        }\n        var finalStr = \"\";\n        while (idxReplacement >= 0 && replacements[idxReplacement].start < newCurrentIndex) {\n          var repl = replacements[idxReplacement];\n          var start = Math.floor(repl.start);\n          var end = Math.floor(repl.end + 1);\n          var before = str.substr(0, Math.max(0, start - currentIndex));\n          if (end <= newCurrentIndex) {\n            var after = str.substr(Math.max(0, end - currentIndex));\n            finalStr += before + repl.content;\n            str = after;\n            currentIndex = Math.max(currentIndex, end);\n          } else {\n            finalStr += before + repl.content;\n            str = \"\";\n            removeChars = end - newCurrentIndex;\n          }\n          idxReplacement--;\n        }\n        str = finalStr + str;\n      }\n      currentIndex = newCurrentIndex;\n      return str;\n    });\n    var extraCode = \"\";\n    while (idxReplacement >= 0) {\n      extraCode += replacements[idxReplacement].content;\n      idxReplacement--;\n    }\n    if (extraCode) {\n      map.add(extraCode);\n    }\n    return map;\n  }\n  _splitString(str, position) {\n    return position <= 0 ? [\"\", str] : [str.substr(0, position), str.substr(position)];\n  }\n  _replaceInStringNode(output, replace, getOriginalSource, node, position, mapping) {\n    var original = undefined;\n    do {\n      var splitPosition = replace.position - position;\n      // If multiple replaces occur in the same location then the splitPosition may be\n      // before the current position for the subsequent splits. Ensure it is >= 0\n      if (splitPosition < 0) {\n        splitPosition = 0;\n      }\n      if (splitPosition >= node.length || replace.done) {\n        if (replace.emit) {\n          var nodeEnd = new SourceNode(mapping.line, mapping.column, mapping.source, node, mapping.name);\n          output.push(nodeEnd);\n        }\n        return position + node.length;\n      }\n      var originalColumn = mapping.column;\n\n      // Try to figure out if generated code matches original code of this segement\n      // If this is the case we assume that it's allowed to move mapping.column\n      // Because getOriginalSource can be expensive we only do it when neccessary\n\n      var nodePart;\n      if (splitPosition > 0) {\n        nodePart = node.slice(0, splitPosition);\n        if (original === undefined) {\n          original = getOriginalSource(mapping);\n        }\n        if (original && original.length >= splitPosition && original.startsWith(nodePart)) {\n          mapping.column += splitPosition;\n          original = original.substr(splitPosition);\n        }\n      }\n      var emit = replace.next();\n      if (!emit) {\n        // Stop emitting when we have found the beginning of the string to replace.\n        // Emit the part of the string before splitPosition\n        if (splitPosition > 0) {\n          var nodeStart = new SourceNode(mapping.line, originalColumn, mapping.source, nodePart, mapping.name);\n          output.push(nodeStart);\n        }\n\n        // Emit the replacement value\n        if (replace.value) {\n          output.push(new SourceNode(mapping.line, mapping.column, mapping.source, replace.value, mapping.name || replace.name));\n        }\n      }\n\n      // Recurse with remainder of the string as there may be multiple replaces within a single node\n      node = node.substr(splitPosition);\n      position += splitPosition;\n    } while (true);\n  }\n}\nclass ReplacementEnumerator {\n  /**\n   * @param {Replacement[]} replacements list of replacements\n   */\n  constructor(replacements) {\n    this.replacements = replacements || [];\n    this.index = this.replacements.length;\n    this.done = false;\n    this.emit = false;\n    // Set initial start position\n    this.next();\n  }\n  next() {\n    if (this.done) return true;\n    if (this.emit) {\n      // Start point found. stop emitting. set position to find end\n      var repl = this.replacements[this.index];\n      var end = Math.floor(repl.end + 1);\n      this.position = end;\n      this.value = repl.content;\n      this.name = repl.name;\n    } else {\n      // End point found. start emitting. set position to find next start\n      this.index--;\n      if (this.index < 0) {\n        this.done = true;\n      } else {\n        var nextRepl = this.replacements[this.index];\n        var start = Math.floor(nextRepl.start);\n        this.position = start;\n      }\n    }\n    if (this.position < 0) this.position = 0;\n    this.emit = !this.emit;\n    return this.emit;\n  }\n  footer() {\n    if (!this.done && !this.emit) this.next(); // If we finished _replaceInNode mid emit we advance to next entry\n    if (this.done) {\n      return [];\n    } else {\n      var resultStr = \"\";\n      for (var i = this.index; i >= 0; i--) {\n        var repl = this.replacements[i];\n        // this doesn't need to handle repl.name, because in SourceMaps generated code\n        // without pointer to original source can't have a name\n        resultStr += repl.content;\n      }\n      return resultStr;\n    }\n  }\n}\nrequire(\"./SourceAndMapMixin\")(ReplaceSource.prototype);\nmodule.exports = ReplaceSource;","map":{"version":3,"names":["Source","require","SourceNode","Replacement","constructor","start","end","content","insertIndex","name","ReplaceSource","source","_source","_name","replacements","replace","newValue","Error","push","length","insert","pos","options","_replaceString","original","_sortReplacements","sort","a","b","diff","str","result","forEach","repl","remSource","pop","splitted1","_splitString","Math","floor","splitted2","resultStr","i","node","ReplacementEnumerator","output","position","sources","Object","create","sourcesInLines","walkSourceContents","sourceFile","sourceContent","setSourceContent","replaceInStringNode","_replaceInStringNode","bind","getOriginalSource","mapping","key","lines","split","map","line","substr","column","walk","chunk","remaining","footer","add","listMap","currentIndex","idxReplacement","removeChars","mapGeneratedCode","newCurrentIndex","finalStr","before","max","after","extraCode","undefined","splitPosition","done","emit","nodeEnd","originalColumn","nodePart","slice","startsWith","next","nodeStart","value","index","nextRepl","prototype","module","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack-sources/lib/ReplaceSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar Source = require(\"./Source\");\nvar SourceNode = require(\"source-map\").SourceNode;\n\nclass Replacement {\n\tconstructor(start, end, content, insertIndex, name) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.content = content;\n\t\tthis.insertIndex = insertIndex;\n\t\tthis.name = name;\n\t}\n}\n\nclass ReplaceSource extends Source {\n\tconstructor(source, name) {\n\t\tsuper();\n\t\tthis._source = source;\n\t\tthis._name = name;\n\t\t/** @type {Replacement[]} */\n\t\tthis.replacements = [];\n\t}\n\n\treplace(start, end, newValue, name) {\n\t\tif(typeof newValue !== \"string\")\n\t\t\tthrow new Error(\"insertion must be a string, but is a \" + typeof newValue);\n\t\tthis.replacements.push(new Replacement(start, end, newValue, this.replacements.length, name));\n\t}\n\n\tinsert(pos, newValue, name) {\n\t\tif(typeof newValue !== \"string\")\n\t\t\tthrow new Error(\"insertion must be a string, but is a \" + typeof newValue + \": \" + newValue);\n\t\tthis.replacements.push(new Replacement(pos, pos - 1, newValue, this.replacements.length, name));\n\t}\n\n\tsource(options) {\n\t\treturn this._replaceString(this._source.source());\n\t}\n\n\toriginal() {\n\t\treturn this._source;\n\t}\n\n\t_sortReplacements() {\n\t\tthis.replacements.sort(function(a, b) {\n\t\t\tvar diff = b.end - a.end;\n\t\t\tif(diff !== 0)\n\t\t\t\treturn diff;\n\t\t\tdiff = b.start - a.start;\n\t\t\tif(diff !== 0)\n\t\t\t\treturn diff;\n\t\t\treturn b.insertIndex - a.insertIndex;\n\t\t});\n\t}\n\n\t_replaceString(str) {\n\t\tif(typeof str !== \"string\")\n\t\t\tthrow new Error(\"str must be a string, but is a \" + typeof str + \": \" + str);\n\t\tthis._sortReplacements();\n\t\tvar result = [str];\n\t\tthis.replacements.forEach(function(repl) {\n\t\t\tvar remSource = result.pop();\n\t\t\tvar splitted1 = this._splitString(remSource, Math.floor(repl.end + 1));\n\t\t\tvar splitted2 = this._splitString(splitted1[0], Math.floor(repl.start));\n\t\t\tresult.push(splitted1[1], repl.content, splitted2[0]);\n\t\t}, this);\n\n\t\t// write out result array in reverse order\n\t\tlet resultStr = \"\";\n\t\tfor(let i = result.length - 1; i >= 0; --i) {\n\t\t\tresultStr += result[i];\n\t\t}\n\t\treturn resultStr;\n\t}\n\n\tnode(options) {\n\t\tvar node = this._source.node(options);\n\t\tif(this.replacements.length === 0) {\n\t\t\treturn node;\n\t\t}\n\t\tthis._sortReplacements();\n\t\tvar replace = new ReplacementEnumerator(this.replacements);\n\t\tvar output = [];\n\t\tvar position = 0;\n\t\tvar sources = Object.create(null);\n\t\tvar sourcesInLines = Object.create(null);\n\n\t\t// We build a new list of SourceNodes in \"output\"\n\t\t// from the original mapping data\n\n\t\tvar result = new SourceNode();\n\n\t\t// We need to add source contents manually\n\t\t// because \"walk\" will not handle it\n\t\tnode.walkSourceContents(function(sourceFile, sourceContent) {\n\t\t\tresult.setSourceContent(sourceFile, sourceContent);\n\t\t\tsources[\"$\" + sourceFile] = sourceContent;\n\t\t});\n\n\t\tvar replaceInStringNode = this._replaceInStringNode.bind(this, output, replace, function getOriginalSource(mapping) {\n\t\t\tvar key = \"$\" + mapping.source;\n\t\t\tvar lines = sourcesInLines[key];\n\t\t\tif(!lines) {\n\t\t\t\tvar source = sources[key];\n\t\t\t\tif(!source) return null;\n\t\t\t\tlines = source.split(\"\\n\").map(function(line) {\n\t\t\t\t\treturn line + \"\\n\";\n\t\t\t\t});\n\t\t\t\tsourcesInLines[key] = lines;\n\t\t\t}\n\t\t\t// line is 1-based\n\t\t\tif(mapping.line > lines.length) return null;\n\t\t\tvar line = lines[mapping.line - 1];\n\t\t\treturn line.substr(mapping.column);\n\t\t});\n\n\t\tnode.walk(function(chunk, mapping) {\n\t\t\tposition = replaceInStringNode(chunk, position, mapping);\n\t\t});\n\n\t\t// If any replacements occur after the end of the original file, then we append them\n\t\t// directly to the end of the output\n\t\tvar remaining = replace.footer();\n\t\tif(remaining) {\n\t\t\toutput.push(remaining);\n\t\t}\n\n\t\tresult.add(output);\n\n\t\treturn result;\n\t}\n\n\tlistMap(options) {\n\t\tthis._sortReplacements();\n\t\tvar map = this._source.listMap(options);\n\t\tvar currentIndex = 0;\n\t\tvar replacements = this.replacements;\n\t\tvar idxReplacement = replacements.length - 1;\n\t\tvar removeChars = 0;\n\t\tmap = map.mapGeneratedCode(function(str) {\n\t\t\tvar newCurrentIndex = currentIndex + str.length;\n\t\t\tif(removeChars > str.length) {\n\t\t\t\tremoveChars -= str.length;\n\t\t\t\tstr = \"\";\n\t\t\t} else {\n\t\t\t\tif(removeChars > 0) {\n\t\t\t\t\tstr = str.substr(removeChars);\n\t\t\t\t\tcurrentIndex += removeChars;\n\t\t\t\t\tremoveChars = 0;\n\t\t\t\t}\n\t\t\t\tvar finalStr = \"\";\n\t\t\t\twhile(idxReplacement >= 0 && replacements[idxReplacement].start < newCurrentIndex) {\n\t\t\t\t\tvar repl = replacements[idxReplacement];\n\t\t\t\t\tvar start = Math.floor(repl.start);\n\t\t\t\t\tvar end = Math.floor(repl.end + 1);\n\t\t\t\t\tvar before = str.substr(0, Math.max(0, start - currentIndex));\n\t\t\t\t\tif(end <= newCurrentIndex) {\n\t\t\t\t\t\tvar after = str.substr(Math.max(0, end - currentIndex));\n\t\t\t\t\t\tfinalStr += before + repl.content;\n\t\t\t\t\t\tstr = after;\n\t\t\t\t\t\tcurrentIndex = Math.max(currentIndex, end);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfinalStr += before + repl.content;\n\t\t\t\t\t\tstr = \"\";\n\t\t\t\t\t\tremoveChars = end - newCurrentIndex;\n\t\t\t\t\t}\n\t\t\t\t\tidxReplacement--;\n\t\t\t\t}\n\t\t\t\tstr = finalStr + str;\n\t\t\t}\n\t\t\tcurrentIndex = newCurrentIndex;\n\t\t\treturn str;\n\t\t});\n\t\tvar extraCode = \"\";\n\t\twhile(idxReplacement >= 0) {\n\t\t\textraCode += replacements[idxReplacement].content;\n\t\t\tidxReplacement--;\n\t\t}\n\t\tif(extraCode) {\n\t\t\tmap.add(extraCode);\n\t\t}\n\t\treturn map;\n\t}\n\n\t_splitString(str, position) {\n\t\treturn position <= 0 ? [\"\", str] : [str.substr(0, position), str.substr(position)];\n\t}\n\n\t_replaceInStringNode(output, replace, getOriginalSource, node, position, mapping) {\n\t\tvar original = undefined;\n\n\t\tdo {\n\t\t\tvar splitPosition = replace.position - position;\n\t\t\t// If multiple replaces occur in the same location then the splitPosition may be\n\t\t\t// before the current position for the subsequent splits. Ensure it is >= 0\n\t\t\tif(splitPosition < 0) {\n\t\t\t\tsplitPosition = 0;\n\t\t\t}\n\t\t\tif(splitPosition >= node.length || replace.done) {\n\t\t\t\tif(replace.emit) {\n\t\t\t\t\tvar nodeEnd = new SourceNode(\n\t\t\t\t\t\tmapping.line,\n\t\t\t\t\t\tmapping.column,\n\t\t\t\t\t\tmapping.source,\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tmapping.name\n\t\t\t\t\t);\n\t\t\t\t\toutput.push(nodeEnd);\n\t\t\t\t}\n\t\t\t\treturn position + node.length;\n\t\t\t}\n\n\t\t\tvar originalColumn = mapping.column;\n\n\t\t\t// Try to figure out if generated code matches original code of this segement\n\t\t\t// If this is the case we assume that it's allowed to move mapping.column\n\t\t\t// Because getOriginalSource can be expensive we only do it when neccessary\n\n\t\t\tvar nodePart;\n\t\t\tif(splitPosition > 0) {\n\t\t\t\tnodePart = node.slice(0, splitPosition);\n\t\t\t\tif(original === undefined) {\n\t\t\t\t\toriginal = getOriginalSource(mapping);\n\t\t\t\t}\n\t\t\t\tif(original && original.length >= splitPosition && original.startsWith(nodePart)) {\n\t\t\t\t\tmapping.column += splitPosition;\n\t\t\t\t\toriginal = original.substr(splitPosition);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar emit = replace.next();\n\t\t\tif(!emit) {\n\t\t\t\t// Stop emitting when we have found the beginning of the string to replace.\n\t\t\t\t// Emit the part of the string before splitPosition\n\t\t\t\tif(splitPosition > 0) {\n\t\t\t\t\tvar nodeStart = new SourceNode(\n\t\t\t\t\t\tmapping.line,\n\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\tmapping.source,\n\t\t\t\t\t\tnodePart,\n\t\t\t\t\t\tmapping.name\n\t\t\t\t\t);\n\t\t\t\t\toutput.push(nodeStart);\n\t\t\t\t}\n\n\t\t\t\t// Emit the replacement value\n\t\t\t\tif(replace.value) {\n\t\t\t\t\toutput.push(new SourceNode(\n\t\t\t\t\t\tmapping.line,\n\t\t\t\t\t\tmapping.column,\n\t\t\t\t\t\tmapping.source,\n\t\t\t\t\t\treplace.value,\n\t\t\t\t\t\tmapping.name || replace.name\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Recurse with remainder of the string as there may be multiple replaces within a single node\n\t\t\tnode = node.substr(splitPosition);\n\t\t\tposition += splitPosition;\n\t\t} while (true);\n\t}\n}\n\nclass ReplacementEnumerator {\n\t/**\n\t * @param {Replacement[]} replacements list of replacements\n\t */\n\tconstructor(replacements) {\n\t\tthis.replacements = replacements || [];\n\t\tthis.index = this.replacements.length;\n\t\tthis.done = false;\n\t\tthis.emit = false;\n\t\t// Set initial start position\n\t\tthis.next();\n\t}\n\n\tnext() {\n\t\tif(this.done)\n\t\t\treturn true;\n\t\tif(this.emit) {\n\t\t\t// Start point found. stop emitting. set position to find end\n\t\t\tvar repl = this.replacements[this.index];\n\t\t\tvar end = Math.floor(repl.end + 1);\n\t\t\tthis.position = end;\n\t\t\tthis.value = repl.content;\n\t\t\tthis.name = repl.name;\n\t\t} else {\n\t\t\t// End point found. start emitting. set position to find next start\n\t\t\tthis.index--;\n\t\t\tif(this.index < 0) {\n\t\t\t\tthis.done = true;\n\t\t\t} else {\n\t\t\t\tvar nextRepl = this.replacements[this.index];\n\t\t\t\tvar start = Math.floor(nextRepl.start);\n\t\t\t\tthis.position = start;\n\t\t\t}\n\t\t}\n\t\tif(this.position < 0)\n\t\t\tthis.position = 0;\n\t\tthis.emit = !this.emit;\n\t\treturn this.emit;\n\t}\n\n\tfooter() {\n\t\tif(!this.done && !this.emit)\n\t\t\tthis.next(); // If we finished _replaceInNode mid emit we advance to next entry\n\t\tif(this.done) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\tvar resultStr = \"\";\n\t\t\tfor(var i = this.index; i >= 0; i--) {\n\t\t\t\tvar repl = this.replacements[i];\n\t\t\t\t// this doesn't need to handle repl.name, because in SourceMaps generated code\n\t\t\t\t// without pointer to original source can't have a name\n\t\t\t\tresultStr += repl.content;\n\t\t\t}\n\t\t\treturn resultStr;\n\t\t}\n\t}\n}\n\nrequire(\"./SourceAndMapMixin\")(ReplaceSource.prototype);\n\nmodule.exports = ReplaceSource;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}