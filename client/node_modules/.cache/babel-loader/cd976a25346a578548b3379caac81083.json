{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Queue = require(\"../util/Queue\");\nconst {\n  intersect\n} = require(\"../util/SetHelpers\");\nconst getParentChunksWithModule = (currentChunk, module) => {\n  const chunks = [];\n  const stack = new Set(currentChunk.parentsIterable);\n  for (const chunk of stack) {\n    if (chunk.containsModule(module)) {\n      chunks.push(chunk);\n    } else {\n      for (const parent of chunk.parentsIterable) {\n        stack.add(parent);\n      }\n    }\n  }\n  return chunks;\n};\nclass RemoveParentModulesPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", compilation => {\n      const handler = (chunks, chunkGroups) => {\n        const queue = new Queue();\n        const availableModulesMap = new WeakMap();\n        for (const chunkGroup of compilation.entrypoints.values()) {\n          // initialize available modules for chunks without parents\n          availableModulesMap.set(chunkGroup, new Set());\n          for (const child of chunkGroup.childrenIterable) {\n            queue.enqueue(child);\n          }\n        }\n        while (queue.length > 0) {\n          const chunkGroup = queue.dequeue();\n          let availableModules = availableModulesMap.get(chunkGroup);\n          let changed = false;\n          for (const parent of chunkGroup.parentsIterable) {\n            const availableModulesInParent = availableModulesMap.get(parent);\n            if (availableModulesInParent !== undefined) {\n              // If we know the available modules in parent: process these\n              if (availableModules === undefined) {\n                // if we have not own info yet: create new entry\n                availableModules = new Set(availableModulesInParent);\n                for (const chunk of parent.chunks) {\n                  for (const m of chunk.modulesIterable) {\n                    availableModules.add(m);\n                  }\n                }\n                availableModulesMap.set(chunkGroup, availableModules);\n                changed = true;\n              } else {\n                for (const m of availableModules) {\n                  if (!parent.containsModule(m) && !availableModulesInParent.has(m)) {\n                    availableModules.delete(m);\n                    changed = true;\n                  }\n                }\n              }\n            }\n          }\n          if (changed) {\n            // if something changed: enqueue our children\n            for (const child of chunkGroup.childrenIterable) {\n              queue.enqueue(child);\n            }\n          }\n        }\n\n        // now we have available modules for every chunk\n        for (const chunk of chunks) {\n          const availableModulesSets = Array.from(chunk.groupsIterable, chunkGroup => availableModulesMap.get(chunkGroup));\n          if (availableModulesSets.some(s => s === undefined)) continue; // No info about this chunk group\n          const availableModules = availableModulesSets.length === 1 ? availableModulesSets[0] : intersect(availableModulesSets);\n          const numberOfModules = chunk.getNumberOfModules();\n          const toRemove = new Set();\n          if (numberOfModules < availableModules.size) {\n            for (const m of chunk.modulesIterable) {\n              if (availableModules.has(m)) {\n                toRemove.add(m);\n              }\n            }\n          } else {\n            for (const m of availableModules) {\n              if (chunk.containsModule(m)) {\n                toRemove.add(m);\n              }\n            }\n          }\n          for (const module of toRemove) {\n            module.rewriteChunkInReasons(chunk, getParentChunksWithModule(chunk, module));\n            chunk.removeModule(module);\n          }\n        }\n      };\n      compilation.hooks.optimizeChunksBasic.tap(\"RemoveParentModulesPlugin\", handler);\n      compilation.hooks.optimizeExtractedChunksBasic.tap(\"RemoveParentModulesPlugin\", handler);\n    });\n  }\n}\nmodule.exports = RemoveParentModulesPlugin;","map":{"version":3,"names":["Queue","require","intersect","getParentChunksWithModule","currentChunk","module","chunks","stack","Set","parentsIterable","chunk","containsModule","push","parent","add","RemoveParentModulesPlugin","apply","compiler","hooks","compilation","tap","handler","chunkGroups","queue","availableModulesMap","WeakMap","chunkGroup","entrypoints","values","set","child","childrenIterable","enqueue","length","dequeue","availableModules","get","changed","availableModulesInParent","undefined","m","modulesIterable","has","delete","availableModulesSets","Array","from","groupsIterable","some","s","numberOfModules","getNumberOfModules","toRemove","size","rewriteChunkInReasons","removeModule","optimizeChunksBasic","optimizeExtractedChunksBasic","exports"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/optimize/RemoveParentModulesPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Queue = require(\"../util/Queue\");\nconst { intersect } = require(\"../util/SetHelpers\");\n\nconst getParentChunksWithModule = (currentChunk, module) => {\n\tconst chunks = [];\n\tconst stack = new Set(currentChunk.parentsIterable);\n\n\tfor (const chunk of stack) {\n\t\tif (chunk.containsModule(module)) {\n\t\t\tchunks.push(chunk);\n\t\t} else {\n\t\t\tfor (const parent of chunk.parentsIterable) {\n\t\t\t\tstack.add(parent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chunks;\n};\n\nclass RemoveParentModulesPlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", compilation => {\n\t\t\tconst handler = (chunks, chunkGroups) => {\n\t\t\t\tconst queue = new Queue();\n\t\t\t\tconst availableModulesMap = new WeakMap();\n\n\t\t\t\tfor (const chunkGroup of compilation.entrypoints.values()) {\n\t\t\t\t\t// initialize available modules for chunks without parents\n\t\t\t\t\tavailableModulesMap.set(chunkGroup, new Set());\n\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst chunkGroup = queue.dequeue();\n\t\t\t\t\tlet availableModules = availableModulesMap.get(chunkGroup);\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\t\t\t\tconst availableModulesInParent = availableModulesMap.get(parent);\n\t\t\t\t\t\tif (availableModulesInParent !== undefined) {\n\t\t\t\t\t\t\t// If we know the available modules in parent: process these\n\t\t\t\t\t\t\tif (availableModules === undefined) {\n\t\t\t\t\t\t\t\t// if we have not own info yet: create new entry\n\t\t\t\t\t\t\t\tavailableModules = new Set(availableModulesInParent);\n\t\t\t\t\t\t\t\tfor (const chunk of parent.chunks) {\n\t\t\t\t\t\t\t\t\tfor (const m of chunk.modulesIterable) {\n\t\t\t\t\t\t\t\t\t\tavailableModules.add(m);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tavailableModulesMap.set(chunkGroup, availableModules);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!parent.containsModule(m) &&\n\t\t\t\t\t\t\t\t\t\t!availableModulesInParent.has(m)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tavailableModules.delete(m);\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t// if something changed: enqueue our children\n\t\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// now we have available modules for every chunk\n\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\tconst availableModulesSets = Array.from(\n\t\t\t\t\t\tchunk.groupsIterable,\n\t\t\t\t\t\tchunkGroup => availableModulesMap.get(chunkGroup)\n\t\t\t\t\t);\n\t\t\t\t\tif (availableModulesSets.some(s => s === undefined)) continue; // No info about this chunk group\n\t\t\t\t\tconst availableModules =\n\t\t\t\t\t\tavailableModulesSets.length === 1\n\t\t\t\t\t\t\t? availableModulesSets[0]\n\t\t\t\t\t\t\t: intersect(availableModulesSets);\n\t\t\t\t\tconst numberOfModules = chunk.getNumberOfModules();\n\t\t\t\t\tconst toRemove = new Set();\n\t\t\t\t\tif (numberOfModules < availableModules.size) {\n\t\t\t\t\t\tfor (const m of chunk.modulesIterable) {\n\t\t\t\t\t\t\tif (availableModules.has(m)) {\n\t\t\t\t\t\t\t\ttoRemove.add(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\tif (chunk.containsModule(m)) {\n\t\t\t\t\t\t\t\ttoRemove.add(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const module of toRemove) {\n\t\t\t\t\t\tmodule.rewriteChunkInReasons(\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tgetParentChunksWithModule(chunk, module)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tcompilation.hooks.optimizeChunksBasic.tap(\n\t\t\t\t\"RemoveParentModulesPlugin\",\n\t\t\t\thandler\n\t\t\t);\n\t\t\tcompilation.hooks.optimizeExtractedChunksBasic.tap(\n\t\t\t\t\"RemoveParentModulesPlugin\",\n\t\t\t\thandler\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = RemoveParentModulesPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}