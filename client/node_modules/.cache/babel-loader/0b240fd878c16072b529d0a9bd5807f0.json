{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst crypto = require(\"crypto\");\nconst SortableSet = require(\"../util/SortableSet\");\nconst GraphHelpers = require(\"../GraphHelpers\");\nconst {\n  isSubset\n} = require(\"../util/SetHelpers\");\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\nconst contextify = require(\"../util/identifier\").contextify;\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\nconst deterministicGroupingForModules = /** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */deterministicGrouping;\nconst hashFilename = name => {\n  return crypto.createHash(\"md4\").update(name).digest(\"hex\").slice(0, 8);\n};\nconst sortByIdentifier = (a, b) => {\n  if (a.identifier() > b.identifier()) return 1;\n  if (a.identifier() < b.identifier()) return -1;\n  return 0;\n};\nconst getRequests = chunk => {\n  let requests = 0;\n  for (const chunkGroup of chunk.groupsIterable) {\n    requests = Math.max(requests, chunkGroup.chunks.length);\n  }\n  return requests;\n};\nconst getModulesSize = modules => {\n  let sum = 0;\n  for (const m of modules) {\n    sum += m.size();\n  }\n  return sum;\n};\n\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\nconst isOverlap = (a, b) => {\n  for (const item of a) {\n    if (b.has(item)) return true;\n  }\n  return false;\n};\nconst compareEntries = (a, b) => {\n  // 1. by priority\n  const diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n  if (diffPriority) return diffPriority;\n  // 2. by number of chunks\n  const diffCount = a.chunks.size - b.chunks.size;\n  if (diffCount) return diffCount;\n  // 3. by size reduction\n  const aSizeReduce = a.size * (a.chunks.size - 1);\n  const bSizeReduce = b.size * (b.chunks.size - 1);\n  const diffSizeReduce = aSizeReduce - bSizeReduce;\n  if (diffSizeReduce) return diffSizeReduce;\n  // 4. by number of modules (to be able to compare by identifier)\n  const modulesA = a.modules;\n  const modulesB = b.modules;\n  const diff = modulesA.size - modulesB.size;\n  if (diff) return diff;\n  // 5. by module identifiers\n  modulesA.sort();\n  modulesB.sort();\n  const aI = modulesA[Symbol.iterator]();\n  const bI = modulesB[Symbol.iterator]();\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const aItem = aI.next();\n    const bItem = bI.next();\n    if (aItem.done) return 0;\n    const aModuleIdentifier = aItem.value.identifier();\n    const bModuleIdentifier = bItem.value.identifier();\n    if (aModuleIdentifier > bModuleIdentifier) return -1;\n    if (aModuleIdentifier < bModuleIdentifier) return 1;\n  }\n};\nconst compareNumbers = (a, b) => a - b;\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\nconst ALL_CHUNK_FILTER = chunk => true;\nmodule.exports = class SplitChunksPlugin {\n  constructor(options) {\n    this.options = SplitChunksPlugin.normalizeOptions(options);\n  }\n  static normalizeOptions(options = {}) {\n    return {\n      chunksFilter: SplitChunksPlugin.normalizeChunksFilter(options.chunks || \"all\"),\n      minSize: options.minSize || 0,\n      maxSize: options.maxSize || 0,\n      minChunks: options.minChunks || 1,\n      maxAsyncRequests: options.maxAsyncRequests || 1,\n      maxInitialRequests: options.maxInitialRequests || 1,\n      hidePathInfo: options.hidePathInfo || false,\n      filename: options.filename || undefined,\n      getCacheGroups: SplitChunksPlugin.normalizeCacheGroups({\n        cacheGroups: options.cacheGroups,\n        name: options.name,\n        automaticNameDelimiter: options.automaticNameDelimiter,\n        automaticNameMaxLength: options.automaticNameMaxLength\n      }),\n      automaticNameDelimiter: options.automaticNameDelimiter,\n      automaticNameMaxLength: options.automaticNameMaxLength || 109,\n      fallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(options.fallbackCacheGroup || {}, options)\n    };\n  }\n  static normalizeName({\n    name,\n    automaticNameDelimiter,\n    automaticNamePrefix,\n    automaticNameMaxLength\n  }) {\n    if (name === true) {\n      /** @type {WeakMap<Chunk[], Record<string, string>>} */\n      const cache = new WeakMap();\n      const fn = (module, chunks, cacheGroup) => {\n        let cacheEntry = cache.get(chunks);\n        if (cacheEntry === undefined) {\n          cacheEntry = {};\n          cache.set(chunks, cacheEntry);\n        } else if (cacheGroup in cacheEntry) {\n          return cacheEntry[cacheGroup];\n        }\n        const names = chunks.map(c => c.name);\n        if (!names.every(Boolean)) {\n          cacheEntry[cacheGroup] = undefined;\n          return;\n        }\n        names.sort();\n        const prefix = typeof automaticNamePrefix === \"string\" ? automaticNamePrefix : cacheGroup;\n        const namePrefix = prefix ? prefix + automaticNameDelimiter : \"\";\n        let name = namePrefix + names.join(automaticNameDelimiter);\n        // Filenames and paths can't be too long otherwise an\n        // ENAMETOOLONG error is raised. If the generated name if too\n        // long, it is truncated and a hash is appended. The limit has\n        // been set to 109 to prevent `[name].[chunkhash].[ext]` from\n        // generating a 256+ character string.\n        if (name.length > automaticNameMaxLength) {\n          const hashedFilename = hashFilename(name);\n          const sliceLength = automaticNameMaxLength - (automaticNameDelimiter.length + hashedFilename.length);\n          name = name.slice(0, sliceLength) + automaticNameDelimiter + hashedFilename;\n        }\n        cacheEntry[cacheGroup] = name;\n        return name;\n      };\n      return fn;\n    }\n    if (typeof name === \"string\") {\n      const fn = () => {\n        return name;\n      };\n      return fn;\n    }\n    if (typeof name === \"function\") return name;\n  }\n  static normalizeChunksFilter(chunks) {\n    if (chunks === \"initial\") {\n      return INITIAL_CHUNK_FILTER;\n    }\n    if (chunks === \"async\") {\n      return ASYNC_CHUNK_FILTER;\n    }\n    if (chunks === \"all\") {\n      return ALL_CHUNK_FILTER;\n    }\n    if (typeof chunks === \"function\") return chunks;\n  }\n  static normalizeFallbackCacheGroup({\n    minSize = undefined,\n    maxSize = undefined,\n    automaticNameDelimiter = undefined\n  }, {\n    minSize: defaultMinSize = undefined,\n    maxSize: defaultMaxSize = undefined,\n    automaticNameDelimiter: defaultAutomaticNameDelimiter = undefined\n  }) {\n    return {\n      minSize: typeof minSize === \"number\" ? minSize : defaultMinSize || 0,\n      maxSize: typeof maxSize === \"number\" ? maxSize : defaultMaxSize || 0,\n      automaticNameDelimiter: automaticNameDelimiter || defaultAutomaticNameDelimiter || \"~\"\n    };\n  }\n  static normalizeCacheGroups({\n    cacheGroups,\n    name,\n    automaticNameDelimiter,\n    automaticNameMaxLength\n  }) {\n    if (typeof cacheGroups === \"function\") {\n      // TODO webpack 5 remove this\n      if (cacheGroups.length !== 1) {\n        return module => cacheGroups(module, module.getChunks());\n      }\n      return cacheGroups;\n    }\n    if (cacheGroups && typeof cacheGroups === \"object\") {\n      const fn = module => {\n        let results;\n        for (const key of Object.keys(cacheGroups)) {\n          let option = cacheGroups[key];\n          if (option === false) continue;\n          if (option instanceof RegExp || typeof option === \"string\") {\n            option = {\n              test: option\n            };\n          }\n          if (typeof option === \"function\") {\n            let result = option(module);\n            if (result) {\n              if (results === undefined) results = [];\n              for (const r of Array.isArray(result) ? result : [result]) {\n                const result = Object.assign({\n                  key\n                }, r);\n                if (result.name) result.getName = () => result.name;\n                if (result.chunks) {\n                  result.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(result.chunks);\n                }\n                results.push(result);\n              }\n            }\n          } else if (SplitChunksPlugin.checkTest(option.test, module)) {\n            if (results === undefined) results = [];\n            results.push({\n              key: key,\n              priority: option.priority,\n              getName: SplitChunksPlugin.normalizeName({\n                name: option.name || name,\n                automaticNameDelimiter: typeof option.automaticNameDelimiter === \"string\" ? option.automaticNameDelimiter : automaticNameDelimiter,\n                automaticNamePrefix: option.automaticNamePrefix,\n                automaticNameMaxLength: option.automaticNameMaxLength || automaticNameMaxLength\n              }) || (() => {}),\n              chunksFilter: SplitChunksPlugin.normalizeChunksFilter(option.chunks),\n              enforce: option.enforce,\n              minSize: option.minSize,\n              maxSize: option.maxSize,\n              minChunks: option.minChunks,\n              maxAsyncRequests: option.maxAsyncRequests,\n              maxInitialRequests: option.maxInitialRequests,\n              filename: option.filename,\n              reuseExistingChunk: option.reuseExistingChunk\n            });\n          }\n        }\n        return results;\n      };\n      return fn;\n    }\n    const fn = () => {};\n    return fn;\n  }\n  static checkTest(test, module) {\n    if (test === undefined) return true;\n    if (typeof test === \"function\") {\n      if (test.length !== 1) {\n        return test(module, module.getChunks());\n      }\n      return test(module);\n    }\n    if (typeof test === \"boolean\") return test;\n    if (typeof test === \"string\") {\n      if (module.nameForCondition && module.nameForCondition().startsWith(test)) {\n        return true;\n      }\n      for (const chunk of module.chunksIterable) {\n        if (chunk.name && chunk.name.startsWith(test)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    if (test instanceof RegExp) {\n      if (module.nameForCondition && test.test(module.nameForCondition())) {\n        return true;\n      }\n      for (const chunk of module.chunksIterable) {\n        if (chunk.name && test.test(chunk.name)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return false;\n  }\n\n  /**\n   * @param {Compiler} compiler webpack compiler\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n      let alreadyOptimized = false;\n      compilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n        alreadyOptimized = false;\n      });\n      compilation.hooks.optimizeChunksAdvanced.tap(\"SplitChunksPlugin\", chunks => {\n        if (alreadyOptimized) return;\n        alreadyOptimized = true;\n        // Give each selected chunk an index (to create strings from chunks)\n        const indexMap = new Map();\n        let index = 1;\n        for (const chunk of chunks) {\n          indexMap.set(chunk, index++);\n        }\n        const getKey = chunks => {\n          return Array.from(chunks, c => indexMap.get(c)).sort(compareNumbers).join();\n        };\n        /** @type {Map<string, Set<Chunk>>} */\n        const chunkSetsInGraph = new Map();\n        for (const module of compilation.modules) {\n          const chunksKey = getKey(module.chunksIterable);\n          if (!chunkSetsInGraph.has(chunksKey)) {\n            chunkSetsInGraph.set(chunksKey, new Set(module.chunksIterable));\n          }\n        }\n\n        // group these set of chunks by count\n        // to allow to check less sets via isSubset\n        // (only smaller sets can be subset)\n        /** @type {Map<number, Array<Set<Chunk>>>} */\n        const chunkSetsByCount = new Map();\n        for (const chunksSet of chunkSetsInGraph.values()) {\n          const count = chunksSet.size;\n          let array = chunkSetsByCount.get(count);\n          if (array === undefined) {\n            array = [];\n            chunkSetsByCount.set(count, array);\n          }\n          array.push(chunksSet);\n        }\n\n        // Create a list of possible combinations\n        const combinationsCache = new Map(); // Map<string, Set<Chunk>[]>\n\n        const getCombinations = key => {\n          const chunksSet = chunkSetsInGraph.get(key);\n          var array = [chunksSet];\n          if (chunksSet.size > 1) {\n            for (const [count, setArray] of chunkSetsByCount) {\n              // \"equal\" is not needed because they would have been merge in the first step\n              if (count < chunksSet.size) {\n                for (const set of setArray) {\n                  if (isSubset(chunksSet, set)) {\n                    array.push(set);\n                  }\n                }\n              }\n            }\n          }\n          return array;\n        };\n\n        /**\n         * @typedef {Object} SelectedChunksResult\n         * @property {Chunk[]} chunks the list of chunks\n         * @property {string} key a key of the list\n         */\n\n        /**\n         * @typedef {function(Chunk): boolean} ChunkFilterFunction\n         */\n\n        /** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n        const selectedChunksCacheByChunksSet = new WeakMap();\n\n        /**\n         * get list and key by applying the filter function to the list\n         * It is cached for performance reasons\n         * @param {Set<Chunk>} chunks list of chunks\n         * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n         * @returns {SelectedChunksResult} list and key\n         */\n        const getSelectedChunks = (chunks, chunkFilter) => {\n          let entry = selectedChunksCacheByChunksSet.get(chunks);\n          if (entry === undefined) {\n            entry = new WeakMap();\n            selectedChunksCacheByChunksSet.set(chunks, entry);\n          }\n          /** @type {SelectedChunksResult} */\n          let entry2 = entry.get(chunkFilter);\n          if (entry2 === undefined) {\n            /** @type {Chunk[]} */\n            const selectedChunks = [];\n            for (const chunk of chunks) {\n              if (chunkFilter(chunk)) selectedChunks.push(chunk);\n            }\n            entry2 = {\n              chunks: selectedChunks,\n              key: getKey(selectedChunks)\n            };\n            entry.set(chunkFilter, entry2);\n          }\n          return entry2;\n        };\n\n        /**\n         * @typedef {Object} ChunksInfoItem\n         * @property {SortableSet} modules\n         * @property {TODO} cacheGroup\n         * @property {string} name\n         * @property {boolean} validateSize\n         * @property {number} size\n         * @property {Set<Chunk>} chunks\n         * @property {Set<Chunk>} reuseableChunks\n         * @property {Set<string>} chunksKeys\n         */\n\n        // Map a list of chunks to a list of modules\n        // For the key the chunk \"index\" is used, the value is a SortableSet of modules\n        /** @type {Map<string, ChunksInfoItem>} */\n        const chunksInfoMap = new Map();\n\n        /**\n         * @param {TODO} cacheGroup the current cache group\n         * @param {Chunk[]} selectedChunks chunks selected for this module\n         * @param {string} selectedChunksKey a key of selectedChunks\n         * @param {Module} module the current module\n         * @returns {void}\n         */\n        const addModuleToChunksInfoMap = (cacheGroup, selectedChunks, selectedChunksKey, module) => {\n          // Break if minimum number of chunks is not reached\n          if (selectedChunks.length < cacheGroup.minChunks) return;\n          // Determine name for split chunk\n          const name = cacheGroup.getName(module, selectedChunks, cacheGroup.key);\n          // Create key for maps\n          // When it has a name we use the name as key\n          // Elsewise we create the key from chunks and cache group key\n          // This automatically merges equal names\n          const key = cacheGroup.key + (name ? ` name:${name}` : ` chunks:${selectedChunksKey}`);\n          // Add module to maps\n          let info = chunksInfoMap.get(key);\n          if (info === undefined) {\n            chunksInfoMap.set(key, info = {\n              modules: new SortableSet(undefined, sortByIdentifier),\n              cacheGroup,\n              name,\n              validateSize: cacheGroup.minSize > 0,\n              size: 0,\n              chunks: new Set(),\n              reuseableChunks: new Set(),\n              chunksKeys: new Set()\n            });\n          }\n          info.modules.add(module);\n          if (info.validateSize) {\n            info.size += module.size();\n          }\n          if (!info.chunksKeys.has(selectedChunksKey)) {\n            info.chunksKeys.add(selectedChunksKey);\n            for (const chunk of selectedChunks) {\n              info.chunks.add(chunk);\n            }\n          }\n        };\n\n        // Walk through all modules\n        for (const module of compilation.modules) {\n          // Get cache group\n          let cacheGroups = this.options.getCacheGroups(module);\n          if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n            continue;\n          }\n\n          // Prepare some values\n          const chunksKey = getKey(module.chunksIterable);\n          let combs = combinationsCache.get(chunksKey);\n          if (combs === undefined) {\n            combs = getCombinations(chunksKey);\n            combinationsCache.set(chunksKey, combs);\n          }\n          for (const cacheGroupSource of cacheGroups) {\n            const cacheGroup = {\n              key: cacheGroupSource.key,\n              priority: cacheGroupSource.priority || 0,\n              chunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,\n              minSize: cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : cacheGroupSource.enforce ? 0 : this.options.minSize,\n              minSizeForMaxSize: cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : this.options.minSize,\n              maxSize: cacheGroupSource.maxSize !== undefined ? cacheGroupSource.maxSize : cacheGroupSource.enforce ? 0 : this.options.maxSize,\n              minChunks: cacheGroupSource.minChunks !== undefined ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : this.options.minChunks,\n              maxAsyncRequests: cacheGroupSource.maxAsyncRequests !== undefined ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? Infinity : this.options.maxAsyncRequests,\n              maxInitialRequests: cacheGroupSource.maxInitialRequests !== undefined ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? Infinity : this.options.maxInitialRequests,\n              getName: cacheGroupSource.getName !== undefined ? cacheGroupSource.getName : this.options.getName,\n              filename: cacheGroupSource.filename !== undefined ? cacheGroupSource.filename : this.options.filename,\n              automaticNameDelimiter: cacheGroupSource.automaticNameDelimiter !== undefined ? cacheGroupSource.automaticNameDelimiter : this.options.automaticNameDelimiter,\n              reuseExistingChunk: cacheGroupSource.reuseExistingChunk\n            };\n            // For all combination of chunk selection\n            for (const chunkCombination of combs) {\n              // Break if minimum number of chunks is not reached\n              if (chunkCombination.size < cacheGroup.minChunks) continue;\n              // Select chunks by configuration\n              const {\n                chunks: selectedChunks,\n                key: selectedChunksKey\n              } = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter);\n              addModuleToChunksInfoMap(cacheGroup, selectedChunks, selectedChunksKey, module);\n            }\n          }\n        }\n\n        // Filter items were size < minSize\n        for (const pair of chunksInfoMap) {\n          const info = pair[1];\n          if (info.validateSize && info.size < info.cacheGroup.minSize) {\n            chunksInfoMap.delete(pair[0]);\n          }\n        }\n\n        /** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */\n        const maxSizeQueueMap = new Map();\n        while (chunksInfoMap.size > 0) {\n          // Find best matching entry\n          let bestEntryKey;\n          let bestEntry;\n          for (const pair of chunksInfoMap) {\n            const key = pair[0];\n            const info = pair[1];\n            if (bestEntry === undefined) {\n              bestEntry = info;\n              bestEntryKey = key;\n            } else if (compareEntries(bestEntry, info) < 0) {\n              bestEntry = info;\n              bestEntryKey = key;\n            }\n          }\n          const item = bestEntry;\n          chunksInfoMap.delete(bestEntryKey);\n          let chunkName = item.name;\n          // Variable for the new chunk (lazy created)\n          /** @type {Chunk} */\n          let newChunk;\n          // When no chunk name, check if we can reuse a chunk instead of creating a new one\n          let isReused = false;\n          if (item.cacheGroup.reuseExistingChunk) {\n            outer: for (const chunk of item.chunks) {\n              if (chunk.getNumberOfModules() !== item.modules.size) continue;\n              if (chunk.hasEntryModule()) continue;\n              for (const module of item.modules) {\n                if (!chunk.containsModule(module)) continue outer;\n              }\n              if (!newChunk || !newChunk.name) {\n                newChunk = chunk;\n              } else if (chunk.name && chunk.name.length < newChunk.name.length) {\n                newChunk = chunk;\n              } else if (chunk.name && chunk.name.length === newChunk.name.length && chunk.name < newChunk.name) {\n                newChunk = chunk;\n              }\n              chunkName = undefined;\n              isReused = true;\n            }\n          }\n          // Check if maxRequests condition can be fulfilled\n\n          const usedChunks = Array.from(item.chunks).filter(chunk => {\n            // skip if we address ourself\n            return (!chunkName || chunk.name !== chunkName) && chunk !== newChunk;\n          });\n\n          // Skip when no chunk selected\n          if (usedChunks.length === 0) continue;\n          let validChunks = usedChunks;\n          if (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests)) {\n            validChunks = validChunks.filter(chunk => {\n              // respect max requests when not enforced\n              const maxRequests = chunk.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : chunk.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;\n              return !isFinite(maxRequests) || getRequests(chunk) < maxRequests;\n            });\n          }\n          validChunks = validChunks.filter(chunk => {\n            for (const module of item.modules) {\n              if (chunk.containsModule(module)) return true;\n            }\n            return false;\n          });\n          if (validChunks.length < usedChunks.length) {\n            if (validChunks.length >= item.cacheGroup.minChunks) {\n              for (const module of item.modules) {\n                addModuleToChunksInfoMap(item.cacheGroup, validChunks, getKey(validChunks), module);\n              }\n            }\n            continue;\n          }\n\n          // Create the new chunk if not reusing one\n          if (!isReused) {\n            newChunk = compilation.addChunk(chunkName);\n          }\n          // Walk through all chunks\n          for (const chunk of usedChunks) {\n            // Add graph connections for splitted chunk\n            chunk.split(newChunk);\n          }\n\n          // Add a note to the chunk\n          newChunk.chunkReason = isReused ? \"reused as split chunk\" : \"split chunk\";\n          if (item.cacheGroup.key) {\n            newChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n          }\n          if (chunkName) {\n            newChunk.chunkReason += ` (name: ${chunkName})`;\n            // If the chosen name is already an entry point we remove the entry point\n            const entrypoint = compilation.entrypoints.get(chunkName);\n            if (entrypoint) {\n              compilation.entrypoints.delete(chunkName);\n              entrypoint.remove();\n              newChunk.entryModule = undefined;\n            }\n          }\n          if (item.cacheGroup.filename) {\n            if (!newChunk.isOnlyInitial()) {\n              throw new Error(\"SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. \" + \"The runtime can only handle loading of chunks which match the chunkFilename schema. \" + \"Using a custom filename would fail at runtime. \" + `(cache group: ${item.cacheGroup.key})`);\n            }\n            newChunk.filenameTemplate = item.cacheGroup.filename;\n          }\n          if (!isReused) {\n            // Add all modules to the new chunk\n            for (const module of item.modules) {\n              if (typeof module.chunkCondition === \"function\") {\n                if (!module.chunkCondition(newChunk)) continue;\n              }\n              // Add module to new chunk\n              GraphHelpers.connectChunkAndModule(newChunk, module);\n              // Remove module from used chunks\n              for (const chunk of usedChunks) {\n                chunk.removeModule(module);\n                module.rewriteChunkInReasons(chunk, [newChunk]);\n              }\n            }\n          } else {\n            // Remove all modules from used chunks\n            for (const module of item.modules) {\n              for (const chunk of usedChunks) {\n                chunk.removeModule(module);\n                module.rewriteChunkInReasons(chunk, [newChunk]);\n              }\n            }\n          }\n          if (item.cacheGroup.maxSize > 0) {\n            const oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n            maxSizeQueueMap.set(newChunk, {\n              minSize: Math.max(oldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0, item.cacheGroup.minSizeForMaxSize),\n              maxSize: Math.min(oldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity, item.cacheGroup.maxSize),\n              automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n              keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [item.cacheGroup.key]\n            });\n          }\n\n          // remove all modules from other entries and update size\n          for (const [key, info] of chunksInfoMap) {\n            if (isOverlap(info.chunks, item.chunks)) {\n              if (info.validateSize) {\n                // update modules and total size\n                // may remove it from the map when < minSize\n                const oldSize = info.modules.size;\n                for (const module of item.modules) {\n                  info.modules.delete(module);\n                }\n                if (info.modules.size === 0) {\n                  chunksInfoMap.delete(key);\n                  continue;\n                }\n                if (info.modules.size !== oldSize) {\n                  info.size = getModulesSize(info.modules);\n                  if (info.size < info.cacheGroup.minSize) {\n                    chunksInfoMap.delete(key);\n                  }\n                }\n              } else {\n                // only update the modules\n                for (const module of item.modules) {\n                  info.modules.delete(module);\n                }\n                if (info.modules.size === 0) {\n                  chunksInfoMap.delete(key);\n                }\n              }\n            }\n          }\n        }\n        const incorrectMinMaxSizeSet = new Set();\n\n        // Make sure that maxSize is fulfilled\n        for (const chunk of compilation.chunks.slice()) {\n          const {\n            minSize,\n            maxSize,\n            automaticNameDelimiter,\n            keys\n          } = maxSizeQueueMap.get(chunk) || this.options.fallbackCacheGroup;\n          if (!maxSize) continue;\n          if (minSize > maxSize) {\n            const warningKey = `${keys && keys.join()} ${minSize} ${maxSize}`;\n            if (!incorrectMinMaxSizeSet.has(warningKey)) {\n              incorrectMinMaxSizeSet.add(warningKey);\n              compilation.warnings.push(new MinMaxSizeWarning(keys, minSize, maxSize));\n            }\n          }\n          const results = deterministicGroupingForModules({\n            maxSize: Math.max(minSize, maxSize),\n            minSize,\n            items: chunk.modulesIterable,\n            getKey(module) {\n              const ident = contextify(compilation.options.context, module.identifier());\n              const name = module.nameForCondition ? contextify(compilation.options.context, module.nameForCondition()) : ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n              const fullKey = name + automaticNameDelimiter + hashFilename(ident);\n              return fullKey.replace(/[\\\\/?]/g, \"_\");\n            },\n            getSize(module) {\n              return module.size();\n            }\n          });\n          results.sort((a, b) => {\n            if (a.key < b.key) return -1;\n            if (a.key > b.key) return 1;\n            return 0;\n          });\n          for (let i = 0; i < results.length; i++) {\n            const group = results[i];\n            const key = this.options.hidePathInfo ? hashFilename(group.key) : group.key;\n            let name = chunk.name ? chunk.name + automaticNameDelimiter + key : null;\n            if (name && name.length > 100) {\n              name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name);\n            }\n            let newPart;\n            if (i !== results.length - 1) {\n              newPart = compilation.addChunk(name);\n              chunk.split(newPart);\n              newPart.chunkReason = chunk.chunkReason;\n              // Add all modules to the new chunk\n              for (const module of group.items) {\n                if (typeof module.chunkCondition === \"function\") {\n                  if (!module.chunkCondition(newPart)) continue;\n                }\n                // Add module to new chunk\n                GraphHelpers.connectChunkAndModule(newPart, module);\n                // Remove module from used chunks\n                chunk.removeModule(module);\n                module.rewriteChunkInReasons(chunk, [newPart]);\n              }\n            } else {\n              // change the chunk to be a part\n              newPart = chunk;\n              chunk.name = name;\n            }\n          }\n        }\n      });\n    });\n  }\n};","map":{"version":3,"names":["crypto","require","SortableSet","GraphHelpers","isSubset","deterministicGrouping","MinMaxSizeWarning","contextify","deterministicGroupingForModules","hashFilename","name","createHash","update","digest","slice","sortByIdentifier","a","b","identifier","getRequests","chunk","requests","chunkGroup","groupsIterable","Math","max","chunks","length","getModulesSize","modules","sum","m","size","isOverlap","item","has","compareEntries","diffPriority","cacheGroup","priority","diffCount","aSizeReduce","bSizeReduce","diffSizeReduce","modulesA","modulesB","diff","sort","aI","Symbol","iterator","bI","aItem","next","bItem","done","aModuleIdentifier","value","bModuleIdentifier","compareNumbers","INITIAL_CHUNK_FILTER","canBeInitial","ASYNC_CHUNK_FILTER","ALL_CHUNK_FILTER","module","exports","SplitChunksPlugin","constructor","options","normalizeOptions","chunksFilter","normalizeChunksFilter","minSize","maxSize","minChunks","maxAsyncRequests","maxInitialRequests","hidePathInfo","filename","undefined","getCacheGroups","normalizeCacheGroups","cacheGroups","automaticNameDelimiter","automaticNameMaxLength","fallbackCacheGroup","normalizeFallbackCacheGroup","normalizeName","automaticNamePrefix","cache","WeakMap","fn","cacheEntry","get","set","names","map","c","every","Boolean","prefix","namePrefix","join","hashedFilename","sliceLength","defaultMinSize","defaultMaxSize","defaultAutomaticNameDelimiter","getChunks","results","key","Object","keys","option","RegExp","test","result","r","Array","isArray","assign","getName","push","checkTest","enforce","reuseExistingChunk","nameForCondition","startsWith","chunksIterable","apply","compiler","hooks","thisCompilation","tap","compilation","alreadyOptimized","unseal","optimizeChunksAdvanced","indexMap","Map","index","getKey","from","chunkSetsInGraph","chunksKey","Set","chunkSetsByCount","chunksSet","values","count","array","combinationsCache","getCombinations","setArray","selectedChunksCacheByChunksSet","getSelectedChunks","chunkFilter","entry","entry2","selectedChunks","chunksInfoMap","addModuleToChunksInfoMap","selectedChunksKey","info","validateSize","reuseableChunks","chunksKeys","add","combs","cacheGroupSource","minSizeForMaxSize","Infinity","chunkCombination","pair","delete","maxSizeQueueMap","bestEntryKey","bestEntry","chunkName","newChunk","isReused","outer","getNumberOfModules","hasEntryModule","containsModule","usedChunks","filter","validChunks","Number","isFinite","maxRequests","isOnlyInitial","min","addChunk","split","chunkReason","entrypoint","entrypoints","remove","entryModule","Error","filenameTemplate","chunkCondition","connectChunkAndModule","removeModule","rewriteChunkInReasons","oldMaxSizeSettings","concat","oldSize","incorrectMinMaxSizeSet","warningKey","warnings","items","modulesIterable","ident","context","replace","fullKey","getSize","i","group","newPart"],"sources":["/home/soon/bulletin-board/node_modules/webpack/lib/optimize/SplitChunksPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst crypto = require(\"crypto\");\nconst SortableSet = require(\"../util/SortableSet\");\nconst GraphHelpers = require(\"../GraphHelpers\");\nconst { isSubset } = require(\"../util/SetHelpers\");\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\nconst contextify = require(\"../util/identifier\").contextify;\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\nconst deterministicGroupingForModules = /** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */ (deterministicGrouping);\n\nconst hashFilename = name => {\n\treturn crypto\n\t\t.createHash(\"md4\")\n\t\t.update(name)\n\t\t.digest(\"hex\")\n\t\t.slice(0, 8);\n};\n\nconst sortByIdentifier = (a, b) => {\n\tif (a.identifier() > b.identifier()) return 1;\n\tif (a.identifier() < b.identifier()) return -1;\n\treturn 0;\n};\n\nconst getRequests = chunk => {\n\tlet requests = 0;\n\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\trequests = Math.max(requests, chunkGroup.chunks.length);\n\t}\n\treturn requests;\n};\n\nconst getModulesSize = modules => {\n\tlet sum = 0;\n\tfor (const m of modules) {\n\t\tsum += m.size();\n\t}\n\treturn sum;\n};\n\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\nconst isOverlap = (a, b) => {\n\tfor (const item of a) {\n\t\tif (b.has(item)) return true;\n\t}\n\treturn false;\n};\n\nconst compareEntries = (a, b) => {\n\t// 1. by priority\n\tconst diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n\tif (diffPriority) return diffPriority;\n\t// 2. by number of chunks\n\tconst diffCount = a.chunks.size - b.chunks.size;\n\tif (diffCount) return diffCount;\n\t// 3. by size reduction\n\tconst aSizeReduce = a.size * (a.chunks.size - 1);\n\tconst bSizeReduce = b.size * (b.chunks.size - 1);\n\tconst diffSizeReduce = aSizeReduce - bSizeReduce;\n\tif (diffSizeReduce) return diffSizeReduce;\n\t// 4. by number of modules (to be able to compare by identifier)\n\tconst modulesA = a.modules;\n\tconst modulesB = b.modules;\n\tconst diff = modulesA.size - modulesB.size;\n\tif (diff) return diff;\n\t// 5. by module identifiers\n\tmodulesA.sort();\n\tmodulesB.sort();\n\tconst aI = modulesA[Symbol.iterator]();\n\tconst bI = modulesB[Symbol.iterator]();\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst aItem = aI.next();\n\t\tconst bItem = bI.next();\n\t\tif (aItem.done) return 0;\n\t\tconst aModuleIdentifier = aItem.value.identifier();\n\t\tconst bModuleIdentifier = bItem.value.identifier();\n\t\tif (aModuleIdentifier > bModuleIdentifier) return -1;\n\t\tif (aModuleIdentifier < bModuleIdentifier) return 1;\n\t}\n};\n\nconst compareNumbers = (a, b) => a - b;\n\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\nconst ALL_CHUNK_FILTER = chunk => true;\n\nmodule.exports = class SplitChunksPlugin {\n\tconstructor(options) {\n\t\tthis.options = SplitChunksPlugin.normalizeOptions(options);\n\t}\n\n\tstatic normalizeOptions(options = {}) {\n\t\treturn {\n\t\t\tchunksFilter: SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\toptions.chunks || \"all\"\n\t\t\t),\n\t\t\tminSize: options.minSize || 0,\n\t\t\tmaxSize: options.maxSize || 0,\n\t\t\tminChunks: options.minChunks || 1,\n\t\t\tmaxAsyncRequests: options.maxAsyncRequests || 1,\n\t\t\tmaxInitialRequests: options.maxInitialRequests || 1,\n\t\t\thidePathInfo: options.hidePathInfo || false,\n\t\t\tfilename: options.filename || undefined,\n\t\t\tgetCacheGroups: SplitChunksPlugin.normalizeCacheGroups({\n\t\t\t\tcacheGroups: options.cacheGroups,\n\t\t\t\tname: options.name,\n\t\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\t\tautomaticNameMaxLength: options.automaticNameMaxLength\n\t\t\t}),\n\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\tautomaticNameMaxLength: options.automaticNameMaxLength || 109,\n\t\t\tfallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(\n\t\t\t\toptions.fallbackCacheGroup || {},\n\t\t\t\toptions\n\t\t\t)\n\t\t};\n\t}\n\n\tstatic normalizeName({\n\t\tname,\n\t\tautomaticNameDelimiter,\n\t\tautomaticNamePrefix,\n\t\tautomaticNameMaxLength\n\t}) {\n\t\tif (name === true) {\n\t\t\t/** @type {WeakMap<Chunk[], Record<string, string>>} */\n\t\t\tconst cache = new WeakMap();\n\t\t\tconst fn = (module, chunks, cacheGroup) => {\n\t\t\t\tlet cacheEntry = cache.get(chunks);\n\t\t\t\tif (cacheEntry === undefined) {\n\t\t\t\t\tcacheEntry = {};\n\t\t\t\t\tcache.set(chunks, cacheEntry);\n\t\t\t\t} else if (cacheGroup in cacheEntry) {\n\t\t\t\t\treturn cacheEntry[cacheGroup];\n\t\t\t\t}\n\t\t\t\tconst names = chunks.map(c => c.name);\n\t\t\t\tif (!names.every(Boolean)) {\n\t\t\t\t\tcacheEntry[cacheGroup] = undefined;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tnames.sort();\n\t\t\t\tconst prefix =\n\t\t\t\t\ttypeof automaticNamePrefix === \"string\"\n\t\t\t\t\t\t? automaticNamePrefix\n\t\t\t\t\t\t: cacheGroup;\n\t\t\t\tconst namePrefix = prefix ? prefix + automaticNameDelimiter : \"\";\n\t\t\t\tlet name = namePrefix + names.join(automaticNameDelimiter);\n\t\t\t\t// Filenames and paths can't be too long otherwise an\n\t\t\t\t// ENAMETOOLONG error is raised. If the generated name if too\n\t\t\t\t// long, it is truncated and a hash is appended. The limit has\n\t\t\t\t// been set to 109 to prevent `[name].[chunkhash].[ext]` from\n\t\t\t\t// generating a 256+ character string.\n\t\t\t\tif (name.length > automaticNameMaxLength) {\n\t\t\t\t\tconst hashedFilename = hashFilename(name);\n\t\t\t\t\tconst sliceLength =\n\t\t\t\t\t\tautomaticNameMaxLength -\n\t\t\t\t\t\t(automaticNameDelimiter.length + hashedFilename.length);\n\t\t\t\t\tname =\n\t\t\t\t\t\tname.slice(0, sliceLength) +\n\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\thashedFilename;\n\t\t\t\t}\n\t\t\t\tcacheEntry[cacheGroup] = name;\n\t\t\t\treturn name;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tif (typeof name === \"string\") {\n\t\t\tconst fn = () => {\n\t\t\t\treturn name;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tif (typeof name === \"function\") return name;\n\t}\n\n\tstatic normalizeChunksFilter(chunks) {\n\t\tif (chunks === \"initial\") {\n\t\t\treturn INITIAL_CHUNK_FILTER;\n\t\t}\n\t\tif (chunks === \"async\") {\n\t\t\treturn ASYNC_CHUNK_FILTER;\n\t\t}\n\t\tif (chunks === \"all\") {\n\t\t\treturn ALL_CHUNK_FILTER;\n\t\t}\n\t\tif (typeof chunks === \"function\") return chunks;\n\t}\n\n\tstatic normalizeFallbackCacheGroup(\n\t\t{\n\t\t\tminSize = undefined,\n\t\t\tmaxSize = undefined,\n\t\t\tautomaticNameDelimiter = undefined\n\t\t},\n\t\t{\n\t\t\tminSize: defaultMinSize = undefined,\n\t\t\tmaxSize: defaultMaxSize = undefined,\n\t\t\tautomaticNameDelimiter: defaultAutomaticNameDelimiter = undefined\n\t\t}\n\t) {\n\t\treturn {\n\t\t\tminSize: typeof minSize === \"number\" ? minSize : defaultMinSize || 0,\n\t\t\tmaxSize: typeof maxSize === \"number\" ? maxSize : defaultMaxSize || 0,\n\t\t\tautomaticNameDelimiter:\n\t\t\t\tautomaticNameDelimiter || defaultAutomaticNameDelimiter || \"~\"\n\t\t};\n\t}\n\n\tstatic normalizeCacheGroups({\n\t\tcacheGroups,\n\t\tname,\n\t\tautomaticNameDelimiter,\n\t\tautomaticNameMaxLength\n\t}) {\n\t\tif (typeof cacheGroups === \"function\") {\n\t\t\t// TODO webpack 5 remove this\n\t\t\tif (cacheGroups.length !== 1) {\n\t\t\t\treturn module => cacheGroups(module, module.getChunks());\n\t\t\t}\n\t\t\treturn cacheGroups;\n\t\t}\n\t\tif (cacheGroups && typeof cacheGroups === \"object\") {\n\t\t\tconst fn = module => {\n\t\t\t\tlet results;\n\t\t\t\tfor (const key of Object.keys(cacheGroups)) {\n\t\t\t\t\tlet option = cacheGroups[key];\n\t\t\t\t\tif (option === false) continue;\n\t\t\t\t\tif (option instanceof RegExp || typeof option === \"string\") {\n\t\t\t\t\t\toption = {\n\t\t\t\t\t\t\ttest: option\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof option === \"function\") {\n\t\t\t\t\t\tlet result = option(module);\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\tif (results === undefined) results = [];\n\t\t\t\t\t\t\tfor (const r of Array.isArray(result) ? result : [result]) {\n\t\t\t\t\t\t\t\tconst result = Object.assign({ key }, r);\n\t\t\t\t\t\t\t\tif (result.name) result.getName = () => result.name;\n\t\t\t\t\t\t\t\tif (result.chunks) {\n\t\t\t\t\t\t\t\t\tresult.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\t\t\t\t\t\t\tresult.chunks\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tresults.push(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (SplitChunksPlugin.checkTest(option.test, module)) {\n\t\t\t\t\t\tif (results === undefined) results = [];\n\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\t\tpriority: option.priority,\n\t\t\t\t\t\t\tgetName:\n\t\t\t\t\t\t\t\tSplitChunksPlugin.normalizeName({\n\t\t\t\t\t\t\t\t\tname: option.name || name,\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\t\t\t\t\t\ttypeof option.automaticNameDelimiter === \"string\"\n\t\t\t\t\t\t\t\t\t\t\t? option.automaticNameDelimiter\n\t\t\t\t\t\t\t\t\t\t\t: automaticNameDelimiter,\n\t\t\t\t\t\t\t\t\tautomaticNamePrefix: option.automaticNamePrefix,\n\t\t\t\t\t\t\t\t\tautomaticNameMaxLength:\n\t\t\t\t\t\t\t\t\t\toption.automaticNameMaxLength || automaticNameMaxLength\n\t\t\t\t\t\t\t\t}) || (() => {}),\n\t\t\t\t\t\t\tchunksFilter: SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\t\t\t\t\toption.chunks\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tenforce: option.enforce,\n\t\t\t\t\t\t\tminSize: option.minSize,\n\t\t\t\t\t\t\tmaxSize: option.maxSize,\n\t\t\t\t\t\t\tminChunks: option.minChunks,\n\t\t\t\t\t\t\tmaxAsyncRequests: option.maxAsyncRequests,\n\t\t\t\t\t\t\tmaxInitialRequests: option.maxInitialRequests,\n\t\t\t\t\t\t\tfilename: option.filename,\n\t\t\t\t\t\t\treuseExistingChunk: option.reuseExistingChunk\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tconst fn = () => {};\n\t\treturn fn;\n\t}\n\n\tstatic checkTest(test, module) {\n\t\tif (test === undefined) return true;\n\t\tif (typeof test === \"function\") {\n\t\t\tif (test.length !== 1) {\n\t\t\t\treturn test(module, module.getChunks());\n\t\t\t}\n\t\t\treturn test(module);\n\t\t}\n\t\tif (typeof test === \"boolean\") return test;\n\t\tif (typeof test === \"string\") {\n\t\t\tif (\n\t\t\t\tmodule.nameForCondition &&\n\t\t\t\tmodule.nameForCondition().startsWith(test)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (const chunk of module.chunksIterable) {\n\t\t\t\tif (chunk.name && chunk.name.startsWith(test)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (test instanceof RegExp) {\n\t\t\tif (module.nameForCondition && test.test(module.nameForCondition())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (const chunk of module.chunksIterable) {\n\t\t\t\tif (chunk.name && test.test(chunk.name)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Compiler} compiler webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n\t\t\tlet alreadyOptimized = false;\n\t\t\tcompilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n\t\t\t\talreadyOptimized = false;\n\t\t\t});\n\t\t\tcompilation.hooks.optimizeChunksAdvanced.tap(\n\t\t\t\t\"SplitChunksPlugin\",\n\t\t\t\tchunks => {\n\t\t\t\t\tif (alreadyOptimized) return;\n\t\t\t\t\talreadyOptimized = true;\n\t\t\t\t\t// Give each selected chunk an index (to create strings from chunks)\n\t\t\t\t\tconst indexMap = new Map();\n\t\t\t\t\tlet index = 1;\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tindexMap.set(chunk, index++);\n\t\t\t\t\t}\n\t\t\t\t\tconst getKey = chunks => {\n\t\t\t\t\t\treturn Array.from(chunks, c => indexMap.get(c))\n\t\t\t\t\t\t\t.sort(compareNumbers)\n\t\t\t\t\t\t\t.join();\n\t\t\t\t\t};\n\t\t\t\t\t/** @type {Map<string, Set<Chunk>>} */\n\t\t\t\t\tconst chunkSetsInGraph = new Map();\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\tconst chunksKey = getKey(module.chunksIterable);\n\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\n\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(module.chunksIterable));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// group these set of chunks by count\n\t\t\t\t\t// to allow to check less sets via isSubset\n\t\t\t\t\t// (only smaller sets can be subset)\n\t\t\t\t\t/** @type {Map<number, Array<Set<Chunk>>>} */\n\t\t\t\t\tconst chunkSetsByCount = new Map();\n\t\t\t\t\tfor (const chunksSet of chunkSetsInGraph.values()) {\n\t\t\t\t\t\tconst count = chunksSet.size;\n\t\t\t\t\t\tlet array = chunkSetsByCount.get(count);\n\t\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\t\tchunkSetsByCount.set(count, array);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tarray.push(chunksSet);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create a list of possible combinations\n\t\t\t\t\tconst combinationsCache = new Map(); // Map<string, Set<Chunk>[]>\n\n\t\t\t\t\tconst getCombinations = key => {\n\t\t\t\t\t\tconst chunksSet = chunkSetsInGraph.get(key);\n\t\t\t\t\t\tvar array = [chunksSet];\n\t\t\t\t\t\tif (chunksSet.size > 1) {\n\t\t\t\t\t\t\tfor (const [count, setArray] of chunkSetsByCount) {\n\t\t\t\t\t\t\t\t// \"equal\" is not needed because they would have been merge in the first step\n\t\t\t\t\t\t\t\tif (count < chunksSet.size) {\n\t\t\t\t\t\t\t\t\tfor (const set of setArray) {\n\t\t\t\t\t\t\t\t\t\tif (isSubset(chunksSet, set)) {\n\t\t\t\t\t\t\t\t\t\t\tarray.push(set);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn array;\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} SelectedChunksResult\n\t\t\t\t\t * @property {Chunk[]} chunks the list of chunks\n\t\t\t\t\t * @property {string} key a key of the list\n\t\t\t\t\t */\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {function(Chunk): boolean} ChunkFilterFunction\n\t\t\t\t\t */\n\n\t\t\t\t\t/** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\t\t\t\t\tconst selectedChunksCacheByChunksSet = new WeakMap();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * get list and key by applying the filter function to the list\n\t\t\t\t\t * It is cached for performance reasons\n\t\t\t\t\t * @param {Set<Chunk>} chunks list of chunks\n\t\t\t\t\t * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n\t\t\t\t\t * @returns {SelectedChunksResult} list and key\n\t\t\t\t\t */\n\t\t\t\t\tconst getSelectedChunks = (chunks, chunkFilter) => {\n\t\t\t\t\t\tlet entry = selectedChunksCacheByChunksSet.get(chunks);\n\t\t\t\t\t\tif (entry === undefined) {\n\t\t\t\t\t\t\tentry = new WeakMap();\n\t\t\t\t\t\t\tselectedChunksCacheByChunksSet.set(chunks, entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/** @type {SelectedChunksResult} */\n\t\t\t\t\t\tlet entry2 = entry.get(chunkFilter);\n\t\t\t\t\t\tif (entry2 === undefined) {\n\t\t\t\t\t\t\t/** @type {Chunk[]} */\n\t\t\t\t\t\t\tconst selectedChunks = [];\n\t\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\t\tif (chunkFilter(chunk)) selectedChunks.push(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry2 = {\n\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\tkey: getKey(selectedChunks)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tentry.set(chunkFilter, entry2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn entry2;\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} ChunksInfoItem\n\t\t\t\t\t * @property {SortableSet} modules\n\t\t\t\t\t * @property {TODO} cacheGroup\n\t\t\t\t\t * @property {string} name\n\t\t\t\t\t * @property {boolean} validateSize\n\t\t\t\t\t * @property {number} size\n\t\t\t\t\t * @property {Set<Chunk>} chunks\n\t\t\t\t\t * @property {Set<Chunk>} reuseableChunks\n\t\t\t\t\t * @property {Set<string>} chunksKeys\n\t\t\t\t\t */\n\n\t\t\t\t\t// Map a list of chunks to a list of modules\n\t\t\t\t\t// For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\t\t\t\t\t/** @type {Map<string, ChunksInfoItem>} */\n\t\t\t\t\tconst chunksInfoMap = new Map();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {TODO} cacheGroup the current cache group\n\t\t\t\t\t * @param {Chunk[]} selectedChunks chunks selected for this module\n\t\t\t\t\t * @param {string} selectedChunksKey a key of selectedChunks\n\t\t\t\t\t * @param {Module} module the current module\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst addModuleToChunksInfoMap = (\n\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\tmodule\n\t\t\t\t\t) => {\n\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\tif (selectedChunks.length < cacheGroup.minChunks) return;\n\t\t\t\t\t\t// Determine name for split chunk\n\t\t\t\t\t\tconst name = cacheGroup.getName(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\tcacheGroup.key\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Create key for maps\n\t\t\t\t\t\t// When it has a name we use the name as key\n\t\t\t\t\t\t// Elsewise we create the key from chunks and cache group key\n\t\t\t\t\t\t// This automatically merges equal names\n\t\t\t\t\t\tconst key =\n\t\t\t\t\t\t\tcacheGroup.key +\n\t\t\t\t\t\t\t(name ? ` name:${name}` : ` chunks:${selectedChunksKey}`);\n\t\t\t\t\t\t// Add module to maps\n\t\t\t\t\t\tlet info = chunksInfoMap.get(key);\n\t\t\t\t\t\tif (info === undefined) {\n\t\t\t\t\t\t\tchunksInfoMap.set(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t(info = {\n\t\t\t\t\t\t\t\t\tmodules: new SortableSet(undefined, sortByIdentifier),\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\tvalidateSize: cacheGroup.minSize > 0,\n\t\t\t\t\t\t\t\t\tsize: 0,\n\t\t\t\t\t\t\t\t\tchunks: new Set(),\n\t\t\t\t\t\t\t\t\treuseableChunks: new Set(),\n\t\t\t\t\t\t\t\t\tchunksKeys: new Set()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo.modules.add(module);\n\t\t\t\t\t\tif (info.validateSize) {\n\t\t\t\t\t\t\tinfo.size += module.size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!info.chunksKeys.has(selectedChunksKey)) {\n\t\t\t\t\t\t\tinfo.chunksKeys.add(selectedChunksKey);\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tinfo.chunks.add(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Walk through all modules\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t// Get cache group\n\t\t\t\t\t\tlet cacheGroups = this.options.getCacheGroups(module);\n\t\t\t\t\t\tif (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prepare some values\n\t\t\t\t\t\tconst chunksKey = getKey(module.chunksIterable);\n\t\t\t\t\t\tlet combs = combinationsCache.get(chunksKey);\n\t\t\t\t\t\tif (combs === undefined) {\n\t\t\t\t\t\t\tcombs = getCombinations(chunksKey);\n\t\t\t\t\t\t\tcombinationsCache.set(chunksKey, combs);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const cacheGroupSource of cacheGroups) {\n\t\t\t\t\t\t\tconst cacheGroup = {\n\t\t\t\t\t\t\t\tkey: cacheGroupSource.key,\n\t\t\t\t\t\t\t\tpriority: cacheGroupSource.priority || 0,\n\t\t\t\t\t\t\t\tchunksFilter:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.chunksFilter || this.options.chunksFilter,\n\t\t\t\t\t\t\t\tminSize:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.minSize !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.minSize\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t\t: this.options.minSize,\n\t\t\t\t\t\t\t\tminSizeForMaxSize:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.minSize !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.minSize\n\t\t\t\t\t\t\t\t\t\t: this.options.minSize,\n\t\t\t\t\t\t\t\tmaxSize:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxSize !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxSize\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t\t: this.options.maxSize,\n\t\t\t\t\t\t\t\tminChunks:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.minChunks !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.minChunks\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t\t\t\t: this.options.minChunks,\n\t\t\t\t\t\t\t\tmaxAsyncRequests:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxAsyncRequests !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? Infinity\n\t\t\t\t\t\t\t\t\t\t: this.options.maxAsyncRequests,\n\t\t\t\t\t\t\t\tmaxInitialRequests:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxInitialRequests !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxInitialRequests\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? Infinity\n\t\t\t\t\t\t\t\t\t\t: this.options.maxInitialRequests,\n\t\t\t\t\t\t\t\tgetName:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.getName !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.getName\n\t\t\t\t\t\t\t\t\t\t: this.options.getName,\n\t\t\t\t\t\t\t\tfilename:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.filename !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.filename\n\t\t\t\t\t\t\t\t\t\t: this.options.filename,\n\t\t\t\t\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.automaticNameDelimiter !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.automaticNameDelimiter\n\t\t\t\t\t\t\t\t\t\t: this.options.automaticNameDelimiter,\n\t\t\t\t\t\t\t\treuseExistingChunk: cacheGroupSource.reuseExistingChunk\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t// For all combination of chunk selection\n\t\t\t\t\t\t\tfor (const chunkCombination of combs) {\n\t\t\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\t\t\tif (chunkCombination.size < cacheGroup.minChunks) continue;\n\t\t\t\t\t\t\t\t// Select chunks by configuration\n\t\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\t\tkey: selectedChunksKey\n\t\t\t\t\t\t\t\t} = getSelectedChunks(\n\t\t\t\t\t\t\t\t\tchunkCombination,\n\t\t\t\t\t\t\t\t\tcacheGroup.chunksFilter\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Filter items were size < minSize\n\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\tif (info.validateSize && info.size < info.cacheGroup.minSize) {\n\t\t\t\t\t\t\tchunksInfoMap.delete(pair[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */\n\t\t\t\t\tconst maxSizeQueueMap = new Map();\n\n\t\t\t\t\twhile (chunksInfoMap.size > 0) {\n\t\t\t\t\t\t// Find best matching entry\n\t\t\t\t\t\tlet bestEntryKey;\n\t\t\t\t\t\tlet bestEntry;\n\t\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\t\tconst key = pair[0];\n\t\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\t\tif (bestEntry === undefined) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t} else if (compareEntries(bestEntry, info) < 0) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst item = bestEntry;\n\t\t\t\t\t\tchunksInfoMap.delete(bestEntryKey);\n\n\t\t\t\t\t\tlet chunkName = item.name;\n\t\t\t\t\t\t// Variable for the new chunk (lazy created)\n\t\t\t\t\t\t/** @type {Chunk} */\n\t\t\t\t\t\tlet newChunk;\n\t\t\t\t\t\t// When no chunk name, check if we can reuse a chunk instead of creating a new one\n\t\t\t\t\t\tlet isReused = false;\n\t\t\t\t\t\tif (item.cacheGroup.reuseExistingChunk) {\n\t\t\t\t\t\t\touter: for (const chunk of item.chunks) {\n\t\t\t\t\t\t\t\tif (chunk.getNumberOfModules() !== item.modules.size) continue;\n\t\t\t\t\t\t\t\tif (chunk.hasEntryModule()) continue;\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tif (!chunk.containsModule(module)) continue outer;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!newChunk || !newChunk.name) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length < newChunk.name.length\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length === newChunk.name.length &&\n\t\t\t\t\t\t\t\t\tchunk.name < newChunk.name\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchunkName = undefined;\n\t\t\t\t\t\t\t\tisReused = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Check if maxRequests condition can be fulfilled\n\n\t\t\t\t\t\tconst usedChunks = Array.from(item.chunks).filter(chunk => {\n\t\t\t\t\t\t\t// skip if we address ourself\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t(!chunkName || chunk.name !== chunkName) && chunk !== newChunk\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Skip when no chunk selected\n\t\t\t\t\t\tif (usedChunks.length === 0) continue;\n\n\t\t\t\t\t\tlet validChunks = usedChunks;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tNumber.isFinite(item.cacheGroup.maxInitialRequests) ||\n\t\t\t\t\t\t\tNumber.isFinite(item.cacheGroup.maxAsyncRequests)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tvalidChunks = validChunks.filter(chunk => {\n\t\t\t\t\t\t\t\t// respect max requests when not enforced\n\t\t\t\t\t\t\t\tconst maxRequests = chunk.isOnlyInitial()\n\t\t\t\t\t\t\t\t\t? item.cacheGroup.maxInitialRequests\n\t\t\t\t\t\t\t\t\t: chunk.canBeInitial()\n\t\t\t\t\t\t\t\t\t? Math.min(\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialRequests,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncRequests;\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t!isFinite(maxRequests) || getRequests(chunk) < maxRequests\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvalidChunks = validChunks.filter(chunk => {\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (chunk.containsModule(module)) return true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (validChunks.length < usedChunks.length) {\n\t\t\t\t\t\t\tif (validChunks.length >= item.cacheGroup.minChunks) {\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\t\titem.cacheGroup,\n\t\t\t\t\t\t\t\t\t\tvalidChunks,\n\t\t\t\t\t\t\t\t\t\tgetKey(validChunks),\n\t\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Create the new chunk if not reusing one\n\t\t\t\t\t\tif (!isReused) {\n\t\t\t\t\t\t\tnewChunk = compilation.addChunk(chunkName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Walk through all chunks\n\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t// Add graph connections for splitted chunk\n\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add a note to the chunk\n\t\t\t\t\t\tnewChunk.chunkReason = isReused\n\t\t\t\t\t\t\t? \"reused as split chunk\"\n\t\t\t\t\t\t\t: \"split chunk\";\n\t\t\t\t\t\tif (item.cacheGroup.key) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (name: ${chunkName})`;\n\t\t\t\t\t\t\t// If the chosen name is already an entry point we remove the entry point\n\t\t\t\t\t\t\tconst entrypoint = compilation.entrypoints.get(chunkName);\n\t\t\t\t\t\t\tif (entrypoint) {\n\t\t\t\t\t\t\t\tcompilation.entrypoints.delete(chunkName);\n\t\t\t\t\t\t\t\tentrypoint.remove();\n\t\t\t\t\t\t\t\tnewChunk.entryModule = undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (item.cacheGroup.filename) {\n\t\t\t\t\t\t\tif (!newChunk.isOnlyInitial()) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\"SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. \" +\n\t\t\t\t\t\t\t\t\t\t\"The runtime can only handle loading of chunks which match the chunkFilename schema. \" +\n\t\t\t\t\t\t\t\t\t\t\"Using a custom filename would fail at runtime. \" +\n\t\t\t\t\t\t\t\t\t\t`(cache group: ${item.cacheGroup.key})`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnewChunk.filenameTemplate = item.cacheGroup.filename;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!isReused) {\n\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (typeof module.chunkCondition === \"function\") {\n\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newChunk)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\tGraphHelpers.connectChunkAndModule(newChunk, module);\n\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newChunk]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Remove all modules from used chunks\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newChunk]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (item.cacheGroup.maxSize > 0) {\n\t\t\t\t\t\t\tconst oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n\t\t\t\t\t\t\tmaxSizeQueueMap.set(newChunk, {\n\t\t\t\t\t\t\t\tminSize: Math.max(\n\t\t\t\t\t\t\t\t\toldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0,\n\t\t\t\t\t\t\t\t\titem.cacheGroup.minSizeForMaxSize\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tmaxSize: Math.min(\n\t\t\t\t\t\t\t\t\toldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity,\n\t\t\t\t\t\t\t\t\titem.cacheGroup.maxSize\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tautomaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n\t\t\t\t\t\t\t\tkeys: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? oldMaxSizeSettings.keys.concat(item.cacheGroup.key)\n\t\t\t\t\t\t\t\t\t: [item.cacheGroup.key]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remove all modules from other entries and update size\n\t\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\n\t\t\t\t\t\t\tif (isOverlap(info.chunks, item.chunks)) {\n\t\t\t\t\t\t\t\tif (info.validateSize) {\n\t\t\t\t\t\t\t\t\t// update modules and total size\n\t\t\t\t\t\t\t\t\t// may remove it from the map when < minSize\n\t\t\t\t\t\t\t\t\tconst oldSize = info.modules.size;\n\t\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (info.modules.size !== oldSize) {\n\t\t\t\t\t\t\t\t\t\tinfo.size = getModulesSize(info.modules);\n\t\t\t\t\t\t\t\t\t\tif (info.size < info.cacheGroup.minSize) {\n\t\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// only update the modules\n\t\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst incorrectMinMaxSizeSet = new Set();\n\n\t\t\t\t\t// Make sure that maxSize is fulfilled\n\t\t\t\t\tfor (const chunk of compilation.chunks.slice()) {\n\t\t\t\t\t\tconst { minSize, maxSize, automaticNameDelimiter, keys } =\n\t\t\t\t\t\t\tmaxSizeQueueMap.get(chunk) || this.options.fallbackCacheGroup;\n\t\t\t\t\t\tif (!maxSize) continue;\n\t\t\t\t\t\tif (minSize > maxSize) {\n\t\t\t\t\t\t\tconst warningKey = `${keys && keys.join()} ${minSize} ${maxSize}`;\n\t\t\t\t\t\t\tif (!incorrectMinMaxSizeSet.has(warningKey)) {\n\t\t\t\t\t\t\t\tincorrectMinMaxSizeSet.add(warningKey);\n\t\t\t\t\t\t\t\tcompilation.warnings.push(\n\t\t\t\t\t\t\t\t\tnew MinMaxSizeWarning(keys, minSize, maxSize)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst results = deterministicGroupingForModules({\n\t\t\t\t\t\t\tmaxSize: Math.max(minSize, maxSize),\n\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\titems: chunk.modulesIterable,\n\t\t\t\t\t\t\tgetKey(module) {\n\t\t\t\t\t\t\t\tconst ident = contextify(\n\t\t\t\t\t\t\t\t\tcompilation.options.context,\n\t\t\t\t\t\t\t\t\tmodule.identifier()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst name = module.nameForCondition\n\t\t\t\t\t\t\t\t\t? contextify(\n\t\t\t\t\t\t\t\t\t\t\tcompilation.options.context,\n\t\t\t\t\t\t\t\t\t\t\tmodule.nameForCondition()\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n\t\t\t\t\t\t\t\tconst fullKey =\n\t\t\t\t\t\t\t\t\tname + automaticNameDelimiter + hashFilename(ident);\n\t\t\t\t\t\t\t\treturn fullKey.replace(/[\\\\/?]/g, \"_\");\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgetSize(module) {\n\t\t\t\t\t\t\t\treturn module.size();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresults.sort((a, b) => {\n\t\t\t\t\t\t\tif (a.key < b.key) return -1;\n\t\t\t\t\t\t\tif (a.key > b.key) return 1;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\t\t\tconst group = results[i];\n\t\t\t\t\t\t\tconst key = this.options.hidePathInfo\n\t\t\t\t\t\t\t\t? hashFilename(group.key)\n\t\t\t\t\t\t\t\t: group.key;\n\t\t\t\t\t\t\tlet name = chunk.name\n\t\t\t\t\t\t\t\t? chunk.name + automaticNameDelimiter + key\n\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\tif (name && name.length > 100) {\n\t\t\t\t\t\t\t\tname =\n\t\t\t\t\t\t\t\t\tname.slice(0, 100) +\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\t\t\t\thashFilename(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet newPart;\n\t\t\t\t\t\t\tif (i !== results.length - 1) {\n\t\t\t\t\t\t\t\tnewPart = compilation.addChunk(name);\n\t\t\t\t\t\t\t\tchunk.split(newPart);\n\t\t\t\t\t\t\t\tnewPart.chunkReason = chunk.chunkReason;\n\t\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\t\tfor (const module of group.items) {\n\t\t\t\t\t\t\t\t\tif (typeof module.chunkCondition === \"function\") {\n\t\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newPart)) continue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\t\tGraphHelpers.connectChunkAndModule(newPart, module);\n\t\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newPart]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// change the chunk to be a part\n\t\t\t\t\t\t\t\tnewPart = chunk;\n\t\t\t\t\t\t\t\tchunk.name = name;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}