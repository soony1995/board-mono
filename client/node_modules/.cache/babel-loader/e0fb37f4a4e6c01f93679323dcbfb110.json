{"ast":null,"code":"'use strict';\n\nconst BB = require('bluebird');\nconst contentPath = require('./content/path');\nconst figgyPudding = require('figgy-pudding');\nconst finished = BB.promisify(require('mississippi').finished);\nconst fixOwner = require('./util/fix-owner');\nconst fs = require('graceful-fs');\nconst glob = BB.promisify(require('glob'));\nconst index = require('./entry-index');\nconst path = require('path');\nconst rimraf = BB.promisify(require('rimraf'));\nconst ssri = require('ssri');\nBB.promisifyAll(fs);\nconst VerifyOpts = figgyPudding({\n  concurrency: {\n    default: 20\n  },\n  filter: {},\n  log: {\n    default: {\n      silly() {}\n    }\n  }\n});\nmodule.exports = verify;\nfunction verify(cache, opts) {\n  opts = VerifyOpts(opts);\n  opts.log.silly('verify', 'verifying cache at', cache);\n  return BB.reduce([markStartTime, fixPerms, garbageCollect, rebuildIndex, cleanTmp, writeVerifile, markEndTime], (stats, step, i) => {\n    const label = step.name || `step #${i}`;\n    const start = new Date();\n    return BB.resolve(step(cache, opts)).then(s => {\n      s && Object.keys(s).forEach(k => {\n        stats[k] = s[k];\n      });\n      const end = new Date();\n      if (!stats.runTime) {\n        stats.runTime = {};\n      }\n      stats.runTime[label] = end - start;\n      return stats;\n    });\n  }, {}).tap(stats => {\n    stats.runTime.total = stats.endTime - stats.startTime;\n    opts.log.silly('verify', 'verification finished for', cache, 'in', `${stats.runTime.total}ms`);\n  });\n}\nfunction markStartTime(cache, opts) {\n  return {\n    startTime: new Date()\n  };\n}\nfunction markEndTime(cache, opts) {\n  return {\n    endTime: new Date()\n  };\n}\nfunction fixPerms(cache, opts) {\n  opts.log.silly('verify', 'fixing cache permissions');\n  return fixOwner.mkdirfix(cache, cache).then(() => {\n    // TODO - fix file permissions too\n    return fixOwner.chownr(cache, cache);\n  }).then(() => null);\n}\n\n// Implements a naive mark-and-sweep tracing garbage collector.\n//\n// The algorithm is basically as follows:\n// 1. Read (and filter) all index entries (\"pointers\")\n// 2. Mark each integrity value as \"live\"\n// 3. Read entire filesystem tree in `content-vX/` dir\n// 4. If content is live, verify its checksum and delete it if it fails\n// 5. If content is not marked as live, rimraf it.\n//\nfunction garbageCollect(cache, opts) {\n  opts.log.silly('verify', 'garbage collecting content');\n  const indexStream = index.lsStream(cache);\n  const liveContent = new Set();\n  indexStream.on('data', entry => {\n    if (opts.filter && !opts.filter(entry)) {\n      return;\n    }\n    liveContent.add(entry.integrity.toString());\n  });\n  return finished(indexStream).then(() => {\n    const contentDir = contentPath._contentDir(cache);\n    return glob(path.join(contentDir, '**'), {\n      follow: false,\n      nodir: true,\n      nosort: true\n    }).then(files => {\n      return BB.resolve({\n        verifiedContent: 0,\n        reclaimedCount: 0,\n        reclaimedSize: 0,\n        badContentCount: 0,\n        keptSize: 0\n      }).tap(stats => BB.map(files, f => {\n        const split = f.split(/[/\\\\]/);\n        const digest = split.slice(split.length - 3).join('');\n        const algo = split[split.length - 4];\n        const integrity = ssri.fromHex(digest, algo);\n        if (liveContent.has(integrity.toString())) {\n          return verifyContent(f, integrity).then(info => {\n            if (!info.valid) {\n              stats.reclaimedCount++;\n              stats.badContentCount++;\n              stats.reclaimedSize += info.size;\n            } else {\n              stats.verifiedContent++;\n              stats.keptSize += info.size;\n            }\n            return stats;\n          });\n        } else {\n          // No entries refer to this content. We can delete.\n          stats.reclaimedCount++;\n          return fs.statAsync(f).then(s => {\n            return rimraf(f).then(() => {\n              stats.reclaimedSize += s.size;\n              return stats;\n            });\n          });\n        }\n      }, {\n        concurrency: opts.concurrency\n      }));\n    });\n  });\n}\nfunction verifyContent(filepath, sri) {\n  return fs.statAsync(filepath).then(stat => {\n    const contentInfo = {\n      size: stat.size,\n      valid: true\n    };\n    return ssri.checkStream(fs.createReadStream(filepath), sri).catch(err => {\n      if (err.code !== 'EINTEGRITY') {\n        throw err;\n      }\n      return rimraf(filepath).then(() => {\n        contentInfo.valid = false;\n      });\n    }).then(() => contentInfo);\n  }).catch({\n    code: 'ENOENT'\n  }, () => ({\n    size: 0,\n    valid: false\n  }));\n}\nfunction rebuildIndex(cache, opts) {\n  opts.log.silly('verify', 'rebuilding index');\n  return index.ls(cache).then(entries => {\n    const stats = {\n      missingContent: 0,\n      rejectedEntries: 0,\n      totalEntries: 0\n    };\n    const buckets = {};\n    for (let k in entries) {\n      if (entries.hasOwnProperty(k)) {\n        const hashed = index._hashKey(k);\n        const entry = entries[k];\n        const excluded = opts.filter && !opts.filter(entry);\n        excluded && stats.rejectedEntries++;\n        if (buckets[hashed] && !excluded) {\n          buckets[hashed].push(entry);\n        } else if (buckets[hashed] && excluded) {\n          // skip\n        } else if (excluded) {\n          buckets[hashed] = [];\n          buckets[hashed]._path = index._bucketPath(cache, k);\n        } else {\n          buckets[hashed] = [entry];\n          buckets[hashed]._path = index._bucketPath(cache, k);\n        }\n      }\n    }\n    return BB.map(Object.keys(buckets), key => {\n      return rebuildBucket(cache, buckets[key], stats, opts);\n    }, {\n      concurrency: opts.concurrency\n    }).then(() => stats);\n  });\n}\nfunction rebuildBucket(cache, bucket, stats, opts) {\n  return fs.truncateAsync(bucket._path).then(() => {\n    // This needs to be serialized because cacache explicitly\n    // lets very racy bucket conflicts clobber each other.\n    return BB.mapSeries(bucket, entry => {\n      const content = contentPath(cache, entry.integrity);\n      return fs.statAsync(content).then(() => {\n        return index.insert(cache, entry.key, entry.integrity, {\n          metadata: entry.metadata,\n          size: entry.size\n        }).then(() => {\n          stats.totalEntries++;\n        });\n      }).catch({\n        code: 'ENOENT'\n      }, () => {\n        stats.rejectedEntries++;\n        stats.missingContent++;\n      });\n    });\n  });\n}\nfunction cleanTmp(cache, opts) {\n  opts.log.silly('verify', 'cleaning tmp directory');\n  return rimraf(path.join(cache, 'tmp'));\n}\nfunction writeVerifile(cache, opts) {\n  const verifile = path.join(cache, '_lastverified');\n  opts.log.silly('verify', 'writing verifile to ' + verifile);\n  try {\n    return fs.writeFileAsync(verifile, '' + +new Date());\n  } finally {\n    fixOwner.chownr.sync(cache, verifile);\n  }\n}\nmodule.exports.lastRun = lastRun;\nfunction lastRun(cache) {\n  return fs.readFileAsync(path.join(cache, '_lastverified'), 'utf8').then(data => new Date(+data));\n}","map":{"version":3,"names":["BB","require","contentPath","figgyPudding","finished","promisify","fixOwner","fs","glob","index","path","rimraf","ssri","promisifyAll","VerifyOpts","concurrency","default","filter","log","silly","module","exports","verify","cache","opts","reduce","markStartTime","fixPerms","garbageCollect","rebuildIndex","cleanTmp","writeVerifile","markEndTime","stats","step","i","label","name","start","Date","resolve","then","s","Object","keys","forEach","k","end","runTime","tap","total","endTime","startTime","mkdirfix","chownr","indexStream","lsStream","liveContent","Set","on","entry","add","integrity","toString","contentDir","_contentDir","join","follow","nodir","nosort","files","verifiedContent","reclaimedCount","reclaimedSize","badContentCount","keptSize","map","f","split","digest","slice","length","algo","fromHex","has","verifyContent","info","valid","size","statAsync","filepath","sri","stat","contentInfo","checkStream","createReadStream","catch","err","code","ls","entries","missingContent","rejectedEntries","totalEntries","buckets","hasOwnProperty","hashed","_hashKey","excluded","push","_path","_bucketPath","key","rebuildBucket","bucket","truncateAsync","mapSeries","content","insert","metadata","verifile","writeFileAsync","sync","lastRun","readFileAsync","data"],"sources":["/home/soon/bulletin-board/node_modules/webpack/node_modules/cacache/lib/verify.js"],"sourcesContent":["'use strict'\n\nconst BB = require('bluebird')\n\nconst contentPath = require('./content/path')\nconst figgyPudding = require('figgy-pudding')\nconst finished = BB.promisify(require('mississippi').finished)\nconst fixOwner = require('./util/fix-owner')\nconst fs = require('graceful-fs')\nconst glob = BB.promisify(require('glob'))\nconst index = require('./entry-index')\nconst path = require('path')\nconst rimraf = BB.promisify(require('rimraf'))\nconst ssri = require('ssri')\n\nBB.promisifyAll(fs)\n\nconst VerifyOpts = figgyPudding({\n  concurrency: {\n    default: 20\n  },\n  filter: {},\n  log: {\n    default: { silly () {} }\n  }\n})\n\nmodule.exports = verify\nfunction verify (cache, opts) {\n  opts = VerifyOpts(opts)\n  opts.log.silly('verify', 'verifying cache at', cache)\n  return BB.reduce([\n    markStartTime,\n    fixPerms,\n    garbageCollect,\n    rebuildIndex,\n    cleanTmp,\n    writeVerifile,\n    markEndTime\n  ], (stats, step, i) => {\n    const label = step.name || `step #${i}`\n    const start = new Date()\n    return BB.resolve(step(cache, opts)).then(s => {\n      s && Object.keys(s).forEach(k => {\n        stats[k] = s[k]\n      })\n      const end = new Date()\n      if (!stats.runTime) { stats.runTime = {} }\n      stats.runTime[label] = end - start\n      return stats\n    })\n  }, {}).tap(stats => {\n    stats.runTime.total = stats.endTime - stats.startTime\n    opts.log.silly('verify', 'verification finished for', cache, 'in', `${stats.runTime.total}ms`)\n  })\n}\n\nfunction markStartTime (cache, opts) {\n  return { startTime: new Date() }\n}\n\nfunction markEndTime (cache, opts) {\n  return { endTime: new Date() }\n}\n\nfunction fixPerms (cache, opts) {\n  opts.log.silly('verify', 'fixing cache permissions')\n  return fixOwner.mkdirfix(cache, cache).then(() => {\n    // TODO - fix file permissions too\n    return fixOwner.chownr(cache, cache)\n  }).then(() => null)\n}\n\n// Implements a naive mark-and-sweep tracing garbage collector.\n//\n// The algorithm is basically as follows:\n// 1. Read (and filter) all index entries (\"pointers\")\n// 2. Mark each integrity value as \"live\"\n// 3. Read entire filesystem tree in `content-vX/` dir\n// 4. If content is live, verify its checksum and delete it if it fails\n// 5. If content is not marked as live, rimraf it.\n//\nfunction garbageCollect (cache, opts) {\n  opts.log.silly('verify', 'garbage collecting content')\n  const indexStream = index.lsStream(cache)\n  const liveContent = new Set()\n  indexStream.on('data', entry => {\n    if (opts.filter && !opts.filter(entry)) { return }\n    liveContent.add(entry.integrity.toString())\n  })\n  return finished(indexStream).then(() => {\n    const contentDir = contentPath._contentDir(cache)\n    return glob(path.join(contentDir, '**'), {\n      follow: false,\n      nodir: true,\n      nosort: true\n    }).then(files => {\n      return BB.resolve({\n        verifiedContent: 0,\n        reclaimedCount: 0,\n        reclaimedSize: 0,\n        badContentCount: 0,\n        keptSize: 0\n      }).tap((stats) => BB.map(files, (f) => {\n        const split = f.split(/[/\\\\]/)\n        const digest = split.slice(split.length - 3).join('')\n        const algo = split[split.length - 4]\n        const integrity = ssri.fromHex(digest, algo)\n        if (liveContent.has(integrity.toString())) {\n          return verifyContent(f, integrity).then(info => {\n            if (!info.valid) {\n              stats.reclaimedCount++\n              stats.badContentCount++\n              stats.reclaimedSize += info.size\n            } else {\n              stats.verifiedContent++\n              stats.keptSize += info.size\n            }\n            return stats\n          })\n        } else {\n          // No entries refer to this content. We can delete.\n          stats.reclaimedCount++\n          return fs.statAsync(f).then(s => {\n            return rimraf(f).then(() => {\n              stats.reclaimedSize += s.size\n              return stats\n            })\n          })\n        }\n      }, { concurrency: opts.concurrency }))\n    })\n  })\n}\n\nfunction verifyContent (filepath, sri) {\n  return fs.statAsync(filepath).then(stat => {\n    const contentInfo = {\n      size: stat.size,\n      valid: true\n    }\n    return ssri.checkStream(\n      fs.createReadStream(filepath),\n      sri\n    ).catch(err => {\n      if (err.code !== 'EINTEGRITY') { throw err }\n      return rimraf(filepath).then(() => {\n        contentInfo.valid = false\n      })\n    }).then(() => contentInfo)\n  }).catch({ code: 'ENOENT' }, () => ({ size: 0, valid: false }))\n}\n\nfunction rebuildIndex (cache, opts) {\n  opts.log.silly('verify', 'rebuilding index')\n  return index.ls(cache).then(entries => {\n    const stats = {\n      missingContent: 0,\n      rejectedEntries: 0,\n      totalEntries: 0\n    }\n    const buckets = {}\n    for (let k in entries) {\n      if (entries.hasOwnProperty(k)) {\n        const hashed = index._hashKey(k)\n        const entry = entries[k]\n        const excluded = opts.filter && !opts.filter(entry)\n        excluded && stats.rejectedEntries++\n        if (buckets[hashed] && !excluded) {\n          buckets[hashed].push(entry)\n        } else if (buckets[hashed] && excluded) {\n          // skip\n        } else if (excluded) {\n          buckets[hashed] = []\n          buckets[hashed]._path = index._bucketPath(cache, k)\n        } else {\n          buckets[hashed] = [entry]\n          buckets[hashed]._path = index._bucketPath(cache, k)\n        }\n      }\n    }\n    return BB.map(Object.keys(buckets), key => {\n      return rebuildBucket(cache, buckets[key], stats, opts)\n    }, { concurrency: opts.concurrency }).then(() => stats)\n  })\n}\n\nfunction rebuildBucket (cache, bucket, stats, opts) {\n  return fs.truncateAsync(bucket._path).then(() => {\n    // This needs to be serialized because cacache explicitly\n    // lets very racy bucket conflicts clobber each other.\n    return BB.mapSeries(bucket, entry => {\n      const content = contentPath(cache, entry.integrity)\n      return fs.statAsync(content).then(() => {\n        return index.insert(cache, entry.key, entry.integrity, {\n          metadata: entry.metadata,\n          size: entry.size\n        }).then(() => { stats.totalEntries++ })\n      }).catch({ code: 'ENOENT' }, () => {\n        stats.rejectedEntries++\n        stats.missingContent++\n      })\n    })\n  })\n}\n\nfunction cleanTmp (cache, opts) {\n  opts.log.silly('verify', 'cleaning tmp directory')\n  return rimraf(path.join(cache, 'tmp'))\n}\n\nfunction writeVerifile (cache, opts) {\n  const verifile = path.join(cache, '_lastverified')\n  opts.log.silly('verify', 'writing verifile to ' + verifile)\n  try {\n    return fs.writeFileAsync(verifile, '' + (+(new Date())))\n  } finally {\n    fixOwner.chownr.sync(cache, verifile)\n  }\n}\n\nmodule.exports.lastRun = lastRun\nfunction lastRun (cache) {\n  return fs.readFileAsync(\n    path.join(cache, '_lastverified'), 'utf8'\n  ).then(data => new Date(+data))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}