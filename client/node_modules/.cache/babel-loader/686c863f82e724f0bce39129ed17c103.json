{"ast":null,"code":"'use strict';\n\nmodule.exports = copy;\nmodule.exports.item = copyItem;\nmodule.exports.recurse = recurseDir;\nmodule.exports.symlink = copySymlink;\nmodule.exports.file = copyFile;\nvar nodeFs = require('fs');\nvar path = require('path');\nvar validate = require('aproba');\nvar stockWriteStreamAtomic = require('fs-write-stream-atomic');\nvar mkdirp = require('mkdirp');\nvar rimraf = require('rimraf');\nvar isWindows = require('./is-windows');\nvar RunQueue = require('run-queue');\nvar extend = Object.assign || require('util')._extend;\nfunction promisify(Promise, fn) {\n  return function () {\n    var args = [].slice.call(arguments);\n    return new Promise(function (resolve, reject) {\n      return fn.apply(null, args.concat(function (err, value) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(value);\n        }\n      }));\n    });\n  };\n}\nfunction copy(from, to, opts) {\n  validate('SSO|SS', arguments);\n  opts = extend({}, opts || {});\n  var Promise = opts.Promise || global.Promise;\n  var fs = opts.fs || nodeFs;\n  if (opts.isWindows == null) opts.isWindows = isWindows;\n  if (!opts.Promise) opts.Promise = Promise;\n  if (!opts.fs) opts.fs = fs;\n  if (!opts.recurseWith) opts.recurseWith = copyItem;\n  if (!opts.lstat) opts.lstat = promisify(opts.Promise, fs.lstat);\n  if (!opts.stat) opts.stat = promisify(opts.Promise, fs.stat);\n  if (!opts.chown) opts.chown = promisify(opts.Promise, fs.chown);\n  if (!opts.readdir) opts.readdir = promisify(opts.Promise, fs.readdir);\n  if (!opts.readlink) opts.readlink = promisify(opts.Promise, fs.readlink);\n  if (!opts.symlink) opts.symlink = promisify(opts.Promise, fs.symlink);\n  if (!opts.chmod) opts.chmod = promisify(opts.Promise, fs.chmod);\n  opts.top = from;\n  opts.mkdirpAsync = promisify(opts.Promise, mkdirp);\n  var rimrafAsync = promisify(opts.Promise, rimraf);\n  var queue = new RunQueue({\n    maxConcurrency: opts.maxConcurrency,\n    Promise: Promise\n  });\n  opts.queue = queue;\n  queue.add(0, copyItem, [from, to, opts]);\n  return queue.run().catch(function (err) {\n    // if the target already exists don't clobber it\n    if (err.code === 'EEXIST' || err.code === 'EPERM') {\n      return passThroughError();\n    } else {\n      return remove(to).then(passThroughError, passThroughError);\n    }\n    function passThroughError() {\n      return Promise.reject(err);\n    }\n  });\n  function remove(target) {\n    var opts = {\n      unlink: fs.unlink,\n      chmod: fs.chmod,\n      stat: fs.stat,\n      lstat: fs.lstat,\n      rmdir: fs.rmdir,\n      readdir: fs.readdir,\n      glob: false\n    };\n    return rimrafAsync(target, opts);\n  }\n}\nfunction copyItem(from, to, opts) {\n  validate('SSO', [from, to, opts]);\n  var fs = opts.fs || nodeFs;\n  var Promise = opts.Promise || global.Promise;\n  var lstat = opts.lstat || promisify(Promise, fs.lstat);\n  return lstat(to).then(function () {\n    return Promise.reject(eexists(from, to));\n  }, function (err) {\n    if (err && err.code !== 'ENOENT') return Promise.reject(err);\n    return lstat(from);\n  }).then(function (fromStat) {\n    var cmdOpts = extend(extend({}, opts), fromStat);\n    if (fromStat.isDirectory()) {\n      return recurseDir(from, to, cmdOpts);\n    } else if (fromStat.isSymbolicLink()) {\n      opts.queue.add(1, copySymlink, [from, to, cmdOpts]);\n    } else if (fromStat.isFile()) {\n      return copyFile(from, to, cmdOpts);\n    } else if (fromStat.isBlockDevice()) {\n      return Promise.reject(eunsupported(from + \" is a block device, and we don't know how to copy those.\"));\n    } else if (fromStat.isCharacterDevice()) {\n      return Promise.reject(eunsupported(from + \" is a character device, and we don't know how to copy those.\"));\n    } else if (fromStat.isFIFO()) {\n      return Promise.reject(eunsupported(from + \" is a FIFO, and we don't know how to copy those.\"));\n    } else if (fromStat.isSocket()) {\n      return Promise.reject(eunsupported(from + \" is a socket, and we don't know how to copy those.\"));\n    } else {\n      return Promise.reject(eunsupported(\"We can't tell what \" + from + \" is and so we can't copy it.\"));\n    }\n  });\n}\nfunction recurseDir(from, to, opts) {\n  validate('SSO', [from, to, opts]);\n  var recurseWith = opts.recurseWith || copyItem;\n  var fs = opts.fs || nodeFs;\n  var chown = opts.chown || promisify(Promise, fs.chown);\n  var readdir = opts.readdir || promisify(Promise, fs.readdir);\n  var mkdirpAsync = opts.mkdirpAsync || promisify(Promise, mkdirp);\n  return mkdirpAsync(to, {\n    fs: fs,\n    mode: opts.mode\n  }).then(function () {\n    var getuid = opts.getuid || process.getuid;\n    if (getuid && opts.uid != null && getuid() === 0) {\n      return chown(to, opts.uid, opts.gid);\n    }\n  }).then(function () {\n    return readdir(from);\n  }).then(function (files) {\n    files.forEach(function (file) {\n      opts.queue.add(0, recurseWith, [path.join(from, file), path.join(to, file), opts]);\n    });\n  });\n}\nfunction copySymlink(from, to, opts) {\n  validate('SSO', [from, to, opts]);\n  var fs = opts.fs || nodeFs;\n  var readlink = opts.readlink || promisify(Promise, fs.readlink);\n  var stat = opts.stat || promisify(Promise, fs.symlink);\n  var symlink = opts.symlink || promisify(Promise, fs.symlink);\n  var Promise = opts.Promise || global.Promise;\n  return readlink(from).then(function (fromDest) {\n    var absoluteDest = path.resolve(path.dirname(from), fromDest);\n    // Treat absolute paths that are inside the tree we're\n    // copying as relative. This necessary to properly support junctions\n    // on windows (which are always absolute) but is also DWIM with symlinks.\n    var relativeDest = path.relative(opts.top, absoluteDest);\n    var linkFrom = relativeDest.substr(0, 2) === '..' ? fromDest : path.relative(path.dirname(from), absoluteDest);\n    if (opts.isWindows) {\n      return stat(absoluteDest).catch(function () {\n        return null;\n      }).then(function (destStat) {\n        var isDir = destStat && destStat.isDirectory();\n        var type = isDir ? 'dir' : 'file';\n        return symlink(linkFrom, to, type).catch(function (err) {\n          if (type === 'dir') {\n            return symlink(linkFrom, to, 'junction');\n          } else {\n            return Promise.reject(err);\n          }\n        });\n      });\n    } else {\n      return symlink(linkFrom, to);\n    }\n  });\n}\nfunction copyFile(from, to, opts) {\n  validate('SSO', [from, to, opts]);\n  var fs = opts.fs || nodeFs;\n  var writeStreamAtomic = opts.writeStreamAtomic || stockWriteStreamAtomic;\n  var Promise = opts.Promise || global.Promise;\n  var chmod = opts.chmod || promisify(Promise, fs.chmod);\n  var writeOpts = {};\n  var getuid = opts.getuid || process.getuid;\n  if (getuid && opts.uid != null && getuid() === 0) {\n    writeOpts.chown = {\n      uid: opts.uid,\n      gid: opts.gid\n    };\n  }\n  return new Promise(function (resolve, reject) {\n    var errored = false;\n    function onError(err) {\n      errored = true;\n      reject(err);\n    }\n    fs.createReadStream(from).once('error', onError).pipe(writeStreamAtomic(to, writeOpts)).once('error', onError).once('close', function () {\n      if (errored) return;\n      if (opts.mode != null) {\n        resolve(chmod(to, opts.mode));\n      } else {\n        resolve();\n      }\n    });\n  });\n}\nfunction eexists(from, to) {\n  var err = new Error('Could not move ' + from + ' to ' + to + ': destination already exists.');\n  err.code = 'EEXIST';\n  return err;\n}\nfunction eunsupported(msg) {\n  var err = new Error(msg);\n  err.code = 'EUNSUPPORTED';\n  return err;\n}","map":{"version":3,"names":["module","exports","copy","item","copyItem","recurse","recurseDir","symlink","copySymlink","file","copyFile","nodeFs","require","path","validate","stockWriteStreamAtomic","mkdirp","rimraf","isWindows","RunQueue","extend","Object","assign","_extend","promisify","Promise","fn","args","slice","call","arguments","resolve","reject","apply","concat","err","value","from","to","opts","global","fs","recurseWith","lstat","stat","chown","readdir","readlink","chmod","top","mkdirpAsync","rimrafAsync","queue","maxConcurrency","add","run","catch","code","passThroughError","remove","then","target","unlink","rmdir","glob","eexists","fromStat","cmdOpts","isDirectory","isSymbolicLink","isFile","isBlockDevice","eunsupported","isCharacterDevice","isFIFO","isSocket","mode","getuid","process","uid","gid","files","forEach","join","fromDest","absoluteDest","dirname","relativeDest","relative","linkFrom","substr","destStat","isDir","type","writeStreamAtomic","writeOpts","errored","onError","createReadStream","once","pipe","Error","msg"],"sources":["/home/soon/bulletin-board/node_modules/copy-concurrently/copy.js"],"sourcesContent":["'use strict'\nmodule.exports = copy\nmodule.exports.item = copyItem\nmodule.exports.recurse = recurseDir\nmodule.exports.symlink = copySymlink\nmodule.exports.file = copyFile\n\nvar nodeFs = require('fs')\nvar path = require('path')\nvar validate = require('aproba')\nvar stockWriteStreamAtomic = require('fs-write-stream-atomic')\nvar mkdirp = require('mkdirp')\nvar rimraf = require('rimraf')\nvar isWindows = require('./is-windows')\nvar RunQueue = require('run-queue')\nvar extend = Object.assign || require('util')._extend\n\nfunction promisify (Promise, fn) {\n  return function () {\n    var args = [].slice.call(arguments)\n    return new Promise(function (resolve, reject) {\n      return fn.apply(null, args.concat(function (err, value) {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(value)\n        }\n      }))\n    })\n  }\n}\n\nfunction copy (from, to, opts) {\n  validate('SSO|SS', arguments)\n  opts = extend({}, opts || {})\n\n  var Promise = opts.Promise || global.Promise\n  var fs = opts.fs || nodeFs\n\n  if (opts.isWindows == null) opts.isWindows = isWindows\n  if (!opts.Promise) opts.Promise = Promise\n  if (!opts.fs) opts.fs = fs\n  if (!opts.recurseWith) opts.recurseWith = copyItem\n  if (!opts.lstat) opts.lstat = promisify(opts.Promise, fs.lstat)\n  if (!opts.stat) opts.stat = promisify(opts.Promise, fs.stat)\n  if (!opts.chown) opts.chown = promisify(opts.Promise, fs.chown)\n  if (!opts.readdir) opts.readdir = promisify(opts.Promise, fs.readdir)\n  if (!opts.readlink) opts.readlink = promisify(opts.Promise, fs.readlink)\n  if (!opts.symlink) opts.symlink = promisify(opts.Promise, fs.symlink)\n  if (!opts.chmod) opts.chmod = promisify(opts.Promise, fs.chmod)\n\n  opts.top = from\n  opts.mkdirpAsync = promisify(opts.Promise, mkdirp)\n  var rimrafAsync = promisify(opts.Promise, rimraf)\n\n  var queue = new RunQueue({\n    maxConcurrency: opts.maxConcurrency,\n    Promise: Promise\n  })\n  opts.queue = queue\n\n  queue.add(0, copyItem, [from, to, opts])\n\n  return queue.run().catch(function (err) {\n    // if the target already exists don't clobber it\n    if (err.code === 'EEXIST' || err.code === 'EPERM') {\n      return passThroughError()\n    } else {\n      return remove(to).then(passThroughError, passThroughError)\n    }\n    function passThroughError () {\n      return Promise.reject(err)\n    }\n  })\n\n  function remove (target) {\n    var opts = {\n      unlink: fs.unlink,\n      chmod: fs.chmod,\n      stat: fs.stat,\n      lstat: fs.lstat,\n      rmdir: fs.rmdir,\n      readdir: fs.readdir,\n      glob: false\n    }\n    return rimrafAsync(target, opts)\n  }\n}\n\nfunction copyItem (from, to, opts) {\n  validate('SSO', [from, to, opts])\n  var fs = opts.fs || nodeFs\n  var Promise = opts.Promise || global.Promise\n  var lstat = opts.lstat || promisify(Promise, fs.lstat)\n\n  return lstat(to).then(function () {\n    return Promise.reject(eexists(from, to))\n  }, function (err) {\n    if (err && err.code !== 'ENOENT') return Promise.reject(err)\n    return lstat(from)\n  }).then(function (fromStat) {\n    var cmdOpts = extend(extend({}, opts), fromStat)\n    if (fromStat.isDirectory()) {\n      return recurseDir(from, to, cmdOpts)\n    } else if (fromStat.isSymbolicLink()) {\n      opts.queue.add(1, copySymlink, [from, to, cmdOpts])\n    } else if (fromStat.isFile()) {\n      return copyFile(from, to, cmdOpts)\n    } else if (fromStat.isBlockDevice()) {\n      return Promise.reject(eunsupported(from + \" is a block device, and we don't know how to copy those.\"))\n    } else if (fromStat.isCharacterDevice()) {\n      return Promise.reject(eunsupported(from + \" is a character device, and we don't know how to copy those.\"))\n    } else if (fromStat.isFIFO()) {\n      return Promise.reject(eunsupported(from + \" is a FIFO, and we don't know how to copy those.\"))\n    } else if (fromStat.isSocket()) {\n      return Promise.reject(eunsupported(from + \" is a socket, and we don't know how to copy those.\"))\n    } else {\n      return Promise.reject(eunsupported(\"We can't tell what \" + from + \" is and so we can't copy it.\"))\n    }\n  })\n}\n\nfunction recurseDir (from, to, opts) {\n  validate('SSO', [from, to, opts])\n  var recurseWith = opts.recurseWith || copyItem\n  var fs = opts.fs || nodeFs\n  var chown = opts.chown || promisify(Promise, fs.chown)\n  var readdir = opts.readdir || promisify(Promise, fs.readdir)\n  var mkdirpAsync = opts.mkdirpAsync || promisify(Promise, mkdirp)\n\n  return mkdirpAsync(to, {fs: fs, mode: opts.mode}).then(function () {\n    var getuid = opts.getuid || process.getuid\n    if (getuid && opts.uid != null && getuid() === 0) {\n      return chown(to, opts.uid, opts.gid)\n    }\n  }).then(function () {\n    return readdir(from)\n  }).then(function (files) {\n    files.forEach(function (file) {\n      opts.queue.add(0, recurseWith, [path.join(from, file), path.join(to, file), opts])\n    })\n  })\n}\n\nfunction copySymlink (from, to, opts) {\n  validate('SSO', [from, to, opts])\n  var fs = opts.fs || nodeFs\n  var readlink = opts.readlink || promisify(Promise, fs.readlink)\n  var stat = opts.stat || promisify(Promise, fs.symlink)\n  var symlink = opts.symlink || promisify(Promise, fs.symlink)\n  var Promise = opts.Promise || global.Promise\n\n  return readlink(from).then(function (fromDest) {\n    var absoluteDest = path.resolve(path.dirname(from), fromDest)\n    // Treat absolute paths that are inside the tree we're\n    // copying as relative. This necessary to properly support junctions\n    // on windows (which are always absolute) but is also DWIM with symlinks.\n    var relativeDest = path.relative(opts.top, absoluteDest)\n    var linkFrom = relativeDest.substr(0, 2) === '..' ? fromDest : path.relative(path.dirname(from), absoluteDest)\n    if (opts.isWindows) {\n      return stat(absoluteDest).catch(function () { return null }).then(function (destStat) {\n        var isDir = destStat && destStat.isDirectory()\n        var type = isDir ? 'dir' : 'file'\n        return symlink(linkFrom, to, type).catch(function (err) {\n          if (type === 'dir') {\n            return symlink(linkFrom, to, 'junction')\n          } else {\n            return Promise.reject(err)\n          }\n        })\n      })\n    } else {\n      return symlink(linkFrom, to)\n    }\n  })\n}\n\nfunction copyFile (from, to, opts) {\n  validate('SSO', [from, to, opts])\n  var fs = opts.fs || nodeFs\n  var writeStreamAtomic = opts.writeStreamAtomic || stockWriteStreamAtomic\n  var Promise = opts.Promise || global.Promise\n  var chmod = opts.chmod || promisify(Promise, fs.chmod)\n\n  var writeOpts = {}\n  var getuid = opts.getuid || process.getuid\n  if (getuid && opts.uid != null && getuid() === 0) {\n    writeOpts.chown = {\n      uid: opts.uid,\n      gid: opts.gid\n    }\n  }\n\n  return new Promise(function (resolve, reject) {\n    var errored = false\n    function onError (err) {\n      errored = true\n      reject(err)\n    }\n    fs.createReadStream(from)\n      .once('error', onError)\n      .pipe(writeStreamAtomic(to, writeOpts))\n      .once('error', onError)\n      .once('close', function () {\n        if (errored) return\n        if (opts.mode != null) {\n          resolve(chmod(to, opts.mode))\n        } else {\n          resolve()\n        }\n      })\n  })\n}\n\nfunction eexists (from, to) {\n  var err = new Error('Could not move ' + from + ' to ' + to + ': destination already exists.')\n  err.code = 'EEXIST'\n  return err\n}\n\nfunction eunsupported (msg) {\n  var err = new Error(msg)\n  err.code = 'EUNSUPPORTED'\n  return err\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}