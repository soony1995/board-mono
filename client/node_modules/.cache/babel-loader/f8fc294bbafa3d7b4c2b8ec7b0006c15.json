{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\nconst figgyPudding = require('figgy-pudding');\nconst Transform = require('stream').Transform;\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512'];\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;\nconst SRI_REGEX = /^([^-]+)-([^?]+)([?\\S*]*)$/;\nconst STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)?$/;\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/;\nconst SsriOpts = figgyPudding({\n  algorithms: {\n    default: ['sha512']\n  },\n  error: {\n    default: false\n  },\n  integrity: {},\n  options: {\n    default: []\n  },\n  pickAlgorithm: {\n    default: () => getPrioritizedHash\n  },\n  Promise: {\n    default: () => Promise\n  },\n  sep: {\n    default: ' '\n  },\n  single: {\n    default: false\n  },\n  size: {},\n  strict: {\n    default: false\n  }\n});\nclass Hash {\n  get isHash() {\n    return true;\n  }\n  constructor(hash, opts) {\n    opts = SsriOpts(opts);\n    const strict = !!opts.strict;\n    this.source = hash.trim();\n    // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n    const match = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX);\n    if (!match) {\n      return;\n    }\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) {\n      return;\n    }\n    this.algorithm = match[1];\n    this.digest = match[2];\n    const rawOpts = match[3];\n    this.options = rawOpts ? rawOpts.slice(1).split('?') : [];\n  }\n  hexDigest() {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex');\n  }\n  toJSON() {\n    return this.toString();\n  }\n  toString(opts) {\n    opts = SsriOpts(opts);\n    if (opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!(\n      // The spec has very restricted productions for algorithms.\n      // https://www.w3.org/TR/CSP2/#source-list-syntax\n      SPEC_ALGORITHMS.some(x => x === this.algorithm) &&\n      // Usually, if someone insists on using a \"different\" base64, we\n      // leave it as-is, since there's multiple standards, and the\n      // specified is not a URL-safe variant.\n      // https://www.w3.org/TR/CSP2/#base64_value\n      this.digest.match(BASE64_REGEX) &&\n      // Option syntax is strictly visual chars.\n      // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n      // https://tools.ietf.org/html/rfc5234#appendix-B.1\n      (this.options || []).every(opt => opt.match(VCHAR_REGEX)))) {\n        return '';\n      }\n    }\n    const options = this.options && this.options.length ? `?${this.options.join('?')}` : '';\n    return `${this.algorithm}-${this.digest}${options}`;\n  }\n}\nclass Integrity {\n  get isIntegrity() {\n    return true;\n  }\n  toJSON() {\n    return this.toString();\n  }\n  toString(opts) {\n    opts = SsriOpts(opts);\n    let sep = opts.sep || ' ';\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ');\n    }\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts);\n      }).filter(x => x.length).join(sep);\n    }).filter(x => x.length).join(sep);\n  }\n  concat(integrity, opts) {\n    opts = SsriOpts(opts);\n    const other = typeof integrity === 'string' ? integrity : stringify(integrity, opts);\n    return parse(`${this.toString(opts)} ${other}`, opts);\n  }\n  hexDigest() {\n    return parse(this, {\n      single: true\n    }).hexDigest();\n  }\n  match(integrity, opts) {\n    opts = SsriOpts(opts);\n    const other = parse(integrity, opts);\n    const algo = other.pickAlgorithm(opts);\n    return this[algo] && other[algo] && this[algo].find(hash => other[algo].find(otherhash => hash.digest === otherhash.digest)) || false;\n  }\n  pickAlgorithm(opts) {\n    opts = SsriOpts(opts);\n    const pickAlgorithm = opts.pickAlgorithm;\n    const keys = Object.keys(this);\n    if (!keys.length) {\n      throw new Error(`No algorithms available for ${JSON.stringify(this.toString())}`);\n    }\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc;\n    });\n  }\n}\nmodule.exports.parse = parse;\nfunction parse(sri, opts) {\n  opts = SsriOpts(opts);\n  if (typeof sri === 'string') {\n    return _parse(sri, opts);\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity();\n    fullSri[sri.algorithm] = [sri];\n    return _parse(stringify(fullSri, opts), opts);\n  } else {\n    return _parse(stringify(sri, opts), opts);\n  }\n}\nfunction _parse(integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts);\n  }\n  return integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts);\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm;\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n      acc[algo].push(hash);\n    }\n    return acc;\n  }, new Integrity());\n}\nmodule.exports.stringify = stringify;\nfunction stringify(obj, opts) {\n  opts = SsriOpts(opts);\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts);\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts);\n  } else {\n    return Integrity.prototype.toString.call(obj, opts);\n  }\n}\nmodule.exports.fromHex = fromHex;\nfunction fromHex(hexDigest, algorithm, opts) {\n  opts = SsriOpts(opts);\n  const optString = opts.options && opts.options.length ? `?${opts.options.join('?')}` : '';\n  return parse(`${algorithm}-${Buffer.from(hexDigest, 'hex').toString('base64')}${optString}`, opts);\n}\nmodule.exports.fromData = fromData;\nfunction fromData(data, opts) {\n  opts = SsriOpts(opts);\n  const algorithms = opts.algorithms;\n  const optString = opts.options && opts.options.length ? `?${opts.options.join('?')}` : '';\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64');\n    const hash = new Hash(`${algo}-${digest}${optString}`, opts);\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm;\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n      acc[algo].push(hash);\n    }\n    return acc;\n  }, new Integrity());\n}\nmodule.exports.fromStream = fromStream;\nfunction fromStream(stream, opts) {\n  opts = SsriOpts(opts);\n  const P = opts.Promise || Promise;\n  const istream = integrityStream(opts);\n  return new P((resolve, reject) => {\n    stream.pipe(istream);\n    stream.on('error', reject);\n    istream.on('error', reject);\n    let sri;\n    istream.on('integrity', s => {\n      sri = s;\n    });\n    istream.on('end', () => resolve(sri));\n    istream.on('data', () => {});\n  });\n}\nmodule.exports.checkData = checkData;\nfunction checkData(data, sri, opts) {\n  opts = SsriOpts(opts);\n  sri = parse(sri, opts);\n  if (!Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(new Error('No valid integrity hashes to check against'), {\n        code: 'EINTEGRITY'\n      });\n    } else {\n      return false;\n    }\n  }\n  const algorithm = sri.pickAlgorithm(opts);\n  const digest = crypto.createHash(algorithm).update(data).digest('base64');\n  const newSri = parse({\n    algorithm,\n    digest\n  });\n  const match = newSri.match(sri, opts);\n  if (match || !opts.error) {\n    return match;\n  } else if (typeof opts.size === 'number' && data.length !== opts.size) {\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`);\n    err.code = 'EBADSIZE';\n    err.found = data.length;\n    err.expected = opts.size;\n    err.sri = sri;\n    throw err;\n  } else {\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`);\n    err.code = 'EINTEGRITY';\n    err.found = newSri;\n    err.expected = sri;\n    err.algorithm = algorithm;\n    err.sri = sri;\n    throw err;\n  }\n}\nmodule.exports.checkStream = checkStream;\nfunction checkStream(stream, sri, opts) {\n  opts = SsriOpts(opts);\n  const P = opts.Promise || Promise;\n  const checker = integrityStream(opts.concat({\n    integrity: sri\n  }));\n  return new P((resolve, reject) => {\n    stream.pipe(checker);\n    stream.on('error', reject);\n    checker.on('error', reject);\n    let sri;\n    checker.on('verified', s => {\n      sri = s;\n    });\n    checker.on('end', () => resolve(sri));\n    checker.on('data', () => {});\n  });\n}\nmodule.exports.integrityStream = integrityStream;\nfunction integrityStream(opts) {\n  opts = SsriOpts(opts);\n  // For verification\n  const sri = opts.integrity && parse(opts.integrity, opts);\n  const goodSri = sri && Object.keys(sri).length;\n  const algorithm = goodSri && sri.pickAlgorithm(opts);\n  const digests = goodSri && sri[algorithm];\n  // Calculating stream\n  const algorithms = Array.from(new Set(opts.algorithms.concat(algorithm ? [algorithm] : [])));\n  const hashes = algorithms.map(crypto.createHash);\n  let streamSize = 0;\n  const stream = new Transform({\n    transform(chunk, enc, cb) {\n      streamSize += chunk.length;\n      hashes.forEach(h => h.update(chunk, enc));\n      cb(null, chunk, enc);\n    }\n  }).on('end', () => {\n    const optString = opts.options && opts.options.length ? `?${opts.options.join('?')}` : '';\n    const newSri = parse(hashes.map((h, i) => {\n      return `${algorithms[i]}-${h.digest('base64')}${optString}`;\n    }).join(' '), opts);\n    // Integrity verification mode\n    const match = goodSri && newSri.match(sri, opts);\n    if (typeof opts.size === 'number' && streamSize !== opts.size) {\n      const err = new Error(`stream size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${streamSize}`);\n      err.code = 'EBADSIZE';\n      err.found = streamSize;\n      err.expected = opts.size;\n      err.sri = sri;\n      stream.emit('error', err);\n    } else if (opts.integrity && !match) {\n      const err = new Error(`${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`);\n      err.code = 'EINTEGRITY';\n      err.found = newSri;\n      err.expected = digests;\n      err.algorithm = algorithm;\n      err.sri = sri;\n      stream.emit('error', err);\n    } else {\n      stream.emit('size', streamSize);\n      stream.emit('integrity', newSri);\n      match && stream.emit('verified', match);\n    }\n  });\n  return stream;\n}\nmodule.exports.create = createIntegrity;\nfunction createIntegrity(opts) {\n  opts = SsriOpts(opts);\n  const algorithms = opts.algorithms;\n  const optString = opts.options.length ? `?${opts.options.join('?')}` : '';\n  const hashes = algorithms.map(crypto.createHash);\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc));\n      return this;\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64');\n        const hash = new Hash(`${algo}-${digest}${optString}`, opts);\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm;\n          if (!acc[algo]) {\n            acc[algo] = [];\n          }\n          acc[algo].push(hash);\n        }\n        return acc;\n      }, new Integrity());\n      return integrity;\n    }\n  };\n}\nconst NODE_HASHES = new Set(crypto.getHashes());\n\n// This is a Best Effort™ at a reasonable priority for hash algos\nconst DEFAULT_PRIORITY = ['md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',\n// TODO - it's unclear _which_ of these Node will actually use as its name\n//        for the algorithm, so we guesswork it based on the OpenSSL names.\n'sha3', 'sha3-256', 'sha3-384', 'sha3-512', 'sha3_256', 'sha3_384', 'sha3_512'].filter(algo => NODE_HASHES.has(algo));\nfunction getPrioritizedHash(algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;\n}","map":{"version":3,"names":["crypto","require","figgyPudding","Transform","SPEC_ALGORITHMS","BASE64_REGEX","SRI_REGEX","STRICT_SRI_REGEX","VCHAR_REGEX","SsriOpts","algorithms","default","error","integrity","options","pickAlgorithm","getPrioritizedHash","Promise","sep","single","size","strict","Hash","isHash","constructor","hash","opts","source","trim","match","some","a","algorithm","digest","rawOpts","slice","split","hexDigest","Buffer","from","toString","toJSON","x","every","opt","length","join","Integrity","isIntegrity","replace","Object","keys","map","k","prototype","call","filter","concat","other","stringify","parse","algo","find","otherhash","Error","JSON","reduce","acc","module","exports","sri","_parse","fullSri","string","push","obj","fromHex","optString","fromData","data","createHash","update","fromStream","stream","P","istream","integrityStream","resolve","reject","pipe","on","s","checkData","assign","code","newSri","err","found","expected","checkStream","checker","goodSri","digests","Array","Set","hashes","streamSize","transform","chunk","enc","cb","forEach","h","i","emit","create","createIntegrity","shift","NODE_HASHES","getHashes","DEFAULT_PRIORITY","has","algo1","algo2","indexOf","toLowerCase"],"sources":["/home/soon/bulletin-board/node_modules/webpack/node_modules/ssri/index.js"],"sourcesContent":["'use strict'\n\nconst crypto = require('crypto')\nconst figgyPudding = require('figgy-pudding')\nconst Transform = require('stream').Transform\n\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512']\n\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i\nconst SRI_REGEX = /^([^-]+)-([^?]+)([?\\S*]*)$/\nconst STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)?$/\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/\n\nconst SsriOpts = figgyPudding({\n  algorithms: {default: ['sha512']},\n  error: {default: false},\n  integrity: {},\n  options: {default: []},\n  pickAlgorithm: {default: () => getPrioritizedHash},\n  Promise: {default: () => Promise},\n  sep: {default: ' '},\n  single: {default: false},\n  size: {},\n  strict: {default: false}\n})\n\nclass Hash {\n  get isHash () { return true }\n  constructor (hash, opts) {\n    opts = SsriOpts(opts)\n    const strict = !!opts.strict\n    this.source = hash.trim()\n    // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n    const match = this.source.match(\n      strict\n      ? STRICT_SRI_REGEX\n      : SRI_REGEX\n    )\n    if (!match) { return }\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) { return }\n    this.algorithm = match[1]\n    this.digest = match[2]\n\n    const rawOpts = match[3]\n    this.options = rawOpts ? rawOpts.slice(1).split('?') : []\n  }\n  hexDigest () {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex')\n  }\n  toJSON () {\n    return this.toString()\n  }\n  toString (opts) {\n    opts = SsriOpts(opts)\n    if (opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!(\n        // The spec has very restricted productions for algorithms.\n        // https://www.w3.org/TR/CSP2/#source-list-syntax\n        SPEC_ALGORITHMS.some(x => x === this.algorithm) &&\n        // Usually, if someone insists on using a \"different\" base64, we\n        // leave it as-is, since there's multiple standards, and the\n        // specified is not a URL-safe variant.\n        // https://www.w3.org/TR/CSP2/#base64_value\n        this.digest.match(BASE64_REGEX) &&\n        // Option syntax is strictly visual chars.\n        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n        // https://tools.ietf.org/html/rfc5234#appendix-B.1\n        (this.options || []).every(opt => opt.match(VCHAR_REGEX))\n      )) {\n        return ''\n      }\n    }\n    const options = this.options && this.options.length\n    ? `?${this.options.join('?')}`\n    : ''\n    return `${this.algorithm}-${this.digest}${options}`\n  }\n}\n\nclass Integrity {\n  get isIntegrity () { return true }\n  toJSON () {\n    return this.toString()\n  }\n  toString (opts) {\n    opts = SsriOpts(opts)\n    let sep = opts.sep || ' '\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ')\n    }\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts)\n      }).filter(x => x.length).join(sep)\n    }).filter(x => x.length).join(sep)\n  }\n  concat (integrity, opts) {\n    opts = SsriOpts(opts)\n    const other = typeof integrity === 'string'\n    ? integrity\n    : stringify(integrity, opts)\n    return parse(`${this.toString(opts)} ${other}`, opts)\n  }\n  hexDigest () {\n    return parse(this, {single: true}).hexDigest()\n  }\n  match (integrity, opts) {\n    opts = SsriOpts(opts)\n    const other = parse(integrity, opts)\n    const algo = other.pickAlgorithm(opts)\n    return (\n      this[algo] &&\n      other[algo] &&\n      this[algo].find(hash =>\n        other[algo].find(otherhash =>\n          hash.digest === otherhash.digest\n        )\n      )\n    ) || false\n  }\n  pickAlgorithm (opts) {\n    opts = SsriOpts(opts)\n    const pickAlgorithm = opts.pickAlgorithm\n    const keys = Object.keys(this)\n    if (!keys.length) {\n      throw new Error(`No algorithms available for ${\n        JSON.stringify(this.toString())\n      }`)\n    }\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc\n    })\n  }\n}\n\nmodule.exports.parse = parse\nfunction parse (sri, opts) {\n  opts = SsriOpts(opts)\n  if (typeof sri === 'string') {\n    return _parse(sri, opts)\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity()\n    fullSri[sri.algorithm] = [sri]\n    return _parse(stringify(fullSri, opts), opts)\n  } else {\n    return _parse(stringify(sri, opts), opts)\n  }\n}\n\nfunction _parse (integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts)\n  }\n  return integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts)\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.stringify = stringify\nfunction stringify (obj, opts) {\n  opts = SsriOpts(opts)\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts)\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts)\n  } else {\n    return Integrity.prototype.toString.call(obj, opts)\n  }\n}\n\nmodule.exports.fromHex = fromHex\nfunction fromHex (hexDigest, algorithm, opts) {\n  opts = SsriOpts(opts)\n  const optString = opts.options && opts.options.length\n  ? `?${opts.options.join('?')}`\n  : ''\n  return parse(\n    `${algorithm}-${\n      Buffer.from(hexDigest, 'hex').toString('base64')\n    }${optString}`, opts\n  )\n}\n\nmodule.exports.fromData = fromData\nfunction fromData (data, opts) {\n  opts = SsriOpts(opts)\n  const algorithms = opts.algorithms\n  const optString = opts.options && opts.options.length\n  ? `?${opts.options.join('?')}`\n  : ''\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64')\n    const hash = new Hash(\n      `${algo}-${digest}${optString}`,\n       opts\n    )\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.fromStream = fromStream\nfunction fromStream (stream, opts) {\n  opts = SsriOpts(opts)\n  const P = opts.Promise || Promise\n  const istream = integrityStream(opts)\n  return new P((resolve, reject) => {\n    stream.pipe(istream)\n    stream.on('error', reject)\n    istream.on('error', reject)\n    let sri\n    istream.on('integrity', s => { sri = s })\n    istream.on('end', () => resolve(sri))\n    istream.on('data', () => {})\n  })\n}\n\nmodule.exports.checkData = checkData\nfunction checkData (data, sri, opts) {\n  opts = SsriOpts(opts)\n  sri = parse(sri, opts)\n  if (!Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(\n        new Error('No valid integrity hashes to check against'), {\n          code: 'EINTEGRITY'\n        }\n      )\n    } else {\n      return false\n    }\n  }\n  const algorithm = sri.pickAlgorithm(opts)\n  const digest = crypto.createHash(algorithm).update(data).digest('base64')\n  const newSri = parse({algorithm, digest})\n  const match = newSri.match(sri, opts)\n  if (match || !opts.error) {\n    return match\n  } else if (typeof opts.size === 'number' && (data.length !== opts.size)) {\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`)\n    err.code = 'EBADSIZE'\n    err.found = data.length\n    err.expected = opts.size\n    err.sri = sri\n    throw err\n  } else {\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`)\n    err.code = 'EINTEGRITY'\n    err.found = newSri\n    err.expected = sri\n    err.algorithm = algorithm\n    err.sri = sri\n    throw err\n  }\n}\n\nmodule.exports.checkStream = checkStream\nfunction checkStream (stream, sri, opts) {\n  opts = SsriOpts(opts)\n  const P = opts.Promise || Promise\n  const checker = integrityStream(opts.concat({\n    integrity: sri\n  }))\n  return new P((resolve, reject) => {\n    stream.pipe(checker)\n    stream.on('error', reject)\n    checker.on('error', reject)\n    let sri\n    checker.on('verified', s => { sri = s })\n    checker.on('end', () => resolve(sri))\n    checker.on('data', () => {})\n  })\n}\n\nmodule.exports.integrityStream = integrityStream\nfunction integrityStream (opts) {\n  opts = SsriOpts(opts)\n  // For verification\n  const sri = opts.integrity && parse(opts.integrity, opts)\n  const goodSri = sri && Object.keys(sri).length\n  const algorithm = goodSri && sri.pickAlgorithm(opts)\n  const digests = goodSri && sri[algorithm]\n  // Calculating stream\n  const algorithms = Array.from(\n    new Set(opts.algorithms.concat(algorithm ? [algorithm] : []))\n  )\n  const hashes = algorithms.map(crypto.createHash)\n  let streamSize = 0\n  const stream = new Transform({\n    transform (chunk, enc, cb) {\n      streamSize += chunk.length\n      hashes.forEach(h => h.update(chunk, enc))\n      cb(null, chunk, enc)\n    }\n  }).on('end', () => {\n    const optString = (opts.options && opts.options.length)\n    ? `?${opts.options.join('?')}`\n    : ''\n    const newSri = parse(hashes.map((h, i) => {\n      return `${algorithms[i]}-${h.digest('base64')}${optString}`\n    }).join(' '), opts)\n    // Integrity verification mode\n    const match = goodSri && newSri.match(sri, opts)\n    if (typeof opts.size === 'number' && streamSize !== opts.size) {\n      const err = new Error(`stream size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${streamSize}`)\n      err.code = 'EBADSIZE'\n      err.found = streamSize\n      err.expected = opts.size\n      err.sri = sri\n      stream.emit('error', err)\n    } else if (opts.integrity && !match) {\n      const err = new Error(`${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`)\n      err.code = 'EINTEGRITY'\n      err.found = newSri\n      err.expected = digests\n      err.algorithm = algorithm\n      err.sri = sri\n      stream.emit('error', err)\n    } else {\n      stream.emit('size', streamSize)\n      stream.emit('integrity', newSri)\n      match && stream.emit('verified', match)\n    }\n  })\n  return stream\n}\n\nmodule.exports.create = createIntegrity\nfunction createIntegrity (opts) {\n  opts = SsriOpts(opts)\n  const algorithms = opts.algorithms\n  const optString = opts.options.length\n  ? `?${opts.options.join('?')}`\n  : ''\n\n  const hashes = algorithms.map(crypto.createHash)\n\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc))\n      return this\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64')\n        const hash = new Hash(\n          `${algo}-${digest}${optString}`,\n          opts\n        )\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm\n          if (!acc[algo]) { acc[algo] = [] }\n          acc[algo].push(hash)\n        }\n        return acc\n      }, new Integrity())\n\n      return integrity\n    }\n  }\n}\n\nconst NODE_HASHES = new Set(crypto.getHashes())\n\n// This is a Best Effort™ at a reasonable priority for hash algos\nconst DEFAULT_PRIORITY = [\n  'md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',\n  // TODO - it's unclear _which_ of these Node will actually use as its name\n  //        for the algorithm, so we guesswork it based on the OpenSSL names.\n  'sha3',\n  'sha3-256', 'sha3-384', 'sha3-512',\n  'sha3_256', 'sha3_384', 'sha3_512'\n].filter(algo => NODE_HASHES.has(algo))\n\nfunction getPrioritizedHash (algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())\n  ? algo1\n  : algo2\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}