{"ast":null,"code":"// string literal characters cannot contain control codes\nvar CONTROL_CODES = [0,\n// null\n7,\n// bell\n8,\n// backspace\n9,\n// horizontal\n10,\n// line feed\n11,\n// vertical tab\n12,\n// form feed\n13,\n// carriage return\n26,\n// Control-Z\n27,\n// escape\n127 // delete\n]; // escaped sequences can either be a two character hex value, or one of the\n// following single character codes\n\nfunction decodeControlCharacter(char) {\n  switch (char) {\n    case \"t\":\n      return 0x09;\n    case \"n\":\n      return 0x0a;\n    case \"r\":\n      return 0x0d;\n    case '\"':\n      return 0x22;\n    case \"′\":\n      return 0x27;\n    case \"\\\\\":\n      return 0x5c;\n  }\n  return -1;\n}\nvar ESCAPE_CHAR = 92; // backslash\n\nvar QUOTE_CHAR = 34; // backslash\n// parse string as per the spec:\n// https://webassembly.github.io/spec/core/multipage/text/values.html#text-string\n\nexport function parseString(value) {\n  var byteArray = [];\n  var index = 0;\n  while (index < value.length) {\n    var charCode = value.charCodeAt(index);\n    if (CONTROL_CODES.indexOf(charCode) !== -1) {\n      throw new Error(\"ASCII control characters are not permitted within string literals\");\n    }\n    if (charCode === QUOTE_CHAR) {\n      throw new Error(\"quotes are not permitted within string literals\");\n    }\n    if (charCode === ESCAPE_CHAR) {\n      var firstChar = value.substr(index + 1, 1);\n      var decodedControlChar = decodeControlCharacter(firstChar);\n      if (decodedControlChar !== -1) {\n        // single character escaped values, e.g. \\r\n        byteArray.push(decodedControlChar);\n        index += 2;\n      } else {\n        // hex escaped values, e.g. \\2a\n        var hexValue = value.substr(index + 1, 2);\n        if (!/^[0-9A-F]{2}$/i.test(hexValue)) {\n          throw new Error(\"invalid character encoding\");\n        }\n        byteArray.push(parseInt(hexValue, 16));\n        index += 3;\n      }\n    } else {\n      // ASCII encoded values\n      byteArray.push(charCode);\n      index++;\n    }\n  }\n  return byteArray;\n}","map":{"version":3,"names":["CONTROL_CODES","decodeControlCharacter","char","ESCAPE_CHAR","QUOTE_CHAR","parseString","value","byteArray","index","length","charCode","charCodeAt","indexOf","Error","firstChar","substr","decodedControlChar","push","hexValue","test","parseInt"],"sources":["/home/soon/bulletin-board/node_modules/@webassemblyjs/wast-parser/esm/string-literals.js"],"sourcesContent":["// string literal characters cannot contain control codes\nvar CONTROL_CODES = [0, // null\n7, // bell\n8, // backspace\n9, // horizontal\n10, // line feed\n11, // vertical tab\n12, // form feed\n13, // carriage return\n26, // Control-Z\n27, // escape\n127 // delete\n]; // escaped sequences can either be a two character hex value, or one of the\n// following single character codes\n\nfunction decodeControlCharacter(char) {\n  switch (char) {\n    case \"t\":\n      return 0x09;\n\n    case \"n\":\n      return 0x0a;\n\n    case \"r\":\n      return 0x0d;\n\n    case '\"':\n      return 0x22;\n\n    case \"′\":\n      return 0x27;\n\n    case \"\\\\\":\n      return 0x5c;\n  }\n\n  return -1;\n}\n\nvar ESCAPE_CHAR = 92; // backslash\n\nvar QUOTE_CHAR = 34; // backslash\n// parse string as per the spec:\n// https://webassembly.github.io/spec/core/multipage/text/values.html#text-string\n\nexport function parseString(value) {\n  var byteArray = [];\n  var index = 0;\n\n  while (index < value.length) {\n    var charCode = value.charCodeAt(index);\n\n    if (CONTROL_CODES.indexOf(charCode) !== -1) {\n      throw new Error(\"ASCII control characters are not permitted within string literals\");\n    }\n\n    if (charCode === QUOTE_CHAR) {\n      throw new Error(\"quotes are not permitted within string literals\");\n    }\n\n    if (charCode === ESCAPE_CHAR) {\n      var firstChar = value.substr(index + 1, 1);\n      var decodedControlChar = decodeControlCharacter(firstChar);\n\n      if (decodedControlChar !== -1) {\n        // single character escaped values, e.g. \\r\n        byteArray.push(decodedControlChar);\n        index += 2;\n      } else {\n        // hex escaped values, e.g. \\2a\n        var hexValue = value.substr(index + 1, 2);\n\n        if (!/^[0-9A-F]{2}$/i.test(hexValue)) {\n          throw new Error(\"invalid character encoding\");\n        }\n\n        byteArray.push(parseInt(hexValue, 16));\n        index += 3;\n      }\n    } else {\n      // ASCII encoded values\n      byteArray.push(charCode);\n      index++;\n    }\n  }\n\n  return byteArray;\n}"],"mappings":"AAAA;AACA,IAAIA,aAAa,GAAG,CAAC,CAAC;AAAE;AACxB,CAAC;AAAE;AACH,CAAC;AAAE;AACH,CAAC;AAAE;AACH,EAAE;AAAE;AACJ,EAAE;AAAE;AACJ,EAAE;AAAE;AACJ,EAAE;AAAE;AACJ,EAAE;AAAE;AACJ,EAAE;AAAE;AACJ,GAAG,CAAC;AAAA,CACH,CAAC,CAAC;AACH;;AAEA,SAASC,sBAAsBA,CAACC,IAAI,EAAE;EACpC,QAAQA,IAAI;IACV,KAAK,GAAG;MACN,OAAO,IAAI;IAEb,KAAK,GAAG;MACN,OAAO,IAAI;IAEb,KAAK,GAAG;MACN,OAAO,IAAI;IAEb,KAAK,GAAG;MACN,OAAO,IAAI;IAEb,KAAK,GAAG;MACN,OAAO,IAAI;IAEb,KAAK,IAAI;MACP,OAAO,IAAI;EACf;EAEA,OAAO,CAAC,CAAC;AACX;AAEA,IAAIC,WAAW,GAAG,EAAE,CAAC,CAAC;;AAEtB,IAAIC,UAAU,GAAG,EAAE,CAAC,CAAC;AACrB;AACA;;AAEA,OAAO,SAASC,WAAWA,CAACC,KAAK,EAAE;EACjC,IAAIC,SAAS,GAAG,EAAE;EAClB,IAAIC,KAAK,GAAG,CAAC;EAEb,OAAOA,KAAK,GAAGF,KAAK,CAACG,MAAM,EAAE;IAC3B,IAAIC,QAAQ,GAAGJ,KAAK,CAACK,UAAU,CAACH,KAAK,CAAC;IAEtC,IAAIR,aAAa,CAACY,OAAO,CAACF,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;MAC1C,MAAM,IAAIG,KAAK,CAAC,mEAAmE,CAAC;IACtF;IAEA,IAAIH,QAAQ,KAAKN,UAAU,EAAE;MAC3B,MAAM,IAAIS,KAAK,CAAC,iDAAiD,CAAC;IACpE;IAEA,IAAIH,QAAQ,KAAKP,WAAW,EAAE;MAC5B,IAAIW,SAAS,GAAGR,KAAK,CAACS,MAAM,CAACP,KAAK,GAAG,CAAC,EAAE,CAAC,CAAC;MAC1C,IAAIQ,kBAAkB,GAAGf,sBAAsB,CAACa,SAAS,CAAC;MAE1D,IAAIE,kBAAkB,KAAK,CAAC,CAAC,EAAE;QAC7B;QACAT,SAAS,CAACU,IAAI,CAACD,kBAAkB,CAAC;QAClCR,KAAK,IAAI,CAAC;MACZ,CAAC,MAAM;QACL;QACA,IAAIU,QAAQ,GAAGZ,KAAK,CAACS,MAAM,CAACP,KAAK,GAAG,CAAC,EAAE,CAAC,CAAC;QAEzC,IAAI,CAAC,gBAAgB,CAACW,IAAI,CAACD,QAAQ,CAAC,EAAE;UACpC,MAAM,IAAIL,KAAK,CAAC,4BAA4B,CAAC;QAC/C;QAEAN,SAAS,CAACU,IAAI,CAACG,QAAQ,CAACF,QAAQ,EAAE,EAAE,CAAC,CAAC;QACtCV,KAAK,IAAI,CAAC;MACZ;IACF,CAAC,MAAM;MACL;MACAD,SAAS,CAACU,IAAI,CAACP,QAAQ,CAAC;MACxBF,KAAK,EAAE;IACT;EACF;EAEA,OAAOD,SAAS;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module"}